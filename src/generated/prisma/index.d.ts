
/**
 * Client
**/

import * as runtime from './runtime/client.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model ClientPet
 * 
 */
export type ClientPet = $Result.DefaultSelection<Prisma.$ClientPetPayload>
/**
 * Model Pet
 * 
 */
export type Pet = $Result.DefaultSelection<Prisma.$PetPayload>
/**
 * Model Race
 * 
 */
export type Race = $Result.DefaultSelection<Prisma.$RacePayload>
/**
 * Model Vaccine
 * 
 */
export type Vaccine = $Result.DefaultSelection<Prisma.$VaccinePayload>
/**
 * Model PersonalPetVaccine
 * 
 */
export type PersonalPetVaccine = $Result.DefaultSelection<Prisma.$PersonalPetVaccinePayload>
/**
 * Model Metting
 * 
 */
export type Metting = $Result.DefaultSelection<Prisma.$MettingPayload>
/**
 * Model Product
 * 
 */
export type Product = $Result.DefaultSelection<Prisma.$ProductPayload>
/**
 * Model Food
 * 
 */
export type Food = $Result.DefaultSelection<Prisma.$FoodPayload>
/**
 * Model Brand
 * 
 */
export type Brand = $Result.DefaultSelection<Prisma.$BrandPayload>
/**
 * Model ClinicProduct
 * 
 */
export type ClinicProduct = $Result.DefaultSelection<Prisma.$ClinicProductPayload>
/**
 * Model FoodPet
 * 
 */
export type FoodPet = $Result.DefaultSelection<Prisma.$FoodPetPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model ClientProfile
 * 
 */
export type ClientProfile = $Result.DefaultSelection<Prisma.$ClientProfilePayload>
/**
 * Model VeterinarianProfile
 * 
 */
export type VeterinarianProfile = $Result.DefaultSelection<Prisma.$VeterinarianProfilePayload>
/**
 * Model ClinicProfile
 * 
 */
export type ClinicProfile = $Result.DefaultSelection<Prisma.$ClinicProfilePayload>
/**
 * Model SecretaryProfile
 * 
 */
export type SecretaryProfile = $Result.DefaultSelection<Prisma.$SecretaryProfilePayload>

/**
 * Enums
 */
export namespace $Enums {
  export const FoodType: {
  KIBBLE: 'KIBBLE',
  WET: 'WET'
};

export type FoodType = (typeof FoodType)[keyof typeof FoodType]


export const FoodPetDay: {
  MONDAY: 'MONDAY',
  TUESDAY: 'TUESDAY',
  WEDNESDAY: 'WEDNESDAY',
  THURSDAY: 'THURSDAY',
  FRIDAY: 'FRIDAY',
  SATURDAY: 'SATURDAY',
  SUNDAY: 'SUNDAY'
};

export type FoodPetDay = (typeof FoodPetDay)[keyof typeof FoodPetDay]


export const UserRole: {
  CLIENT: 'CLIENT',
  ADMIN: 'ADMIN',
  SECRETARY: 'SECRETARY',
  VETERINARIAN: 'VETERINARIAN',
  CLINIC: 'CLINIC'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]

}

export type FoodType = $Enums.FoodType

export const FoodType: typeof $Enums.FoodType

export type FoodPetDay = $Enums.FoodPetDay

export const FoodPetDay: typeof $Enums.FoodPetDay

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more ClientPets
 * const clientPets = await prisma.clientPet.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://pris.ly/d/client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more ClientPets
   * const clientPets = await prisma.clientPet.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://pris.ly/d/client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>

  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.clientPet`: Exposes CRUD operations for the **ClientPet** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ClientPets
    * const clientPets = await prisma.clientPet.findMany()
    * ```
    */
  get clientPet(): Prisma.ClientPetDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pet`: Exposes CRUD operations for the **Pet** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pets
    * const pets = await prisma.pet.findMany()
    * ```
    */
  get pet(): Prisma.PetDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.race`: Exposes CRUD operations for the **Race** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Races
    * const races = await prisma.race.findMany()
    * ```
    */
  get race(): Prisma.RaceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.vaccine`: Exposes CRUD operations for the **Vaccine** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Vaccines
    * const vaccines = await prisma.vaccine.findMany()
    * ```
    */
  get vaccine(): Prisma.VaccineDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.personalPetVaccine`: Exposes CRUD operations for the **PersonalPetVaccine** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PersonalPetVaccines
    * const personalPetVaccines = await prisma.personalPetVaccine.findMany()
    * ```
    */
  get personalPetVaccine(): Prisma.PersonalPetVaccineDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.metting`: Exposes CRUD operations for the **Metting** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Mettings
    * const mettings = await prisma.metting.findMany()
    * ```
    */
  get metting(): Prisma.MettingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.product`: Exposes CRUD operations for the **Product** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products
    * const products = await prisma.product.findMany()
    * ```
    */
  get product(): Prisma.ProductDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.food`: Exposes CRUD operations for the **Food** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Foods
    * const foods = await prisma.food.findMany()
    * ```
    */
  get food(): Prisma.FoodDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.brand`: Exposes CRUD operations for the **Brand** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Brands
    * const brands = await prisma.brand.findMany()
    * ```
    */
  get brand(): Prisma.BrandDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.clinicProduct`: Exposes CRUD operations for the **ClinicProduct** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ClinicProducts
    * const clinicProducts = await prisma.clinicProduct.findMany()
    * ```
    */
  get clinicProduct(): Prisma.ClinicProductDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.foodPet`: Exposes CRUD operations for the **FoodPet** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FoodPets
    * const foodPets = await prisma.foodPet.findMany()
    * ```
    */
  get foodPet(): Prisma.FoodPetDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.clientProfile`: Exposes CRUD operations for the **ClientProfile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ClientProfiles
    * const clientProfiles = await prisma.clientProfile.findMany()
    * ```
    */
  get clientProfile(): Prisma.ClientProfileDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.veterinarianProfile`: Exposes CRUD operations for the **VeterinarianProfile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VeterinarianProfiles
    * const veterinarianProfiles = await prisma.veterinarianProfile.findMany()
    * ```
    */
  get veterinarianProfile(): Prisma.VeterinarianProfileDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.clinicProfile`: Exposes CRUD operations for the **ClinicProfile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ClinicProfiles
    * const clinicProfiles = await prisma.clinicProfile.findMany()
    * ```
    */
  get clinicProfile(): Prisma.ClinicProfileDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.secretaryProfile`: Exposes CRUD operations for the **SecretaryProfile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SecretaryProfiles
    * const secretaryProfiles = await prisma.secretaryProfile.findMany()
    * ```
    */
  get secretaryProfile(): Prisma.SecretaryProfileDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 7.3.0
   * Query Engine version: 9d6ad21cbbceab97458517b147a6a09ff43aa735
   */
  export type PrismaVersion = {
    client: string
    engine: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    ClientPet: 'ClientPet',
    Pet: 'Pet',
    Race: 'Race',
    Vaccine: 'Vaccine',
    PersonalPetVaccine: 'PersonalPetVaccine',
    Metting: 'Metting',
    Product: 'Product',
    Food: 'Food',
    Brand: 'Brand',
    ClinicProduct: 'ClinicProduct',
    FoodPet: 'FoodPet',
    User: 'User',
    ClientProfile: 'ClientProfile',
    VeterinarianProfile: 'VeterinarianProfile',
    ClinicProfile: 'ClinicProfile',
    SecretaryProfile: 'SecretaryProfile'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]



  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "clientPet" | "pet" | "race" | "vaccine" | "personalPetVaccine" | "metting" | "product" | "food" | "brand" | "clinicProduct" | "foodPet" | "user" | "clientProfile" | "veterinarianProfile" | "clinicProfile" | "secretaryProfile"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      ClientPet: {
        payload: Prisma.$ClientPetPayload<ExtArgs>
        fields: Prisma.ClientPetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClientPetFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClientPetFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPetPayload>
          }
          findFirst: {
            args: Prisma.ClientPetFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClientPetFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPetPayload>
          }
          findMany: {
            args: Prisma.ClientPetFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPetPayload>[]
          }
          create: {
            args: Prisma.ClientPetCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPetPayload>
          }
          createMany: {
            args: Prisma.ClientPetCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClientPetCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPetPayload>[]
          }
          delete: {
            args: Prisma.ClientPetDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPetPayload>
          }
          update: {
            args: Prisma.ClientPetUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPetPayload>
          }
          deleteMany: {
            args: Prisma.ClientPetDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClientPetUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ClientPetUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPetPayload>[]
          }
          upsert: {
            args: Prisma.ClientPetUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPetPayload>
          }
          aggregate: {
            args: Prisma.ClientPetAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClientPet>
          }
          groupBy: {
            args: Prisma.ClientPetGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClientPetGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClientPetCountArgs<ExtArgs>
            result: $Utils.Optional<ClientPetCountAggregateOutputType> | number
          }
        }
      }
      Pet: {
        payload: Prisma.$PetPayload<ExtArgs>
        fields: Prisma.PetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PetFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PetFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PetPayload>
          }
          findFirst: {
            args: Prisma.PetFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PetFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PetPayload>
          }
          findMany: {
            args: Prisma.PetFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PetPayload>[]
          }
          create: {
            args: Prisma.PetCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PetPayload>
          }
          createMany: {
            args: Prisma.PetCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PetCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PetPayload>[]
          }
          delete: {
            args: Prisma.PetDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PetPayload>
          }
          update: {
            args: Prisma.PetUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PetPayload>
          }
          deleteMany: {
            args: Prisma.PetDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PetUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PetUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PetPayload>[]
          }
          upsert: {
            args: Prisma.PetUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PetPayload>
          }
          aggregate: {
            args: Prisma.PetAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePet>
          }
          groupBy: {
            args: Prisma.PetGroupByArgs<ExtArgs>
            result: $Utils.Optional<PetGroupByOutputType>[]
          }
          count: {
            args: Prisma.PetCountArgs<ExtArgs>
            result: $Utils.Optional<PetCountAggregateOutputType> | number
          }
        }
      }
      Race: {
        payload: Prisma.$RacePayload<ExtArgs>
        fields: Prisma.RaceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RaceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RacePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RaceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RacePayload>
          }
          findFirst: {
            args: Prisma.RaceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RacePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RaceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RacePayload>
          }
          findMany: {
            args: Prisma.RaceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RacePayload>[]
          }
          create: {
            args: Prisma.RaceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RacePayload>
          }
          createMany: {
            args: Prisma.RaceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RaceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RacePayload>[]
          }
          delete: {
            args: Prisma.RaceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RacePayload>
          }
          update: {
            args: Prisma.RaceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RacePayload>
          }
          deleteMany: {
            args: Prisma.RaceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RaceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RaceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RacePayload>[]
          }
          upsert: {
            args: Prisma.RaceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RacePayload>
          }
          aggregate: {
            args: Prisma.RaceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRace>
          }
          groupBy: {
            args: Prisma.RaceGroupByArgs<ExtArgs>
            result: $Utils.Optional<RaceGroupByOutputType>[]
          }
          count: {
            args: Prisma.RaceCountArgs<ExtArgs>
            result: $Utils.Optional<RaceCountAggregateOutputType> | number
          }
        }
      }
      Vaccine: {
        payload: Prisma.$VaccinePayload<ExtArgs>
        fields: Prisma.VaccineFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VaccineFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VaccinePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VaccineFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VaccinePayload>
          }
          findFirst: {
            args: Prisma.VaccineFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VaccinePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VaccineFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VaccinePayload>
          }
          findMany: {
            args: Prisma.VaccineFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VaccinePayload>[]
          }
          create: {
            args: Prisma.VaccineCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VaccinePayload>
          }
          createMany: {
            args: Prisma.VaccineCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VaccineCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VaccinePayload>[]
          }
          delete: {
            args: Prisma.VaccineDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VaccinePayload>
          }
          update: {
            args: Prisma.VaccineUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VaccinePayload>
          }
          deleteMany: {
            args: Prisma.VaccineDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VaccineUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VaccineUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VaccinePayload>[]
          }
          upsert: {
            args: Prisma.VaccineUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VaccinePayload>
          }
          aggregate: {
            args: Prisma.VaccineAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVaccine>
          }
          groupBy: {
            args: Prisma.VaccineGroupByArgs<ExtArgs>
            result: $Utils.Optional<VaccineGroupByOutputType>[]
          }
          count: {
            args: Prisma.VaccineCountArgs<ExtArgs>
            result: $Utils.Optional<VaccineCountAggregateOutputType> | number
          }
        }
      }
      PersonalPetVaccine: {
        payload: Prisma.$PersonalPetVaccinePayload<ExtArgs>
        fields: Prisma.PersonalPetVaccineFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PersonalPetVaccineFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonalPetVaccinePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PersonalPetVaccineFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonalPetVaccinePayload>
          }
          findFirst: {
            args: Prisma.PersonalPetVaccineFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonalPetVaccinePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PersonalPetVaccineFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonalPetVaccinePayload>
          }
          findMany: {
            args: Prisma.PersonalPetVaccineFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonalPetVaccinePayload>[]
          }
          create: {
            args: Prisma.PersonalPetVaccineCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonalPetVaccinePayload>
          }
          createMany: {
            args: Prisma.PersonalPetVaccineCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PersonalPetVaccineCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonalPetVaccinePayload>[]
          }
          delete: {
            args: Prisma.PersonalPetVaccineDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonalPetVaccinePayload>
          }
          update: {
            args: Prisma.PersonalPetVaccineUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonalPetVaccinePayload>
          }
          deleteMany: {
            args: Prisma.PersonalPetVaccineDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PersonalPetVaccineUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PersonalPetVaccineUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonalPetVaccinePayload>[]
          }
          upsert: {
            args: Prisma.PersonalPetVaccineUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonalPetVaccinePayload>
          }
          aggregate: {
            args: Prisma.PersonalPetVaccineAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePersonalPetVaccine>
          }
          groupBy: {
            args: Prisma.PersonalPetVaccineGroupByArgs<ExtArgs>
            result: $Utils.Optional<PersonalPetVaccineGroupByOutputType>[]
          }
          count: {
            args: Prisma.PersonalPetVaccineCountArgs<ExtArgs>
            result: $Utils.Optional<PersonalPetVaccineCountAggregateOutputType> | number
          }
        }
      }
      Metting: {
        payload: Prisma.$MettingPayload<ExtArgs>
        fields: Prisma.MettingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MettingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MettingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MettingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MettingPayload>
          }
          findFirst: {
            args: Prisma.MettingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MettingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MettingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MettingPayload>
          }
          findMany: {
            args: Prisma.MettingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MettingPayload>[]
          }
          create: {
            args: Prisma.MettingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MettingPayload>
          }
          createMany: {
            args: Prisma.MettingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MettingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MettingPayload>[]
          }
          delete: {
            args: Prisma.MettingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MettingPayload>
          }
          update: {
            args: Prisma.MettingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MettingPayload>
          }
          deleteMany: {
            args: Prisma.MettingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MettingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MettingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MettingPayload>[]
          }
          upsert: {
            args: Prisma.MettingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MettingPayload>
          }
          aggregate: {
            args: Prisma.MettingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMetting>
          }
          groupBy: {
            args: Prisma.MettingGroupByArgs<ExtArgs>
            result: $Utils.Optional<MettingGroupByOutputType>[]
          }
          count: {
            args: Prisma.MettingCountArgs<ExtArgs>
            result: $Utils.Optional<MettingCountAggregateOutputType> | number
          }
        }
      }
      Product: {
        payload: Prisma.$ProductPayload<ExtArgs>
        fields: Prisma.ProductFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findFirst: {
            args: Prisma.ProductFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findMany: {
            args: Prisma.ProductFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          create: {
            args: Prisma.ProductCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          createMany: {
            args: Prisma.ProductCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          delete: {
            args: Prisma.ProductDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          update: {
            args: Prisma.ProductUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          deleteMany: {
            args: Prisma.ProductDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          upsert: {
            args: Prisma.ProductUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          aggregate: {
            args: Prisma.ProductAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProduct>
          }
          groupBy: {
            args: Prisma.ProductGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductCountArgs<ExtArgs>
            result: $Utils.Optional<ProductCountAggregateOutputType> | number
          }
        }
      }
      Food: {
        payload: Prisma.$FoodPayload<ExtArgs>
        fields: Prisma.FoodFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FoodFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FoodFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodPayload>
          }
          findFirst: {
            args: Prisma.FoodFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FoodFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodPayload>
          }
          findMany: {
            args: Prisma.FoodFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodPayload>[]
          }
          create: {
            args: Prisma.FoodCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodPayload>
          }
          createMany: {
            args: Prisma.FoodCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FoodCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodPayload>[]
          }
          delete: {
            args: Prisma.FoodDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodPayload>
          }
          update: {
            args: Prisma.FoodUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodPayload>
          }
          deleteMany: {
            args: Prisma.FoodDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FoodUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FoodUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodPayload>[]
          }
          upsert: {
            args: Prisma.FoodUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodPayload>
          }
          aggregate: {
            args: Prisma.FoodAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFood>
          }
          groupBy: {
            args: Prisma.FoodGroupByArgs<ExtArgs>
            result: $Utils.Optional<FoodGroupByOutputType>[]
          }
          count: {
            args: Prisma.FoodCountArgs<ExtArgs>
            result: $Utils.Optional<FoodCountAggregateOutputType> | number
          }
        }
      }
      Brand: {
        payload: Prisma.$BrandPayload<ExtArgs>
        fields: Prisma.BrandFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BrandFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrandPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BrandFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrandPayload>
          }
          findFirst: {
            args: Prisma.BrandFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrandPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BrandFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrandPayload>
          }
          findMany: {
            args: Prisma.BrandFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrandPayload>[]
          }
          create: {
            args: Prisma.BrandCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrandPayload>
          }
          createMany: {
            args: Prisma.BrandCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BrandCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrandPayload>[]
          }
          delete: {
            args: Prisma.BrandDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrandPayload>
          }
          update: {
            args: Prisma.BrandUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrandPayload>
          }
          deleteMany: {
            args: Prisma.BrandDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BrandUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BrandUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrandPayload>[]
          }
          upsert: {
            args: Prisma.BrandUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrandPayload>
          }
          aggregate: {
            args: Prisma.BrandAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBrand>
          }
          groupBy: {
            args: Prisma.BrandGroupByArgs<ExtArgs>
            result: $Utils.Optional<BrandGroupByOutputType>[]
          }
          count: {
            args: Prisma.BrandCountArgs<ExtArgs>
            result: $Utils.Optional<BrandCountAggregateOutputType> | number
          }
        }
      }
      ClinicProduct: {
        payload: Prisma.$ClinicProductPayload<ExtArgs>
        fields: Prisma.ClinicProductFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClinicProductFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicProductPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClinicProductFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicProductPayload>
          }
          findFirst: {
            args: Prisma.ClinicProductFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicProductPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClinicProductFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicProductPayload>
          }
          findMany: {
            args: Prisma.ClinicProductFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicProductPayload>[]
          }
          create: {
            args: Prisma.ClinicProductCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicProductPayload>
          }
          createMany: {
            args: Prisma.ClinicProductCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClinicProductCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicProductPayload>[]
          }
          delete: {
            args: Prisma.ClinicProductDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicProductPayload>
          }
          update: {
            args: Prisma.ClinicProductUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicProductPayload>
          }
          deleteMany: {
            args: Prisma.ClinicProductDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClinicProductUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ClinicProductUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicProductPayload>[]
          }
          upsert: {
            args: Prisma.ClinicProductUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicProductPayload>
          }
          aggregate: {
            args: Prisma.ClinicProductAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClinicProduct>
          }
          groupBy: {
            args: Prisma.ClinicProductGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClinicProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClinicProductCountArgs<ExtArgs>
            result: $Utils.Optional<ClinicProductCountAggregateOutputType> | number
          }
        }
      }
      FoodPet: {
        payload: Prisma.$FoodPetPayload<ExtArgs>
        fields: Prisma.FoodPetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FoodPetFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodPetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FoodPetFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodPetPayload>
          }
          findFirst: {
            args: Prisma.FoodPetFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodPetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FoodPetFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodPetPayload>
          }
          findMany: {
            args: Prisma.FoodPetFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodPetPayload>[]
          }
          create: {
            args: Prisma.FoodPetCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodPetPayload>
          }
          createMany: {
            args: Prisma.FoodPetCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FoodPetCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodPetPayload>[]
          }
          delete: {
            args: Prisma.FoodPetDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodPetPayload>
          }
          update: {
            args: Prisma.FoodPetUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodPetPayload>
          }
          deleteMany: {
            args: Prisma.FoodPetDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FoodPetUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FoodPetUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodPetPayload>[]
          }
          upsert: {
            args: Prisma.FoodPetUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodPetPayload>
          }
          aggregate: {
            args: Prisma.FoodPetAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFoodPet>
          }
          groupBy: {
            args: Prisma.FoodPetGroupByArgs<ExtArgs>
            result: $Utils.Optional<FoodPetGroupByOutputType>[]
          }
          count: {
            args: Prisma.FoodPetCountArgs<ExtArgs>
            result: $Utils.Optional<FoodPetCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      ClientProfile: {
        payload: Prisma.$ClientProfilePayload<ExtArgs>
        fields: Prisma.ClientProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClientProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClientProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientProfilePayload>
          }
          findFirst: {
            args: Prisma.ClientProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClientProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientProfilePayload>
          }
          findMany: {
            args: Prisma.ClientProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientProfilePayload>[]
          }
          create: {
            args: Prisma.ClientProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientProfilePayload>
          }
          createMany: {
            args: Prisma.ClientProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClientProfileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientProfilePayload>[]
          }
          delete: {
            args: Prisma.ClientProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientProfilePayload>
          }
          update: {
            args: Prisma.ClientProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientProfilePayload>
          }
          deleteMany: {
            args: Prisma.ClientProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClientProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ClientProfileUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientProfilePayload>[]
          }
          upsert: {
            args: Prisma.ClientProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientProfilePayload>
          }
          aggregate: {
            args: Prisma.ClientProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClientProfile>
          }
          groupBy: {
            args: Prisma.ClientProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClientProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClientProfileCountArgs<ExtArgs>
            result: $Utils.Optional<ClientProfileCountAggregateOutputType> | number
          }
        }
      }
      VeterinarianProfile: {
        payload: Prisma.$VeterinarianProfilePayload<ExtArgs>
        fields: Prisma.VeterinarianProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VeterinarianProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VeterinarianProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VeterinarianProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VeterinarianProfilePayload>
          }
          findFirst: {
            args: Prisma.VeterinarianProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VeterinarianProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VeterinarianProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VeterinarianProfilePayload>
          }
          findMany: {
            args: Prisma.VeterinarianProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VeterinarianProfilePayload>[]
          }
          create: {
            args: Prisma.VeterinarianProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VeterinarianProfilePayload>
          }
          createMany: {
            args: Prisma.VeterinarianProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VeterinarianProfileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VeterinarianProfilePayload>[]
          }
          delete: {
            args: Prisma.VeterinarianProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VeterinarianProfilePayload>
          }
          update: {
            args: Prisma.VeterinarianProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VeterinarianProfilePayload>
          }
          deleteMany: {
            args: Prisma.VeterinarianProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VeterinarianProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VeterinarianProfileUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VeterinarianProfilePayload>[]
          }
          upsert: {
            args: Prisma.VeterinarianProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VeterinarianProfilePayload>
          }
          aggregate: {
            args: Prisma.VeterinarianProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVeterinarianProfile>
          }
          groupBy: {
            args: Prisma.VeterinarianProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<VeterinarianProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.VeterinarianProfileCountArgs<ExtArgs>
            result: $Utils.Optional<VeterinarianProfileCountAggregateOutputType> | number
          }
        }
      }
      ClinicProfile: {
        payload: Prisma.$ClinicProfilePayload<ExtArgs>
        fields: Prisma.ClinicProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClinicProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClinicProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicProfilePayload>
          }
          findFirst: {
            args: Prisma.ClinicProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClinicProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicProfilePayload>
          }
          findMany: {
            args: Prisma.ClinicProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicProfilePayload>[]
          }
          create: {
            args: Prisma.ClinicProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicProfilePayload>
          }
          createMany: {
            args: Prisma.ClinicProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClinicProfileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicProfilePayload>[]
          }
          delete: {
            args: Prisma.ClinicProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicProfilePayload>
          }
          update: {
            args: Prisma.ClinicProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicProfilePayload>
          }
          deleteMany: {
            args: Prisma.ClinicProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClinicProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ClinicProfileUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicProfilePayload>[]
          }
          upsert: {
            args: Prisma.ClinicProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicProfilePayload>
          }
          aggregate: {
            args: Prisma.ClinicProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClinicProfile>
          }
          groupBy: {
            args: Prisma.ClinicProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClinicProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClinicProfileCountArgs<ExtArgs>
            result: $Utils.Optional<ClinicProfileCountAggregateOutputType> | number
          }
        }
      }
      SecretaryProfile: {
        payload: Prisma.$SecretaryProfilePayload<ExtArgs>
        fields: Prisma.SecretaryProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SecretaryProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecretaryProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SecretaryProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecretaryProfilePayload>
          }
          findFirst: {
            args: Prisma.SecretaryProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecretaryProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SecretaryProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecretaryProfilePayload>
          }
          findMany: {
            args: Prisma.SecretaryProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecretaryProfilePayload>[]
          }
          create: {
            args: Prisma.SecretaryProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecretaryProfilePayload>
          }
          createMany: {
            args: Prisma.SecretaryProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SecretaryProfileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecretaryProfilePayload>[]
          }
          delete: {
            args: Prisma.SecretaryProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecretaryProfilePayload>
          }
          update: {
            args: Prisma.SecretaryProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecretaryProfilePayload>
          }
          deleteMany: {
            args: Prisma.SecretaryProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SecretaryProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SecretaryProfileUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecretaryProfilePayload>[]
          }
          upsert: {
            args: Prisma.SecretaryProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecretaryProfilePayload>
          }
          aggregate: {
            args: Prisma.SecretaryProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSecretaryProfile>
          }
          groupBy: {
            args: Prisma.SecretaryProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<SecretaryProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.SecretaryProfileCountArgs<ExtArgs>
            result: $Utils.Optional<SecretaryProfileCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://pris.ly/d/logging).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory
    /**
     * Prisma Accelerate URL allowing the client to connect through Accelerate instead of a direct database.
     */
    accelerateUrl?: string
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
    /**
     * SQL commenter plugins that add metadata to SQL queries as comments.
     * Comments follow the sqlcommenter format: https://google.github.io/sqlcommenter/
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   adapter,
     *   comments: [
     *     traceContext(),
     *     queryInsights(),
     *   ],
     * })
     * ```
     */
    comments?: runtime.SqlCommenterPlugin[]
  }
  export type GlobalOmitConfig = {
    clientPet?: ClientPetOmit
    pet?: PetOmit
    race?: RaceOmit
    vaccine?: VaccineOmit
    personalPetVaccine?: PersonalPetVaccineOmit
    metting?: MettingOmit
    product?: ProductOmit
    food?: FoodOmit
    brand?: BrandOmit
    clinicProduct?: ClinicProductOmit
    foodPet?: FoodPetOmit
    user?: UserOmit
    clientProfile?: ClientProfileOmit
    veterinarianProfile?: VeterinarianProfileOmit
    clinicProfile?: ClinicProfileOmit
    secretaryProfile?: SecretaryProfileOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type ClientPetCountOutputType
   */

  export type ClientPetCountOutputType = {
    personalPetVaccine: number
    metting: number
    foodPets: number
  }

  export type ClientPetCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    personalPetVaccine?: boolean | ClientPetCountOutputTypeCountPersonalPetVaccineArgs
    metting?: boolean | ClientPetCountOutputTypeCountMettingArgs
    foodPets?: boolean | ClientPetCountOutputTypeCountFoodPetsArgs
  }

  // Custom InputTypes
  /**
   * ClientPetCountOutputType without action
   */
  export type ClientPetCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientPetCountOutputType
     */
    select?: ClientPetCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ClientPetCountOutputType without action
   */
  export type ClientPetCountOutputTypeCountPersonalPetVaccineArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PersonalPetVaccineWhereInput
  }

  /**
   * ClientPetCountOutputType without action
   */
  export type ClientPetCountOutputTypeCountMettingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MettingWhereInput
  }

  /**
   * ClientPetCountOutputType without action
   */
  export type ClientPetCountOutputTypeCountFoodPetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FoodPetWhereInput
  }


  /**
   * Count Type PetCountOutputType
   */

  export type PetCountOutputType = {
    races: number
    vaccine: number
  }

  export type PetCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    races?: boolean | PetCountOutputTypeCountRacesArgs
    vaccine?: boolean | PetCountOutputTypeCountVaccineArgs
  }

  // Custom InputTypes
  /**
   * PetCountOutputType without action
   */
  export type PetCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PetCountOutputType
     */
    select?: PetCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PetCountOutputType without action
   */
  export type PetCountOutputTypeCountRacesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RaceWhereInput
  }

  /**
   * PetCountOutputType without action
   */
  export type PetCountOutputTypeCountVaccineArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VaccineWhereInput
  }


  /**
   * Count Type RaceCountOutputType
   */

  export type RaceCountOutputType = {
    clientPet: number
  }

  export type RaceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clientPet?: boolean | RaceCountOutputTypeCountClientPetArgs
  }

  // Custom InputTypes
  /**
   * RaceCountOutputType without action
   */
  export type RaceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceCountOutputType
     */
    select?: RaceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RaceCountOutputType without action
   */
  export type RaceCountOutputTypeCountClientPetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientPetWhereInput
  }


  /**
   * Count Type VaccineCountOutputType
   */

  export type VaccineCountOutputType = {
    personalPetVaccine: number
  }

  export type VaccineCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    personalPetVaccine?: boolean | VaccineCountOutputTypeCountPersonalPetVaccineArgs
  }

  // Custom InputTypes
  /**
   * VaccineCountOutputType without action
   */
  export type VaccineCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VaccineCountOutputType
     */
    select?: VaccineCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * VaccineCountOutputType without action
   */
  export type VaccineCountOutputTypeCountPersonalPetVaccineArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PersonalPetVaccineWhereInput
  }


  /**
   * Count Type MettingCountOutputType
   */

  export type MettingCountOutputType = {
    personalPetVaccine: number
  }

  export type MettingCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    personalPetVaccine?: boolean | MettingCountOutputTypeCountPersonalPetVaccineArgs
  }

  // Custom InputTypes
  /**
   * MettingCountOutputType without action
   */
  export type MettingCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MettingCountOutputType
     */
    select?: MettingCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MettingCountOutputType without action
   */
  export type MettingCountOutputTypeCountPersonalPetVaccineArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PersonalPetVaccineWhereInput
  }


  /**
   * Count Type ProductCountOutputType
   */

  export type ProductCountOutputType = {
    clinicProducts: number
  }

  export type ProductCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clinicProducts?: boolean | ProductCountOutputTypeCountClinicProductsArgs
  }

  // Custom InputTypes
  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCountOutputType
     */
    select?: ProductCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountClinicProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClinicProductWhereInput
  }


  /**
   * Count Type FoodCountOutputType
   */

  export type FoodCountOutputType = {
    foodPets: number
  }

  export type FoodCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    foodPets?: boolean | FoodCountOutputTypeCountFoodPetsArgs
  }

  // Custom InputTypes
  /**
   * FoodCountOutputType without action
   */
  export type FoodCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodCountOutputType
     */
    select?: FoodCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FoodCountOutputType without action
   */
  export type FoodCountOutputTypeCountFoodPetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FoodPetWhereInput
  }


  /**
   * Count Type BrandCountOutputType
   */

  export type BrandCountOutputType = {
    product: number
  }

  export type BrandCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | BrandCountOutputTypeCountProductArgs
  }

  // Custom InputTypes
  /**
   * BrandCountOutputType without action
   */
  export type BrandCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BrandCountOutputType
     */
    select?: BrandCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BrandCountOutputType without action
   */
  export type BrandCountOutputTypeCountProductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }


  /**
   * Count Type ClientProfileCountOutputType
   */

  export type ClientProfileCountOutputType = {
    clientPet: number
    clinicProducts: number
  }

  export type ClientProfileCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clientPet?: boolean | ClientProfileCountOutputTypeCountClientPetArgs
    clinicProducts?: boolean | ClientProfileCountOutputTypeCountClinicProductsArgs
  }

  // Custom InputTypes
  /**
   * ClientProfileCountOutputType without action
   */
  export type ClientProfileCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientProfileCountOutputType
     */
    select?: ClientProfileCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ClientProfileCountOutputType without action
   */
  export type ClientProfileCountOutputTypeCountClientPetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientPetWhereInput
  }

  /**
   * ClientProfileCountOutputType without action
   */
  export type ClientProfileCountOutputTypeCountClinicProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClinicProductWhereInput
  }


  /**
   * Count Type VeterinarianProfileCountOutputType
   */

  export type VeterinarianProfileCountOutputType = {
    clinicProfiles: number
    clientPet: number
    metting: number
  }

  export type VeterinarianProfileCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clinicProfiles?: boolean | VeterinarianProfileCountOutputTypeCountClinicProfilesArgs
    clientPet?: boolean | VeterinarianProfileCountOutputTypeCountClientPetArgs
    metting?: boolean | VeterinarianProfileCountOutputTypeCountMettingArgs
  }

  // Custom InputTypes
  /**
   * VeterinarianProfileCountOutputType without action
   */
  export type VeterinarianProfileCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VeterinarianProfileCountOutputType
     */
    select?: VeterinarianProfileCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * VeterinarianProfileCountOutputType without action
   */
  export type VeterinarianProfileCountOutputTypeCountClinicProfilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClinicProfileWhereInput
  }

  /**
   * VeterinarianProfileCountOutputType without action
   */
  export type VeterinarianProfileCountOutputTypeCountClientPetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientPetWhereInput
  }

  /**
   * VeterinarianProfileCountOutputType without action
   */
  export type VeterinarianProfileCountOutputTypeCountMettingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MettingWhereInput
  }


  /**
   * Models
   */

  /**
   * Model ClientPet
   */

  export type AggregateClientPet = {
    _count: ClientPetCountAggregateOutputType | null
    _avg: ClientPetAvgAggregateOutputType | null
    _sum: ClientPetSumAggregateOutputType | null
    _min: ClientPetMinAggregateOutputType | null
    _max: ClientPetMaxAggregateOutputType | null
  }

  export type ClientPetAvgAggregateOutputType = {
    activity: number | null
  }

  export type ClientPetSumAggregateOutputType = {
    activity: number | null
  }

  export type ClientPetMinAggregateOutputType = {
    id: string | null
    name: string | null
    dateOfBirth: Date | null
    description: string | null
    activity: number | null
    attendingVeterinarianId: string | null
    clientId: string | null
    raceId: string | null
  }

  export type ClientPetMaxAggregateOutputType = {
    id: string | null
    name: string | null
    dateOfBirth: Date | null
    description: string | null
    activity: number | null
    attendingVeterinarianId: string | null
    clientId: string | null
    raceId: string | null
  }

  export type ClientPetCountAggregateOutputType = {
    id: number
    name: number
    dateOfBirth: number
    description: number
    activity: number
    attendingVeterinarianId: number
    clientId: number
    raceId: number
    _all: number
  }


  export type ClientPetAvgAggregateInputType = {
    activity?: true
  }

  export type ClientPetSumAggregateInputType = {
    activity?: true
  }

  export type ClientPetMinAggregateInputType = {
    id?: true
    name?: true
    dateOfBirth?: true
    description?: true
    activity?: true
    attendingVeterinarianId?: true
    clientId?: true
    raceId?: true
  }

  export type ClientPetMaxAggregateInputType = {
    id?: true
    name?: true
    dateOfBirth?: true
    description?: true
    activity?: true
    attendingVeterinarianId?: true
    clientId?: true
    raceId?: true
  }

  export type ClientPetCountAggregateInputType = {
    id?: true
    name?: true
    dateOfBirth?: true
    description?: true
    activity?: true
    attendingVeterinarianId?: true
    clientId?: true
    raceId?: true
    _all?: true
  }

  export type ClientPetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClientPet to aggregate.
     */
    where?: ClientPetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientPets to fetch.
     */
    orderBy?: ClientPetOrderByWithRelationInput | ClientPetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClientPetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientPets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientPets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ClientPets
    **/
    _count?: true | ClientPetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClientPetAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClientPetSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClientPetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClientPetMaxAggregateInputType
  }

  export type GetClientPetAggregateType<T extends ClientPetAggregateArgs> = {
        [P in keyof T & keyof AggregateClientPet]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClientPet[P]>
      : GetScalarType<T[P], AggregateClientPet[P]>
  }




  export type ClientPetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientPetWhereInput
    orderBy?: ClientPetOrderByWithAggregationInput | ClientPetOrderByWithAggregationInput[]
    by: ClientPetScalarFieldEnum[] | ClientPetScalarFieldEnum
    having?: ClientPetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClientPetCountAggregateInputType | true
    _avg?: ClientPetAvgAggregateInputType
    _sum?: ClientPetSumAggregateInputType
    _min?: ClientPetMinAggregateInputType
    _max?: ClientPetMaxAggregateInputType
  }

  export type ClientPetGroupByOutputType = {
    id: string
    name: string
    dateOfBirth: Date
    description: string | null
    activity: number | null
    attendingVeterinarianId: string | null
    clientId: string
    raceId: string
    _count: ClientPetCountAggregateOutputType | null
    _avg: ClientPetAvgAggregateOutputType | null
    _sum: ClientPetSumAggregateOutputType | null
    _min: ClientPetMinAggregateOutputType | null
    _max: ClientPetMaxAggregateOutputType | null
  }

  type GetClientPetGroupByPayload<T extends ClientPetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClientPetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClientPetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClientPetGroupByOutputType[P]>
            : GetScalarType<T[P], ClientPetGroupByOutputType[P]>
        }
      >
    >


  export type ClientPetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    dateOfBirth?: boolean
    description?: boolean
    activity?: boolean
    attendingVeterinarianId?: boolean
    clientId?: boolean
    raceId?: boolean
    attendingVeterinarian?: boolean | ClientPet$attendingVeterinarianArgs<ExtArgs>
    client?: boolean | ClientProfileDefaultArgs<ExtArgs>
    race?: boolean | RaceDefaultArgs<ExtArgs>
    personalPetVaccine?: boolean | ClientPet$personalPetVaccineArgs<ExtArgs>
    metting?: boolean | ClientPet$mettingArgs<ExtArgs>
    foodPets?: boolean | ClientPet$foodPetsArgs<ExtArgs>
    _count?: boolean | ClientPetCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clientPet"]>

  export type ClientPetSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    dateOfBirth?: boolean
    description?: boolean
    activity?: boolean
    attendingVeterinarianId?: boolean
    clientId?: boolean
    raceId?: boolean
    attendingVeterinarian?: boolean | ClientPet$attendingVeterinarianArgs<ExtArgs>
    client?: boolean | ClientProfileDefaultArgs<ExtArgs>
    race?: boolean | RaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clientPet"]>

  export type ClientPetSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    dateOfBirth?: boolean
    description?: boolean
    activity?: boolean
    attendingVeterinarianId?: boolean
    clientId?: boolean
    raceId?: boolean
    attendingVeterinarian?: boolean | ClientPet$attendingVeterinarianArgs<ExtArgs>
    client?: boolean | ClientProfileDefaultArgs<ExtArgs>
    race?: boolean | RaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clientPet"]>

  export type ClientPetSelectScalar = {
    id?: boolean
    name?: boolean
    dateOfBirth?: boolean
    description?: boolean
    activity?: boolean
    attendingVeterinarianId?: boolean
    clientId?: boolean
    raceId?: boolean
  }

  export type ClientPetOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "dateOfBirth" | "description" | "activity" | "attendingVeterinarianId" | "clientId" | "raceId", ExtArgs["result"]["clientPet"]>
  export type ClientPetInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attendingVeterinarian?: boolean | ClientPet$attendingVeterinarianArgs<ExtArgs>
    client?: boolean | ClientProfileDefaultArgs<ExtArgs>
    race?: boolean | RaceDefaultArgs<ExtArgs>
    personalPetVaccine?: boolean | ClientPet$personalPetVaccineArgs<ExtArgs>
    metting?: boolean | ClientPet$mettingArgs<ExtArgs>
    foodPets?: boolean | ClientPet$foodPetsArgs<ExtArgs>
    _count?: boolean | ClientPetCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ClientPetIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attendingVeterinarian?: boolean | ClientPet$attendingVeterinarianArgs<ExtArgs>
    client?: boolean | ClientProfileDefaultArgs<ExtArgs>
    race?: boolean | RaceDefaultArgs<ExtArgs>
  }
  export type ClientPetIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attendingVeterinarian?: boolean | ClientPet$attendingVeterinarianArgs<ExtArgs>
    client?: boolean | ClientProfileDefaultArgs<ExtArgs>
    race?: boolean | RaceDefaultArgs<ExtArgs>
  }

  export type $ClientPetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ClientPet"
    objects: {
      attendingVeterinarian: Prisma.$VeterinarianProfilePayload<ExtArgs> | null
      client: Prisma.$ClientProfilePayload<ExtArgs>
      race: Prisma.$RacePayload<ExtArgs>
      personalPetVaccine: Prisma.$PersonalPetVaccinePayload<ExtArgs>[]
      metting: Prisma.$MettingPayload<ExtArgs>[]
      foodPets: Prisma.$FoodPetPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      dateOfBirth: Date
      description: string | null
      activity: number | null
      attendingVeterinarianId: string | null
      clientId: string
      raceId: string
    }, ExtArgs["result"]["clientPet"]>
    composites: {}
  }

  type ClientPetGetPayload<S extends boolean | null | undefined | ClientPetDefaultArgs> = $Result.GetResult<Prisma.$ClientPetPayload, S>

  type ClientPetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClientPetFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClientPetCountAggregateInputType | true
    }

  export interface ClientPetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ClientPet'], meta: { name: 'ClientPet' } }
    /**
     * Find zero or one ClientPet that matches the filter.
     * @param {ClientPetFindUniqueArgs} args - Arguments to find a ClientPet
     * @example
     * // Get one ClientPet
     * const clientPet = await prisma.clientPet.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClientPetFindUniqueArgs>(args: SelectSubset<T, ClientPetFindUniqueArgs<ExtArgs>>): Prisma__ClientPetClient<$Result.GetResult<Prisma.$ClientPetPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ClientPet that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClientPetFindUniqueOrThrowArgs} args - Arguments to find a ClientPet
     * @example
     * // Get one ClientPet
     * const clientPet = await prisma.clientPet.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClientPetFindUniqueOrThrowArgs>(args: SelectSubset<T, ClientPetFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClientPetClient<$Result.GetResult<Prisma.$ClientPetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClientPet that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientPetFindFirstArgs} args - Arguments to find a ClientPet
     * @example
     * // Get one ClientPet
     * const clientPet = await prisma.clientPet.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClientPetFindFirstArgs>(args?: SelectSubset<T, ClientPetFindFirstArgs<ExtArgs>>): Prisma__ClientPetClient<$Result.GetResult<Prisma.$ClientPetPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClientPet that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientPetFindFirstOrThrowArgs} args - Arguments to find a ClientPet
     * @example
     * // Get one ClientPet
     * const clientPet = await prisma.clientPet.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClientPetFindFirstOrThrowArgs>(args?: SelectSubset<T, ClientPetFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClientPetClient<$Result.GetResult<Prisma.$ClientPetPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ClientPets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientPetFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ClientPets
     * const clientPets = await prisma.clientPet.findMany()
     * 
     * // Get first 10 ClientPets
     * const clientPets = await prisma.clientPet.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clientPetWithIdOnly = await prisma.clientPet.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClientPetFindManyArgs>(args?: SelectSubset<T, ClientPetFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientPetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ClientPet.
     * @param {ClientPetCreateArgs} args - Arguments to create a ClientPet.
     * @example
     * // Create one ClientPet
     * const ClientPet = await prisma.clientPet.create({
     *   data: {
     *     // ... data to create a ClientPet
     *   }
     * })
     * 
     */
    create<T extends ClientPetCreateArgs>(args: SelectSubset<T, ClientPetCreateArgs<ExtArgs>>): Prisma__ClientPetClient<$Result.GetResult<Prisma.$ClientPetPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ClientPets.
     * @param {ClientPetCreateManyArgs} args - Arguments to create many ClientPets.
     * @example
     * // Create many ClientPets
     * const clientPet = await prisma.clientPet.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClientPetCreateManyArgs>(args?: SelectSubset<T, ClientPetCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ClientPets and returns the data saved in the database.
     * @param {ClientPetCreateManyAndReturnArgs} args - Arguments to create many ClientPets.
     * @example
     * // Create many ClientPets
     * const clientPet = await prisma.clientPet.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ClientPets and only return the `id`
     * const clientPetWithIdOnly = await prisma.clientPet.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClientPetCreateManyAndReturnArgs>(args?: SelectSubset<T, ClientPetCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientPetPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ClientPet.
     * @param {ClientPetDeleteArgs} args - Arguments to delete one ClientPet.
     * @example
     * // Delete one ClientPet
     * const ClientPet = await prisma.clientPet.delete({
     *   where: {
     *     // ... filter to delete one ClientPet
     *   }
     * })
     * 
     */
    delete<T extends ClientPetDeleteArgs>(args: SelectSubset<T, ClientPetDeleteArgs<ExtArgs>>): Prisma__ClientPetClient<$Result.GetResult<Prisma.$ClientPetPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ClientPet.
     * @param {ClientPetUpdateArgs} args - Arguments to update one ClientPet.
     * @example
     * // Update one ClientPet
     * const clientPet = await prisma.clientPet.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClientPetUpdateArgs>(args: SelectSubset<T, ClientPetUpdateArgs<ExtArgs>>): Prisma__ClientPetClient<$Result.GetResult<Prisma.$ClientPetPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ClientPets.
     * @param {ClientPetDeleteManyArgs} args - Arguments to filter ClientPets to delete.
     * @example
     * // Delete a few ClientPets
     * const { count } = await prisma.clientPet.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClientPetDeleteManyArgs>(args?: SelectSubset<T, ClientPetDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClientPets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientPetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ClientPets
     * const clientPet = await prisma.clientPet.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClientPetUpdateManyArgs>(args: SelectSubset<T, ClientPetUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClientPets and returns the data updated in the database.
     * @param {ClientPetUpdateManyAndReturnArgs} args - Arguments to update many ClientPets.
     * @example
     * // Update many ClientPets
     * const clientPet = await prisma.clientPet.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ClientPets and only return the `id`
     * const clientPetWithIdOnly = await prisma.clientPet.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ClientPetUpdateManyAndReturnArgs>(args: SelectSubset<T, ClientPetUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientPetPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ClientPet.
     * @param {ClientPetUpsertArgs} args - Arguments to update or create a ClientPet.
     * @example
     * // Update or create a ClientPet
     * const clientPet = await prisma.clientPet.upsert({
     *   create: {
     *     // ... data to create a ClientPet
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ClientPet we want to update
     *   }
     * })
     */
    upsert<T extends ClientPetUpsertArgs>(args: SelectSubset<T, ClientPetUpsertArgs<ExtArgs>>): Prisma__ClientPetClient<$Result.GetResult<Prisma.$ClientPetPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ClientPets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientPetCountArgs} args - Arguments to filter ClientPets to count.
     * @example
     * // Count the number of ClientPets
     * const count = await prisma.clientPet.count({
     *   where: {
     *     // ... the filter for the ClientPets we want to count
     *   }
     * })
    **/
    count<T extends ClientPetCountArgs>(
      args?: Subset<T, ClientPetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClientPetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ClientPet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientPetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClientPetAggregateArgs>(args: Subset<T, ClientPetAggregateArgs>): Prisma.PrismaPromise<GetClientPetAggregateType<T>>

    /**
     * Group by ClientPet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientPetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClientPetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClientPetGroupByArgs['orderBy'] }
        : { orderBy?: ClientPetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClientPetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClientPetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ClientPet model
   */
  readonly fields: ClientPetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ClientPet.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClientPetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    attendingVeterinarian<T extends ClientPet$attendingVeterinarianArgs<ExtArgs> = {}>(args?: Subset<T, ClientPet$attendingVeterinarianArgs<ExtArgs>>): Prisma__VeterinarianProfileClient<$Result.GetResult<Prisma.$VeterinarianProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    client<T extends ClientProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientProfileDefaultArgs<ExtArgs>>): Prisma__ClientProfileClient<$Result.GetResult<Prisma.$ClientProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    race<T extends RaceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RaceDefaultArgs<ExtArgs>>): Prisma__RaceClient<$Result.GetResult<Prisma.$RacePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    personalPetVaccine<T extends ClientPet$personalPetVaccineArgs<ExtArgs> = {}>(args?: Subset<T, ClientPet$personalPetVaccineArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersonalPetVaccinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    metting<T extends ClientPet$mettingArgs<ExtArgs> = {}>(args?: Subset<T, ClientPet$mettingArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MettingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    foodPets<T extends ClientPet$foodPetsArgs<ExtArgs> = {}>(args?: Subset<T, ClientPet$foodPetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FoodPetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ClientPet model
   */
  interface ClientPetFieldRefs {
    readonly id: FieldRef<"ClientPet", 'String'>
    readonly name: FieldRef<"ClientPet", 'String'>
    readonly dateOfBirth: FieldRef<"ClientPet", 'DateTime'>
    readonly description: FieldRef<"ClientPet", 'String'>
    readonly activity: FieldRef<"ClientPet", 'Int'>
    readonly attendingVeterinarianId: FieldRef<"ClientPet", 'String'>
    readonly clientId: FieldRef<"ClientPet", 'String'>
    readonly raceId: FieldRef<"ClientPet", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ClientPet findUnique
   */
  export type ClientPetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientPet
     */
    select?: ClientPetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientPet
     */
    omit?: ClientPetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientPetInclude<ExtArgs> | null
    /**
     * Filter, which ClientPet to fetch.
     */
    where: ClientPetWhereUniqueInput
  }

  /**
   * ClientPet findUniqueOrThrow
   */
  export type ClientPetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientPet
     */
    select?: ClientPetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientPet
     */
    omit?: ClientPetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientPetInclude<ExtArgs> | null
    /**
     * Filter, which ClientPet to fetch.
     */
    where: ClientPetWhereUniqueInput
  }

  /**
   * ClientPet findFirst
   */
  export type ClientPetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientPet
     */
    select?: ClientPetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientPet
     */
    omit?: ClientPetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientPetInclude<ExtArgs> | null
    /**
     * Filter, which ClientPet to fetch.
     */
    where?: ClientPetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientPets to fetch.
     */
    orderBy?: ClientPetOrderByWithRelationInput | ClientPetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClientPets.
     */
    cursor?: ClientPetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientPets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientPets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClientPets.
     */
    distinct?: ClientPetScalarFieldEnum | ClientPetScalarFieldEnum[]
  }

  /**
   * ClientPet findFirstOrThrow
   */
  export type ClientPetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientPet
     */
    select?: ClientPetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientPet
     */
    omit?: ClientPetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientPetInclude<ExtArgs> | null
    /**
     * Filter, which ClientPet to fetch.
     */
    where?: ClientPetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientPets to fetch.
     */
    orderBy?: ClientPetOrderByWithRelationInput | ClientPetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClientPets.
     */
    cursor?: ClientPetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientPets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientPets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClientPets.
     */
    distinct?: ClientPetScalarFieldEnum | ClientPetScalarFieldEnum[]
  }

  /**
   * ClientPet findMany
   */
  export type ClientPetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientPet
     */
    select?: ClientPetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientPet
     */
    omit?: ClientPetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientPetInclude<ExtArgs> | null
    /**
     * Filter, which ClientPets to fetch.
     */
    where?: ClientPetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientPets to fetch.
     */
    orderBy?: ClientPetOrderByWithRelationInput | ClientPetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ClientPets.
     */
    cursor?: ClientPetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientPets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientPets.
     */
    skip?: number
    distinct?: ClientPetScalarFieldEnum | ClientPetScalarFieldEnum[]
  }

  /**
   * ClientPet create
   */
  export type ClientPetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientPet
     */
    select?: ClientPetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientPet
     */
    omit?: ClientPetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientPetInclude<ExtArgs> | null
    /**
     * The data needed to create a ClientPet.
     */
    data: XOR<ClientPetCreateInput, ClientPetUncheckedCreateInput>
  }

  /**
   * ClientPet createMany
   */
  export type ClientPetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ClientPets.
     */
    data: ClientPetCreateManyInput | ClientPetCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ClientPet createManyAndReturn
   */
  export type ClientPetCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientPet
     */
    select?: ClientPetSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ClientPet
     */
    omit?: ClientPetOmit<ExtArgs> | null
    /**
     * The data used to create many ClientPets.
     */
    data: ClientPetCreateManyInput | ClientPetCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientPetIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ClientPet update
   */
  export type ClientPetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientPet
     */
    select?: ClientPetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientPet
     */
    omit?: ClientPetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientPetInclude<ExtArgs> | null
    /**
     * The data needed to update a ClientPet.
     */
    data: XOR<ClientPetUpdateInput, ClientPetUncheckedUpdateInput>
    /**
     * Choose, which ClientPet to update.
     */
    where: ClientPetWhereUniqueInput
  }

  /**
   * ClientPet updateMany
   */
  export type ClientPetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ClientPets.
     */
    data: XOR<ClientPetUpdateManyMutationInput, ClientPetUncheckedUpdateManyInput>
    /**
     * Filter which ClientPets to update
     */
    where?: ClientPetWhereInput
    /**
     * Limit how many ClientPets to update.
     */
    limit?: number
  }

  /**
   * ClientPet updateManyAndReturn
   */
  export type ClientPetUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientPet
     */
    select?: ClientPetSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ClientPet
     */
    omit?: ClientPetOmit<ExtArgs> | null
    /**
     * The data used to update ClientPets.
     */
    data: XOR<ClientPetUpdateManyMutationInput, ClientPetUncheckedUpdateManyInput>
    /**
     * Filter which ClientPets to update
     */
    where?: ClientPetWhereInput
    /**
     * Limit how many ClientPets to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientPetIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ClientPet upsert
   */
  export type ClientPetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientPet
     */
    select?: ClientPetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientPet
     */
    omit?: ClientPetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientPetInclude<ExtArgs> | null
    /**
     * The filter to search for the ClientPet to update in case it exists.
     */
    where: ClientPetWhereUniqueInput
    /**
     * In case the ClientPet found by the `where` argument doesn't exist, create a new ClientPet with this data.
     */
    create: XOR<ClientPetCreateInput, ClientPetUncheckedCreateInput>
    /**
     * In case the ClientPet was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClientPetUpdateInput, ClientPetUncheckedUpdateInput>
  }

  /**
   * ClientPet delete
   */
  export type ClientPetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientPet
     */
    select?: ClientPetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientPet
     */
    omit?: ClientPetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientPetInclude<ExtArgs> | null
    /**
     * Filter which ClientPet to delete.
     */
    where: ClientPetWhereUniqueInput
  }

  /**
   * ClientPet deleteMany
   */
  export type ClientPetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClientPets to delete
     */
    where?: ClientPetWhereInput
    /**
     * Limit how many ClientPets to delete.
     */
    limit?: number
  }

  /**
   * ClientPet.attendingVeterinarian
   */
  export type ClientPet$attendingVeterinarianArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VeterinarianProfile
     */
    select?: VeterinarianProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VeterinarianProfile
     */
    omit?: VeterinarianProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VeterinarianProfileInclude<ExtArgs> | null
    where?: VeterinarianProfileWhereInput
  }

  /**
   * ClientPet.personalPetVaccine
   */
  export type ClientPet$personalPetVaccineArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalPetVaccine
     */
    select?: PersonalPetVaccineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonalPetVaccine
     */
    omit?: PersonalPetVaccineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonalPetVaccineInclude<ExtArgs> | null
    where?: PersonalPetVaccineWhereInput
    orderBy?: PersonalPetVaccineOrderByWithRelationInput | PersonalPetVaccineOrderByWithRelationInput[]
    cursor?: PersonalPetVaccineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PersonalPetVaccineScalarFieldEnum | PersonalPetVaccineScalarFieldEnum[]
  }

  /**
   * ClientPet.metting
   */
  export type ClientPet$mettingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Metting
     */
    select?: MettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Metting
     */
    omit?: MettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MettingInclude<ExtArgs> | null
    where?: MettingWhereInput
    orderBy?: MettingOrderByWithRelationInput | MettingOrderByWithRelationInput[]
    cursor?: MettingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MettingScalarFieldEnum | MettingScalarFieldEnum[]
  }

  /**
   * ClientPet.foodPets
   */
  export type ClientPet$foodPetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodPet
     */
    select?: FoodPetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodPet
     */
    omit?: FoodPetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodPetInclude<ExtArgs> | null
    where?: FoodPetWhereInput
    orderBy?: FoodPetOrderByWithRelationInput | FoodPetOrderByWithRelationInput[]
    cursor?: FoodPetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FoodPetScalarFieldEnum | FoodPetScalarFieldEnum[]
  }

  /**
   * ClientPet without action
   */
  export type ClientPetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientPet
     */
    select?: ClientPetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientPet
     */
    omit?: ClientPetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientPetInclude<ExtArgs> | null
  }


  /**
   * Model Pet
   */

  export type AggregatePet = {
    _count: PetCountAggregateOutputType | null
    _min: PetMinAggregateOutputType | null
    _max: PetMaxAggregateOutputType | null
  }

  export type PetMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    name: string | null
    picture: string | null
  }

  export type PetMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    name: string | null
    picture: string | null
  }

  export type PetCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    name: number
    picture: number
    _all: number
  }


  export type PetMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    picture?: true
  }

  export type PetMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    picture?: true
  }

  export type PetCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    picture?: true
    _all?: true
  }

  export type PetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Pet to aggregate.
     */
    where?: PetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pets to fetch.
     */
    orderBy?: PetOrderByWithRelationInput | PetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Pets
    **/
    _count?: true | PetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PetMaxAggregateInputType
  }

  export type GetPetAggregateType<T extends PetAggregateArgs> = {
        [P in keyof T & keyof AggregatePet]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePet[P]>
      : GetScalarType<T[P], AggregatePet[P]>
  }




  export type PetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PetWhereInput
    orderBy?: PetOrderByWithAggregationInput | PetOrderByWithAggregationInput[]
    by: PetScalarFieldEnum[] | PetScalarFieldEnum
    having?: PetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PetCountAggregateInputType | true
    _min?: PetMinAggregateInputType
    _max?: PetMaxAggregateInputType
  }

  export type PetGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    name: string
    picture: string | null
    _count: PetCountAggregateOutputType | null
    _min: PetMinAggregateOutputType | null
    _max: PetMaxAggregateOutputType | null
  }

  type GetPetGroupByPayload<T extends PetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PetGroupByOutputType[P]>
            : GetScalarType<T[P], PetGroupByOutputType[P]>
        }
      >
    >


  export type PetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    picture?: boolean
    races?: boolean | Pet$racesArgs<ExtArgs>
    vaccine?: boolean | Pet$vaccineArgs<ExtArgs>
    _count?: boolean | PetCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pet"]>

  export type PetSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    picture?: boolean
  }, ExtArgs["result"]["pet"]>

  export type PetSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    picture?: boolean
  }, ExtArgs["result"]["pet"]>

  export type PetSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    picture?: boolean
  }

  export type PetOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "name" | "picture", ExtArgs["result"]["pet"]>
  export type PetInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    races?: boolean | Pet$racesArgs<ExtArgs>
    vaccine?: boolean | Pet$vaccineArgs<ExtArgs>
    _count?: boolean | PetCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PetIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type PetIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Pet"
    objects: {
      races: Prisma.$RacePayload<ExtArgs>[]
      vaccine: Prisma.$VaccinePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      name: string
      picture: string | null
    }, ExtArgs["result"]["pet"]>
    composites: {}
  }

  type PetGetPayload<S extends boolean | null | undefined | PetDefaultArgs> = $Result.GetResult<Prisma.$PetPayload, S>

  type PetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PetFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PetCountAggregateInputType | true
    }

  export interface PetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Pet'], meta: { name: 'Pet' } }
    /**
     * Find zero or one Pet that matches the filter.
     * @param {PetFindUniqueArgs} args - Arguments to find a Pet
     * @example
     * // Get one Pet
     * const pet = await prisma.pet.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PetFindUniqueArgs>(args: SelectSubset<T, PetFindUniqueArgs<ExtArgs>>): Prisma__PetClient<$Result.GetResult<Prisma.$PetPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Pet that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PetFindUniqueOrThrowArgs} args - Arguments to find a Pet
     * @example
     * // Get one Pet
     * const pet = await prisma.pet.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PetFindUniqueOrThrowArgs>(args: SelectSubset<T, PetFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PetClient<$Result.GetResult<Prisma.$PetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Pet that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PetFindFirstArgs} args - Arguments to find a Pet
     * @example
     * // Get one Pet
     * const pet = await prisma.pet.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PetFindFirstArgs>(args?: SelectSubset<T, PetFindFirstArgs<ExtArgs>>): Prisma__PetClient<$Result.GetResult<Prisma.$PetPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Pet that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PetFindFirstOrThrowArgs} args - Arguments to find a Pet
     * @example
     * // Get one Pet
     * const pet = await prisma.pet.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PetFindFirstOrThrowArgs>(args?: SelectSubset<T, PetFindFirstOrThrowArgs<ExtArgs>>): Prisma__PetClient<$Result.GetResult<Prisma.$PetPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Pets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PetFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pets
     * const pets = await prisma.pet.findMany()
     * 
     * // Get first 10 Pets
     * const pets = await prisma.pet.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const petWithIdOnly = await prisma.pet.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PetFindManyArgs>(args?: SelectSubset<T, PetFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Pet.
     * @param {PetCreateArgs} args - Arguments to create a Pet.
     * @example
     * // Create one Pet
     * const Pet = await prisma.pet.create({
     *   data: {
     *     // ... data to create a Pet
     *   }
     * })
     * 
     */
    create<T extends PetCreateArgs>(args: SelectSubset<T, PetCreateArgs<ExtArgs>>): Prisma__PetClient<$Result.GetResult<Prisma.$PetPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Pets.
     * @param {PetCreateManyArgs} args - Arguments to create many Pets.
     * @example
     * // Create many Pets
     * const pet = await prisma.pet.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PetCreateManyArgs>(args?: SelectSubset<T, PetCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Pets and returns the data saved in the database.
     * @param {PetCreateManyAndReturnArgs} args - Arguments to create many Pets.
     * @example
     * // Create many Pets
     * const pet = await prisma.pet.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Pets and only return the `id`
     * const petWithIdOnly = await prisma.pet.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PetCreateManyAndReturnArgs>(args?: SelectSubset<T, PetCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PetPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Pet.
     * @param {PetDeleteArgs} args - Arguments to delete one Pet.
     * @example
     * // Delete one Pet
     * const Pet = await prisma.pet.delete({
     *   where: {
     *     // ... filter to delete one Pet
     *   }
     * })
     * 
     */
    delete<T extends PetDeleteArgs>(args: SelectSubset<T, PetDeleteArgs<ExtArgs>>): Prisma__PetClient<$Result.GetResult<Prisma.$PetPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Pet.
     * @param {PetUpdateArgs} args - Arguments to update one Pet.
     * @example
     * // Update one Pet
     * const pet = await prisma.pet.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PetUpdateArgs>(args: SelectSubset<T, PetUpdateArgs<ExtArgs>>): Prisma__PetClient<$Result.GetResult<Prisma.$PetPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Pets.
     * @param {PetDeleteManyArgs} args - Arguments to filter Pets to delete.
     * @example
     * // Delete a few Pets
     * const { count } = await prisma.pet.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PetDeleteManyArgs>(args?: SelectSubset<T, PetDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pets
     * const pet = await prisma.pet.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PetUpdateManyArgs>(args: SelectSubset<T, PetUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pets and returns the data updated in the database.
     * @param {PetUpdateManyAndReturnArgs} args - Arguments to update many Pets.
     * @example
     * // Update many Pets
     * const pet = await prisma.pet.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Pets and only return the `id`
     * const petWithIdOnly = await prisma.pet.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PetUpdateManyAndReturnArgs>(args: SelectSubset<T, PetUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PetPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Pet.
     * @param {PetUpsertArgs} args - Arguments to update or create a Pet.
     * @example
     * // Update or create a Pet
     * const pet = await prisma.pet.upsert({
     *   create: {
     *     // ... data to create a Pet
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pet we want to update
     *   }
     * })
     */
    upsert<T extends PetUpsertArgs>(args: SelectSubset<T, PetUpsertArgs<ExtArgs>>): Prisma__PetClient<$Result.GetResult<Prisma.$PetPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Pets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PetCountArgs} args - Arguments to filter Pets to count.
     * @example
     * // Count the number of Pets
     * const count = await prisma.pet.count({
     *   where: {
     *     // ... the filter for the Pets we want to count
     *   }
     * })
    **/
    count<T extends PetCountArgs>(
      args?: Subset<T, PetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PetAggregateArgs>(args: Subset<T, PetAggregateArgs>): Prisma.PrismaPromise<GetPetAggregateType<T>>

    /**
     * Group by Pet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PetGroupByArgs['orderBy'] }
        : { orderBy?: PetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Pet model
   */
  readonly fields: PetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Pet.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    races<T extends Pet$racesArgs<ExtArgs> = {}>(args?: Subset<T, Pet$racesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RacePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    vaccine<T extends Pet$vaccineArgs<ExtArgs> = {}>(args?: Subset<T, Pet$vaccineArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VaccinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Pet model
   */
  interface PetFieldRefs {
    readonly id: FieldRef<"Pet", 'String'>
    readonly createdAt: FieldRef<"Pet", 'DateTime'>
    readonly updatedAt: FieldRef<"Pet", 'DateTime'>
    readonly name: FieldRef<"Pet", 'String'>
    readonly picture: FieldRef<"Pet", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Pet findUnique
   */
  export type PetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pet
     */
    select?: PetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pet
     */
    omit?: PetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PetInclude<ExtArgs> | null
    /**
     * Filter, which Pet to fetch.
     */
    where: PetWhereUniqueInput
  }

  /**
   * Pet findUniqueOrThrow
   */
  export type PetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pet
     */
    select?: PetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pet
     */
    omit?: PetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PetInclude<ExtArgs> | null
    /**
     * Filter, which Pet to fetch.
     */
    where: PetWhereUniqueInput
  }

  /**
   * Pet findFirst
   */
  export type PetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pet
     */
    select?: PetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pet
     */
    omit?: PetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PetInclude<ExtArgs> | null
    /**
     * Filter, which Pet to fetch.
     */
    where?: PetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pets to fetch.
     */
    orderBy?: PetOrderByWithRelationInput | PetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pets.
     */
    cursor?: PetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pets.
     */
    distinct?: PetScalarFieldEnum | PetScalarFieldEnum[]
  }

  /**
   * Pet findFirstOrThrow
   */
  export type PetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pet
     */
    select?: PetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pet
     */
    omit?: PetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PetInclude<ExtArgs> | null
    /**
     * Filter, which Pet to fetch.
     */
    where?: PetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pets to fetch.
     */
    orderBy?: PetOrderByWithRelationInput | PetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pets.
     */
    cursor?: PetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pets.
     */
    distinct?: PetScalarFieldEnum | PetScalarFieldEnum[]
  }

  /**
   * Pet findMany
   */
  export type PetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pet
     */
    select?: PetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pet
     */
    omit?: PetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PetInclude<ExtArgs> | null
    /**
     * Filter, which Pets to fetch.
     */
    where?: PetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pets to fetch.
     */
    orderBy?: PetOrderByWithRelationInput | PetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Pets.
     */
    cursor?: PetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pets.
     */
    skip?: number
    distinct?: PetScalarFieldEnum | PetScalarFieldEnum[]
  }

  /**
   * Pet create
   */
  export type PetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pet
     */
    select?: PetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pet
     */
    omit?: PetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PetInclude<ExtArgs> | null
    /**
     * The data needed to create a Pet.
     */
    data: XOR<PetCreateInput, PetUncheckedCreateInput>
  }

  /**
   * Pet createMany
   */
  export type PetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Pets.
     */
    data: PetCreateManyInput | PetCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Pet createManyAndReturn
   */
  export type PetCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pet
     */
    select?: PetSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Pet
     */
    omit?: PetOmit<ExtArgs> | null
    /**
     * The data used to create many Pets.
     */
    data: PetCreateManyInput | PetCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Pet update
   */
  export type PetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pet
     */
    select?: PetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pet
     */
    omit?: PetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PetInclude<ExtArgs> | null
    /**
     * The data needed to update a Pet.
     */
    data: XOR<PetUpdateInput, PetUncheckedUpdateInput>
    /**
     * Choose, which Pet to update.
     */
    where: PetWhereUniqueInput
  }

  /**
   * Pet updateMany
   */
  export type PetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Pets.
     */
    data: XOR<PetUpdateManyMutationInput, PetUncheckedUpdateManyInput>
    /**
     * Filter which Pets to update
     */
    where?: PetWhereInput
    /**
     * Limit how many Pets to update.
     */
    limit?: number
  }

  /**
   * Pet updateManyAndReturn
   */
  export type PetUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pet
     */
    select?: PetSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Pet
     */
    omit?: PetOmit<ExtArgs> | null
    /**
     * The data used to update Pets.
     */
    data: XOR<PetUpdateManyMutationInput, PetUncheckedUpdateManyInput>
    /**
     * Filter which Pets to update
     */
    where?: PetWhereInput
    /**
     * Limit how many Pets to update.
     */
    limit?: number
  }

  /**
   * Pet upsert
   */
  export type PetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pet
     */
    select?: PetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pet
     */
    omit?: PetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PetInclude<ExtArgs> | null
    /**
     * The filter to search for the Pet to update in case it exists.
     */
    where: PetWhereUniqueInput
    /**
     * In case the Pet found by the `where` argument doesn't exist, create a new Pet with this data.
     */
    create: XOR<PetCreateInput, PetUncheckedCreateInput>
    /**
     * In case the Pet was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PetUpdateInput, PetUncheckedUpdateInput>
  }

  /**
   * Pet delete
   */
  export type PetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pet
     */
    select?: PetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pet
     */
    omit?: PetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PetInclude<ExtArgs> | null
    /**
     * Filter which Pet to delete.
     */
    where: PetWhereUniqueInput
  }

  /**
   * Pet deleteMany
   */
  export type PetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Pets to delete
     */
    where?: PetWhereInput
    /**
     * Limit how many Pets to delete.
     */
    limit?: number
  }

  /**
   * Pet.races
   */
  export type Pet$racesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Race
     */
    select?: RaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Race
     */
    omit?: RaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceInclude<ExtArgs> | null
    where?: RaceWhereInput
    orderBy?: RaceOrderByWithRelationInput | RaceOrderByWithRelationInput[]
    cursor?: RaceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RaceScalarFieldEnum | RaceScalarFieldEnum[]
  }

  /**
   * Pet.vaccine
   */
  export type Pet$vaccineArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vaccine
     */
    select?: VaccineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vaccine
     */
    omit?: VaccineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VaccineInclude<ExtArgs> | null
    where?: VaccineWhereInput
    orderBy?: VaccineOrderByWithRelationInput | VaccineOrderByWithRelationInput[]
    cursor?: VaccineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VaccineScalarFieldEnum | VaccineScalarFieldEnum[]
  }

  /**
   * Pet without action
   */
  export type PetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pet
     */
    select?: PetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pet
     */
    omit?: PetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PetInclude<ExtArgs> | null
  }


  /**
   * Model Race
   */

  export type AggregateRace = {
    _count: RaceCountAggregateOutputType | null
    _min: RaceMinAggregateOutputType | null
    _max: RaceMaxAggregateOutputType | null
  }

  export type RaceMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    name: string | null
    picture: string | null
    petId: string | null
  }

  export type RaceMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    name: string | null
    picture: string | null
    petId: string | null
  }

  export type RaceCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    name: number
    picture: number
    petId: number
    _all: number
  }


  export type RaceMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    picture?: true
    petId?: true
  }

  export type RaceMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    picture?: true
    petId?: true
  }

  export type RaceCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    picture?: true
    petId?: true
    _all?: true
  }

  export type RaceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Race to aggregate.
     */
    where?: RaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Races to fetch.
     */
    orderBy?: RaceOrderByWithRelationInput | RaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Races from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Races.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Races
    **/
    _count?: true | RaceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RaceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RaceMaxAggregateInputType
  }

  export type GetRaceAggregateType<T extends RaceAggregateArgs> = {
        [P in keyof T & keyof AggregateRace]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRace[P]>
      : GetScalarType<T[P], AggregateRace[P]>
  }




  export type RaceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RaceWhereInput
    orderBy?: RaceOrderByWithAggregationInput | RaceOrderByWithAggregationInput[]
    by: RaceScalarFieldEnum[] | RaceScalarFieldEnum
    having?: RaceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RaceCountAggregateInputType | true
    _min?: RaceMinAggregateInputType
    _max?: RaceMaxAggregateInputType
  }

  export type RaceGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    name: string
    picture: string | null
    petId: string
    _count: RaceCountAggregateOutputType | null
    _min: RaceMinAggregateOutputType | null
    _max: RaceMaxAggregateOutputType | null
  }

  type GetRaceGroupByPayload<T extends RaceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RaceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RaceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RaceGroupByOutputType[P]>
            : GetScalarType<T[P], RaceGroupByOutputType[P]>
        }
      >
    >


  export type RaceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    picture?: boolean
    petId?: boolean
    pet?: boolean | PetDefaultArgs<ExtArgs>
    clientPet?: boolean | Race$clientPetArgs<ExtArgs>
    _count?: boolean | RaceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["race"]>

  export type RaceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    picture?: boolean
    petId?: boolean
    pet?: boolean | PetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["race"]>

  export type RaceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    picture?: boolean
    petId?: boolean
    pet?: boolean | PetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["race"]>

  export type RaceSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    picture?: boolean
    petId?: boolean
  }

  export type RaceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "name" | "picture" | "petId", ExtArgs["result"]["race"]>
  export type RaceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pet?: boolean | PetDefaultArgs<ExtArgs>
    clientPet?: boolean | Race$clientPetArgs<ExtArgs>
    _count?: boolean | RaceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RaceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pet?: boolean | PetDefaultArgs<ExtArgs>
  }
  export type RaceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pet?: boolean | PetDefaultArgs<ExtArgs>
  }

  export type $RacePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Race"
    objects: {
      pet: Prisma.$PetPayload<ExtArgs>
      clientPet: Prisma.$ClientPetPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      name: string
      picture: string | null
      petId: string
    }, ExtArgs["result"]["race"]>
    composites: {}
  }

  type RaceGetPayload<S extends boolean | null | undefined | RaceDefaultArgs> = $Result.GetResult<Prisma.$RacePayload, S>

  type RaceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RaceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RaceCountAggregateInputType | true
    }

  export interface RaceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Race'], meta: { name: 'Race' } }
    /**
     * Find zero or one Race that matches the filter.
     * @param {RaceFindUniqueArgs} args - Arguments to find a Race
     * @example
     * // Get one Race
     * const race = await prisma.race.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RaceFindUniqueArgs>(args: SelectSubset<T, RaceFindUniqueArgs<ExtArgs>>): Prisma__RaceClient<$Result.GetResult<Prisma.$RacePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Race that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RaceFindUniqueOrThrowArgs} args - Arguments to find a Race
     * @example
     * // Get one Race
     * const race = await prisma.race.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RaceFindUniqueOrThrowArgs>(args: SelectSubset<T, RaceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RaceClient<$Result.GetResult<Prisma.$RacePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Race that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaceFindFirstArgs} args - Arguments to find a Race
     * @example
     * // Get one Race
     * const race = await prisma.race.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RaceFindFirstArgs>(args?: SelectSubset<T, RaceFindFirstArgs<ExtArgs>>): Prisma__RaceClient<$Result.GetResult<Prisma.$RacePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Race that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaceFindFirstOrThrowArgs} args - Arguments to find a Race
     * @example
     * // Get one Race
     * const race = await prisma.race.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RaceFindFirstOrThrowArgs>(args?: SelectSubset<T, RaceFindFirstOrThrowArgs<ExtArgs>>): Prisma__RaceClient<$Result.GetResult<Prisma.$RacePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Races that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Races
     * const races = await prisma.race.findMany()
     * 
     * // Get first 10 Races
     * const races = await prisma.race.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const raceWithIdOnly = await prisma.race.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RaceFindManyArgs>(args?: SelectSubset<T, RaceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RacePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Race.
     * @param {RaceCreateArgs} args - Arguments to create a Race.
     * @example
     * // Create one Race
     * const Race = await prisma.race.create({
     *   data: {
     *     // ... data to create a Race
     *   }
     * })
     * 
     */
    create<T extends RaceCreateArgs>(args: SelectSubset<T, RaceCreateArgs<ExtArgs>>): Prisma__RaceClient<$Result.GetResult<Prisma.$RacePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Races.
     * @param {RaceCreateManyArgs} args - Arguments to create many Races.
     * @example
     * // Create many Races
     * const race = await prisma.race.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RaceCreateManyArgs>(args?: SelectSubset<T, RaceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Races and returns the data saved in the database.
     * @param {RaceCreateManyAndReturnArgs} args - Arguments to create many Races.
     * @example
     * // Create many Races
     * const race = await prisma.race.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Races and only return the `id`
     * const raceWithIdOnly = await prisma.race.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RaceCreateManyAndReturnArgs>(args?: SelectSubset<T, RaceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RacePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Race.
     * @param {RaceDeleteArgs} args - Arguments to delete one Race.
     * @example
     * // Delete one Race
     * const Race = await prisma.race.delete({
     *   where: {
     *     // ... filter to delete one Race
     *   }
     * })
     * 
     */
    delete<T extends RaceDeleteArgs>(args: SelectSubset<T, RaceDeleteArgs<ExtArgs>>): Prisma__RaceClient<$Result.GetResult<Prisma.$RacePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Race.
     * @param {RaceUpdateArgs} args - Arguments to update one Race.
     * @example
     * // Update one Race
     * const race = await prisma.race.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RaceUpdateArgs>(args: SelectSubset<T, RaceUpdateArgs<ExtArgs>>): Prisma__RaceClient<$Result.GetResult<Prisma.$RacePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Races.
     * @param {RaceDeleteManyArgs} args - Arguments to filter Races to delete.
     * @example
     * // Delete a few Races
     * const { count } = await prisma.race.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RaceDeleteManyArgs>(args?: SelectSubset<T, RaceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Races.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Races
     * const race = await prisma.race.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RaceUpdateManyArgs>(args: SelectSubset<T, RaceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Races and returns the data updated in the database.
     * @param {RaceUpdateManyAndReturnArgs} args - Arguments to update many Races.
     * @example
     * // Update many Races
     * const race = await prisma.race.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Races and only return the `id`
     * const raceWithIdOnly = await prisma.race.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RaceUpdateManyAndReturnArgs>(args: SelectSubset<T, RaceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RacePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Race.
     * @param {RaceUpsertArgs} args - Arguments to update or create a Race.
     * @example
     * // Update or create a Race
     * const race = await prisma.race.upsert({
     *   create: {
     *     // ... data to create a Race
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Race we want to update
     *   }
     * })
     */
    upsert<T extends RaceUpsertArgs>(args: SelectSubset<T, RaceUpsertArgs<ExtArgs>>): Prisma__RaceClient<$Result.GetResult<Prisma.$RacePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Races.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaceCountArgs} args - Arguments to filter Races to count.
     * @example
     * // Count the number of Races
     * const count = await prisma.race.count({
     *   where: {
     *     // ... the filter for the Races we want to count
     *   }
     * })
    **/
    count<T extends RaceCountArgs>(
      args?: Subset<T, RaceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RaceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Race.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RaceAggregateArgs>(args: Subset<T, RaceAggregateArgs>): Prisma.PrismaPromise<GetRaceAggregateType<T>>

    /**
     * Group by Race.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RaceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RaceGroupByArgs['orderBy'] }
        : { orderBy?: RaceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RaceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRaceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Race model
   */
  readonly fields: RaceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Race.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RaceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    pet<T extends PetDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PetDefaultArgs<ExtArgs>>): Prisma__PetClient<$Result.GetResult<Prisma.$PetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    clientPet<T extends Race$clientPetArgs<ExtArgs> = {}>(args?: Subset<T, Race$clientPetArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientPetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Race model
   */
  interface RaceFieldRefs {
    readonly id: FieldRef<"Race", 'String'>
    readonly createdAt: FieldRef<"Race", 'DateTime'>
    readonly updatedAt: FieldRef<"Race", 'DateTime'>
    readonly name: FieldRef<"Race", 'String'>
    readonly picture: FieldRef<"Race", 'String'>
    readonly petId: FieldRef<"Race", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Race findUnique
   */
  export type RaceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Race
     */
    select?: RaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Race
     */
    omit?: RaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceInclude<ExtArgs> | null
    /**
     * Filter, which Race to fetch.
     */
    where: RaceWhereUniqueInput
  }

  /**
   * Race findUniqueOrThrow
   */
  export type RaceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Race
     */
    select?: RaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Race
     */
    omit?: RaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceInclude<ExtArgs> | null
    /**
     * Filter, which Race to fetch.
     */
    where: RaceWhereUniqueInput
  }

  /**
   * Race findFirst
   */
  export type RaceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Race
     */
    select?: RaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Race
     */
    omit?: RaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceInclude<ExtArgs> | null
    /**
     * Filter, which Race to fetch.
     */
    where?: RaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Races to fetch.
     */
    orderBy?: RaceOrderByWithRelationInput | RaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Races.
     */
    cursor?: RaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Races from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Races.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Races.
     */
    distinct?: RaceScalarFieldEnum | RaceScalarFieldEnum[]
  }

  /**
   * Race findFirstOrThrow
   */
  export type RaceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Race
     */
    select?: RaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Race
     */
    omit?: RaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceInclude<ExtArgs> | null
    /**
     * Filter, which Race to fetch.
     */
    where?: RaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Races to fetch.
     */
    orderBy?: RaceOrderByWithRelationInput | RaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Races.
     */
    cursor?: RaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Races from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Races.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Races.
     */
    distinct?: RaceScalarFieldEnum | RaceScalarFieldEnum[]
  }

  /**
   * Race findMany
   */
  export type RaceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Race
     */
    select?: RaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Race
     */
    omit?: RaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceInclude<ExtArgs> | null
    /**
     * Filter, which Races to fetch.
     */
    where?: RaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Races to fetch.
     */
    orderBy?: RaceOrderByWithRelationInput | RaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Races.
     */
    cursor?: RaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Races from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Races.
     */
    skip?: number
    distinct?: RaceScalarFieldEnum | RaceScalarFieldEnum[]
  }

  /**
   * Race create
   */
  export type RaceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Race
     */
    select?: RaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Race
     */
    omit?: RaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceInclude<ExtArgs> | null
    /**
     * The data needed to create a Race.
     */
    data: XOR<RaceCreateInput, RaceUncheckedCreateInput>
  }

  /**
   * Race createMany
   */
  export type RaceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Races.
     */
    data: RaceCreateManyInput | RaceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Race createManyAndReturn
   */
  export type RaceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Race
     */
    select?: RaceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Race
     */
    omit?: RaceOmit<ExtArgs> | null
    /**
     * The data used to create many Races.
     */
    data: RaceCreateManyInput | RaceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Race update
   */
  export type RaceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Race
     */
    select?: RaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Race
     */
    omit?: RaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceInclude<ExtArgs> | null
    /**
     * The data needed to update a Race.
     */
    data: XOR<RaceUpdateInput, RaceUncheckedUpdateInput>
    /**
     * Choose, which Race to update.
     */
    where: RaceWhereUniqueInput
  }

  /**
   * Race updateMany
   */
  export type RaceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Races.
     */
    data: XOR<RaceUpdateManyMutationInput, RaceUncheckedUpdateManyInput>
    /**
     * Filter which Races to update
     */
    where?: RaceWhereInput
    /**
     * Limit how many Races to update.
     */
    limit?: number
  }

  /**
   * Race updateManyAndReturn
   */
  export type RaceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Race
     */
    select?: RaceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Race
     */
    omit?: RaceOmit<ExtArgs> | null
    /**
     * The data used to update Races.
     */
    data: XOR<RaceUpdateManyMutationInput, RaceUncheckedUpdateManyInput>
    /**
     * Filter which Races to update
     */
    where?: RaceWhereInput
    /**
     * Limit how many Races to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Race upsert
   */
  export type RaceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Race
     */
    select?: RaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Race
     */
    omit?: RaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceInclude<ExtArgs> | null
    /**
     * The filter to search for the Race to update in case it exists.
     */
    where: RaceWhereUniqueInput
    /**
     * In case the Race found by the `where` argument doesn't exist, create a new Race with this data.
     */
    create: XOR<RaceCreateInput, RaceUncheckedCreateInput>
    /**
     * In case the Race was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RaceUpdateInput, RaceUncheckedUpdateInput>
  }

  /**
   * Race delete
   */
  export type RaceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Race
     */
    select?: RaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Race
     */
    omit?: RaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceInclude<ExtArgs> | null
    /**
     * Filter which Race to delete.
     */
    where: RaceWhereUniqueInput
  }

  /**
   * Race deleteMany
   */
  export type RaceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Races to delete
     */
    where?: RaceWhereInput
    /**
     * Limit how many Races to delete.
     */
    limit?: number
  }

  /**
   * Race.clientPet
   */
  export type Race$clientPetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientPet
     */
    select?: ClientPetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientPet
     */
    omit?: ClientPetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientPetInclude<ExtArgs> | null
    where?: ClientPetWhereInput
    orderBy?: ClientPetOrderByWithRelationInput | ClientPetOrderByWithRelationInput[]
    cursor?: ClientPetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClientPetScalarFieldEnum | ClientPetScalarFieldEnum[]
  }

  /**
   * Race without action
   */
  export type RaceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Race
     */
    select?: RaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Race
     */
    omit?: RaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceInclude<ExtArgs> | null
  }


  /**
   * Model Vaccine
   */

  export type AggregateVaccine = {
    _count: VaccineCountAggregateOutputType | null
    _avg: VaccineAvgAggregateOutputType | null
    _sum: VaccineSumAggregateOutputType | null
    _min: VaccineMinAggregateOutputType | null
    _max: VaccineMaxAggregateOutputType | null
  }

  export type VaccineAvgAggregateOutputType = {
    recommendedAge: number | null
    boosterInterval: number | null
  }

  export type VaccineSumAggregateOutputType = {
    recommendedAge: number | null
    boosterInterval: number | null
  }

  export type VaccineMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    name: string | null
    description: string | null
    recommendedAge: number | null
    boosterInterval: number | null
    petId: string | null
  }

  export type VaccineMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    name: string | null
    description: string | null
    recommendedAge: number | null
    boosterInterval: number | null
    petId: string | null
  }

  export type VaccineCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    name: number
    description: number
    recommendedAge: number
    boosterInterval: number
    mandatoryCountry: number
    recommendedCountry: number
    petId: number
    _all: number
  }


  export type VaccineAvgAggregateInputType = {
    recommendedAge?: true
    boosterInterval?: true
  }

  export type VaccineSumAggregateInputType = {
    recommendedAge?: true
    boosterInterval?: true
  }

  export type VaccineMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    description?: true
    recommendedAge?: true
    boosterInterval?: true
    petId?: true
  }

  export type VaccineMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    description?: true
    recommendedAge?: true
    boosterInterval?: true
    petId?: true
  }

  export type VaccineCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    description?: true
    recommendedAge?: true
    boosterInterval?: true
    mandatoryCountry?: true
    recommendedCountry?: true
    petId?: true
    _all?: true
  }

  export type VaccineAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Vaccine to aggregate.
     */
    where?: VaccineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vaccines to fetch.
     */
    orderBy?: VaccineOrderByWithRelationInput | VaccineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VaccineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vaccines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vaccines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Vaccines
    **/
    _count?: true | VaccineCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VaccineAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VaccineSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VaccineMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VaccineMaxAggregateInputType
  }

  export type GetVaccineAggregateType<T extends VaccineAggregateArgs> = {
        [P in keyof T & keyof AggregateVaccine]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVaccine[P]>
      : GetScalarType<T[P], AggregateVaccine[P]>
  }




  export type VaccineGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VaccineWhereInput
    orderBy?: VaccineOrderByWithAggregationInput | VaccineOrderByWithAggregationInput[]
    by: VaccineScalarFieldEnum[] | VaccineScalarFieldEnum
    having?: VaccineScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VaccineCountAggregateInputType | true
    _avg?: VaccineAvgAggregateInputType
    _sum?: VaccineSumAggregateInputType
    _min?: VaccineMinAggregateInputType
    _max?: VaccineMaxAggregateInputType
  }

  export type VaccineGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    name: string
    description: string | null
    recommendedAge: number
    boosterInterval: number
    mandatoryCountry: JsonValue | null
    recommendedCountry: JsonValue | null
    petId: string
    _count: VaccineCountAggregateOutputType | null
    _avg: VaccineAvgAggregateOutputType | null
    _sum: VaccineSumAggregateOutputType | null
    _min: VaccineMinAggregateOutputType | null
    _max: VaccineMaxAggregateOutputType | null
  }

  type GetVaccineGroupByPayload<T extends VaccineGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VaccineGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VaccineGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VaccineGroupByOutputType[P]>
            : GetScalarType<T[P], VaccineGroupByOutputType[P]>
        }
      >
    >


  export type VaccineSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    description?: boolean
    recommendedAge?: boolean
    boosterInterval?: boolean
    mandatoryCountry?: boolean
    recommendedCountry?: boolean
    petId?: boolean
    pet?: boolean | PetDefaultArgs<ExtArgs>
    personalPetVaccine?: boolean | Vaccine$personalPetVaccineArgs<ExtArgs>
    _count?: boolean | VaccineCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vaccine"]>

  export type VaccineSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    description?: boolean
    recommendedAge?: boolean
    boosterInterval?: boolean
    mandatoryCountry?: boolean
    recommendedCountry?: boolean
    petId?: boolean
    pet?: boolean | PetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vaccine"]>

  export type VaccineSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    description?: boolean
    recommendedAge?: boolean
    boosterInterval?: boolean
    mandatoryCountry?: boolean
    recommendedCountry?: boolean
    petId?: boolean
    pet?: boolean | PetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vaccine"]>

  export type VaccineSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    description?: boolean
    recommendedAge?: boolean
    boosterInterval?: boolean
    mandatoryCountry?: boolean
    recommendedCountry?: boolean
    petId?: boolean
  }

  export type VaccineOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "name" | "description" | "recommendedAge" | "boosterInterval" | "mandatoryCountry" | "recommendedCountry" | "petId", ExtArgs["result"]["vaccine"]>
  export type VaccineInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pet?: boolean | PetDefaultArgs<ExtArgs>
    personalPetVaccine?: boolean | Vaccine$personalPetVaccineArgs<ExtArgs>
    _count?: boolean | VaccineCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type VaccineIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pet?: boolean | PetDefaultArgs<ExtArgs>
  }
  export type VaccineIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pet?: boolean | PetDefaultArgs<ExtArgs>
  }

  export type $VaccinePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Vaccine"
    objects: {
      pet: Prisma.$PetPayload<ExtArgs>
      personalPetVaccine: Prisma.$PersonalPetVaccinePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      name: string
      description: string | null
      recommendedAge: number
      boosterInterval: number
      mandatoryCountry: Prisma.JsonValue | null
      recommendedCountry: Prisma.JsonValue | null
      petId: string
    }, ExtArgs["result"]["vaccine"]>
    composites: {}
  }

  type VaccineGetPayload<S extends boolean | null | undefined | VaccineDefaultArgs> = $Result.GetResult<Prisma.$VaccinePayload, S>

  type VaccineCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VaccineFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VaccineCountAggregateInputType | true
    }

  export interface VaccineDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Vaccine'], meta: { name: 'Vaccine' } }
    /**
     * Find zero or one Vaccine that matches the filter.
     * @param {VaccineFindUniqueArgs} args - Arguments to find a Vaccine
     * @example
     * // Get one Vaccine
     * const vaccine = await prisma.vaccine.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VaccineFindUniqueArgs>(args: SelectSubset<T, VaccineFindUniqueArgs<ExtArgs>>): Prisma__VaccineClient<$Result.GetResult<Prisma.$VaccinePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Vaccine that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VaccineFindUniqueOrThrowArgs} args - Arguments to find a Vaccine
     * @example
     * // Get one Vaccine
     * const vaccine = await prisma.vaccine.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VaccineFindUniqueOrThrowArgs>(args: SelectSubset<T, VaccineFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VaccineClient<$Result.GetResult<Prisma.$VaccinePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Vaccine that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VaccineFindFirstArgs} args - Arguments to find a Vaccine
     * @example
     * // Get one Vaccine
     * const vaccine = await prisma.vaccine.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VaccineFindFirstArgs>(args?: SelectSubset<T, VaccineFindFirstArgs<ExtArgs>>): Prisma__VaccineClient<$Result.GetResult<Prisma.$VaccinePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Vaccine that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VaccineFindFirstOrThrowArgs} args - Arguments to find a Vaccine
     * @example
     * // Get one Vaccine
     * const vaccine = await prisma.vaccine.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VaccineFindFirstOrThrowArgs>(args?: SelectSubset<T, VaccineFindFirstOrThrowArgs<ExtArgs>>): Prisma__VaccineClient<$Result.GetResult<Prisma.$VaccinePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Vaccines that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VaccineFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Vaccines
     * const vaccines = await prisma.vaccine.findMany()
     * 
     * // Get first 10 Vaccines
     * const vaccines = await prisma.vaccine.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vaccineWithIdOnly = await prisma.vaccine.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VaccineFindManyArgs>(args?: SelectSubset<T, VaccineFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VaccinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Vaccine.
     * @param {VaccineCreateArgs} args - Arguments to create a Vaccine.
     * @example
     * // Create one Vaccine
     * const Vaccine = await prisma.vaccine.create({
     *   data: {
     *     // ... data to create a Vaccine
     *   }
     * })
     * 
     */
    create<T extends VaccineCreateArgs>(args: SelectSubset<T, VaccineCreateArgs<ExtArgs>>): Prisma__VaccineClient<$Result.GetResult<Prisma.$VaccinePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Vaccines.
     * @param {VaccineCreateManyArgs} args - Arguments to create many Vaccines.
     * @example
     * // Create many Vaccines
     * const vaccine = await prisma.vaccine.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VaccineCreateManyArgs>(args?: SelectSubset<T, VaccineCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Vaccines and returns the data saved in the database.
     * @param {VaccineCreateManyAndReturnArgs} args - Arguments to create many Vaccines.
     * @example
     * // Create many Vaccines
     * const vaccine = await prisma.vaccine.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Vaccines and only return the `id`
     * const vaccineWithIdOnly = await prisma.vaccine.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VaccineCreateManyAndReturnArgs>(args?: SelectSubset<T, VaccineCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VaccinePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Vaccine.
     * @param {VaccineDeleteArgs} args - Arguments to delete one Vaccine.
     * @example
     * // Delete one Vaccine
     * const Vaccine = await prisma.vaccine.delete({
     *   where: {
     *     // ... filter to delete one Vaccine
     *   }
     * })
     * 
     */
    delete<T extends VaccineDeleteArgs>(args: SelectSubset<T, VaccineDeleteArgs<ExtArgs>>): Prisma__VaccineClient<$Result.GetResult<Prisma.$VaccinePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Vaccine.
     * @param {VaccineUpdateArgs} args - Arguments to update one Vaccine.
     * @example
     * // Update one Vaccine
     * const vaccine = await prisma.vaccine.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VaccineUpdateArgs>(args: SelectSubset<T, VaccineUpdateArgs<ExtArgs>>): Prisma__VaccineClient<$Result.GetResult<Prisma.$VaccinePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Vaccines.
     * @param {VaccineDeleteManyArgs} args - Arguments to filter Vaccines to delete.
     * @example
     * // Delete a few Vaccines
     * const { count } = await prisma.vaccine.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VaccineDeleteManyArgs>(args?: SelectSubset<T, VaccineDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Vaccines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VaccineUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Vaccines
     * const vaccine = await prisma.vaccine.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VaccineUpdateManyArgs>(args: SelectSubset<T, VaccineUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Vaccines and returns the data updated in the database.
     * @param {VaccineUpdateManyAndReturnArgs} args - Arguments to update many Vaccines.
     * @example
     * // Update many Vaccines
     * const vaccine = await prisma.vaccine.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Vaccines and only return the `id`
     * const vaccineWithIdOnly = await prisma.vaccine.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VaccineUpdateManyAndReturnArgs>(args: SelectSubset<T, VaccineUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VaccinePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Vaccine.
     * @param {VaccineUpsertArgs} args - Arguments to update or create a Vaccine.
     * @example
     * // Update or create a Vaccine
     * const vaccine = await prisma.vaccine.upsert({
     *   create: {
     *     // ... data to create a Vaccine
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Vaccine we want to update
     *   }
     * })
     */
    upsert<T extends VaccineUpsertArgs>(args: SelectSubset<T, VaccineUpsertArgs<ExtArgs>>): Prisma__VaccineClient<$Result.GetResult<Prisma.$VaccinePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Vaccines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VaccineCountArgs} args - Arguments to filter Vaccines to count.
     * @example
     * // Count the number of Vaccines
     * const count = await prisma.vaccine.count({
     *   where: {
     *     // ... the filter for the Vaccines we want to count
     *   }
     * })
    **/
    count<T extends VaccineCountArgs>(
      args?: Subset<T, VaccineCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VaccineCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Vaccine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VaccineAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VaccineAggregateArgs>(args: Subset<T, VaccineAggregateArgs>): Prisma.PrismaPromise<GetVaccineAggregateType<T>>

    /**
     * Group by Vaccine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VaccineGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VaccineGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VaccineGroupByArgs['orderBy'] }
        : { orderBy?: VaccineGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VaccineGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVaccineGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Vaccine model
   */
  readonly fields: VaccineFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Vaccine.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VaccineClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    pet<T extends PetDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PetDefaultArgs<ExtArgs>>): Prisma__PetClient<$Result.GetResult<Prisma.$PetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    personalPetVaccine<T extends Vaccine$personalPetVaccineArgs<ExtArgs> = {}>(args?: Subset<T, Vaccine$personalPetVaccineArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersonalPetVaccinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Vaccine model
   */
  interface VaccineFieldRefs {
    readonly id: FieldRef<"Vaccine", 'String'>
    readonly createdAt: FieldRef<"Vaccine", 'DateTime'>
    readonly updatedAt: FieldRef<"Vaccine", 'DateTime'>
    readonly name: FieldRef<"Vaccine", 'String'>
    readonly description: FieldRef<"Vaccine", 'String'>
    readonly recommendedAge: FieldRef<"Vaccine", 'Int'>
    readonly boosterInterval: FieldRef<"Vaccine", 'Int'>
    readonly mandatoryCountry: FieldRef<"Vaccine", 'Json'>
    readonly recommendedCountry: FieldRef<"Vaccine", 'Json'>
    readonly petId: FieldRef<"Vaccine", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Vaccine findUnique
   */
  export type VaccineFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vaccine
     */
    select?: VaccineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vaccine
     */
    omit?: VaccineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VaccineInclude<ExtArgs> | null
    /**
     * Filter, which Vaccine to fetch.
     */
    where: VaccineWhereUniqueInput
  }

  /**
   * Vaccine findUniqueOrThrow
   */
  export type VaccineFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vaccine
     */
    select?: VaccineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vaccine
     */
    omit?: VaccineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VaccineInclude<ExtArgs> | null
    /**
     * Filter, which Vaccine to fetch.
     */
    where: VaccineWhereUniqueInput
  }

  /**
   * Vaccine findFirst
   */
  export type VaccineFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vaccine
     */
    select?: VaccineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vaccine
     */
    omit?: VaccineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VaccineInclude<ExtArgs> | null
    /**
     * Filter, which Vaccine to fetch.
     */
    where?: VaccineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vaccines to fetch.
     */
    orderBy?: VaccineOrderByWithRelationInput | VaccineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Vaccines.
     */
    cursor?: VaccineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vaccines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vaccines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Vaccines.
     */
    distinct?: VaccineScalarFieldEnum | VaccineScalarFieldEnum[]
  }

  /**
   * Vaccine findFirstOrThrow
   */
  export type VaccineFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vaccine
     */
    select?: VaccineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vaccine
     */
    omit?: VaccineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VaccineInclude<ExtArgs> | null
    /**
     * Filter, which Vaccine to fetch.
     */
    where?: VaccineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vaccines to fetch.
     */
    orderBy?: VaccineOrderByWithRelationInput | VaccineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Vaccines.
     */
    cursor?: VaccineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vaccines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vaccines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Vaccines.
     */
    distinct?: VaccineScalarFieldEnum | VaccineScalarFieldEnum[]
  }

  /**
   * Vaccine findMany
   */
  export type VaccineFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vaccine
     */
    select?: VaccineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vaccine
     */
    omit?: VaccineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VaccineInclude<ExtArgs> | null
    /**
     * Filter, which Vaccines to fetch.
     */
    where?: VaccineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vaccines to fetch.
     */
    orderBy?: VaccineOrderByWithRelationInput | VaccineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Vaccines.
     */
    cursor?: VaccineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vaccines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vaccines.
     */
    skip?: number
    distinct?: VaccineScalarFieldEnum | VaccineScalarFieldEnum[]
  }

  /**
   * Vaccine create
   */
  export type VaccineCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vaccine
     */
    select?: VaccineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vaccine
     */
    omit?: VaccineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VaccineInclude<ExtArgs> | null
    /**
     * The data needed to create a Vaccine.
     */
    data: XOR<VaccineCreateInput, VaccineUncheckedCreateInput>
  }

  /**
   * Vaccine createMany
   */
  export type VaccineCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Vaccines.
     */
    data: VaccineCreateManyInput | VaccineCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Vaccine createManyAndReturn
   */
  export type VaccineCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vaccine
     */
    select?: VaccineSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Vaccine
     */
    omit?: VaccineOmit<ExtArgs> | null
    /**
     * The data used to create many Vaccines.
     */
    data: VaccineCreateManyInput | VaccineCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VaccineIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Vaccine update
   */
  export type VaccineUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vaccine
     */
    select?: VaccineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vaccine
     */
    omit?: VaccineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VaccineInclude<ExtArgs> | null
    /**
     * The data needed to update a Vaccine.
     */
    data: XOR<VaccineUpdateInput, VaccineUncheckedUpdateInput>
    /**
     * Choose, which Vaccine to update.
     */
    where: VaccineWhereUniqueInput
  }

  /**
   * Vaccine updateMany
   */
  export type VaccineUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Vaccines.
     */
    data: XOR<VaccineUpdateManyMutationInput, VaccineUncheckedUpdateManyInput>
    /**
     * Filter which Vaccines to update
     */
    where?: VaccineWhereInput
    /**
     * Limit how many Vaccines to update.
     */
    limit?: number
  }

  /**
   * Vaccine updateManyAndReturn
   */
  export type VaccineUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vaccine
     */
    select?: VaccineSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Vaccine
     */
    omit?: VaccineOmit<ExtArgs> | null
    /**
     * The data used to update Vaccines.
     */
    data: XOR<VaccineUpdateManyMutationInput, VaccineUncheckedUpdateManyInput>
    /**
     * Filter which Vaccines to update
     */
    where?: VaccineWhereInput
    /**
     * Limit how many Vaccines to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VaccineIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Vaccine upsert
   */
  export type VaccineUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vaccine
     */
    select?: VaccineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vaccine
     */
    omit?: VaccineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VaccineInclude<ExtArgs> | null
    /**
     * The filter to search for the Vaccine to update in case it exists.
     */
    where: VaccineWhereUniqueInput
    /**
     * In case the Vaccine found by the `where` argument doesn't exist, create a new Vaccine with this data.
     */
    create: XOR<VaccineCreateInput, VaccineUncheckedCreateInput>
    /**
     * In case the Vaccine was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VaccineUpdateInput, VaccineUncheckedUpdateInput>
  }

  /**
   * Vaccine delete
   */
  export type VaccineDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vaccine
     */
    select?: VaccineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vaccine
     */
    omit?: VaccineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VaccineInclude<ExtArgs> | null
    /**
     * Filter which Vaccine to delete.
     */
    where: VaccineWhereUniqueInput
  }

  /**
   * Vaccine deleteMany
   */
  export type VaccineDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Vaccines to delete
     */
    where?: VaccineWhereInput
    /**
     * Limit how many Vaccines to delete.
     */
    limit?: number
  }

  /**
   * Vaccine.personalPetVaccine
   */
  export type Vaccine$personalPetVaccineArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalPetVaccine
     */
    select?: PersonalPetVaccineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonalPetVaccine
     */
    omit?: PersonalPetVaccineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonalPetVaccineInclude<ExtArgs> | null
    where?: PersonalPetVaccineWhereInput
    orderBy?: PersonalPetVaccineOrderByWithRelationInput | PersonalPetVaccineOrderByWithRelationInput[]
    cursor?: PersonalPetVaccineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PersonalPetVaccineScalarFieldEnum | PersonalPetVaccineScalarFieldEnum[]
  }

  /**
   * Vaccine without action
   */
  export type VaccineDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vaccine
     */
    select?: VaccineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vaccine
     */
    omit?: VaccineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VaccineInclude<ExtArgs> | null
  }


  /**
   * Model PersonalPetVaccine
   */

  export type AggregatePersonalPetVaccine = {
    _count: PersonalPetVaccineCountAggregateOutputType | null
    _min: PersonalPetVaccineMinAggregateOutputType | null
    _max: PersonalPetVaccineMaxAggregateOutputType | null
  }

  export type PersonalPetVaccineMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    clientPetId: string | null
    vaccineId: string | null
    mettingId: string | null
  }

  export type PersonalPetVaccineMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    clientPetId: string | null
    vaccineId: string | null
    mettingId: string | null
  }

  export type PersonalPetVaccineCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    clientPetId: number
    vaccineId: number
    mettingId: number
    _all: number
  }


  export type PersonalPetVaccineMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    clientPetId?: true
    vaccineId?: true
    mettingId?: true
  }

  export type PersonalPetVaccineMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    clientPetId?: true
    vaccineId?: true
    mettingId?: true
  }

  export type PersonalPetVaccineCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    clientPetId?: true
    vaccineId?: true
    mettingId?: true
    _all?: true
  }

  export type PersonalPetVaccineAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PersonalPetVaccine to aggregate.
     */
    where?: PersonalPetVaccineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PersonalPetVaccines to fetch.
     */
    orderBy?: PersonalPetVaccineOrderByWithRelationInput | PersonalPetVaccineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PersonalPetVaccineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PersonalPetVaccines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PersonalPetVaccines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PersonalPetVaccines
    **/
    _count?: true | PersonalPetVaccineCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PersonalPetVaccineMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PersonalPetVaccineMaxAggregateInputType
  }

  export type GetPersonalPetVaccineAggregateType<T extends PersonalPetVaccineAggregateArgs> = {
        [P in keyof T & keyof AggregatePersonalPetVaccine]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePersonalPetVaccine[P]>
      : GetScalarType<T[P], AggregatePersonalPetVaccine[P]>
  }




  export type PersonalPetVaccineGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PersonalPetVaccineWhereInput
    orderBy?: PersonalPetVaccineOrderByWithAggregationInput | PersonalPetVaccineOrderByWithAggregationInput[]
    by: PersonalPetVaccineScalarFieldEnum[] | PersonalPetVaccineScalarFieldEnum
    having?: PersonalPetVaccineScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PersonalPetVaccineCountAggregateInputType | true
    _min?: PersonalPetVaccineMinAggregateInputType
    _max?: PersonalPetVaccineMaxAggregateInputType
  }

  export type PersonalPetVaccineGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    clientPetId: string
    vaccineId: string
    mettingId: string | null
    _count: PersonalPetVaccineCountAggregateOutputType | null
    _min: PersonalPetVaccineMinAggregateOutputType | null
    _max: PersonalPetVaccineMaxAggregateOutputType | null
  }

  type GetPersonalPetVaccineGroupByPayload<T extends PersonalPetVaccineGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PersonalPetVaccineGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PersonalPetVaccineGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PersonalPetVaccineGroupByOutputType[P]>
            : GetScalarType<T[P], PersonalPetVaccineGroupByOutputType[P]>
        }
      >
    >


  export type PersonalPetVaccineSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clientPetId?: boolean
    vaccineId?: boolean
    mettingId?: boolean
    clientPet?: boolean | ClientPetDefaultArgs<ExtArgs>
    vaccine?: boolean | VaccineDefaultArgs<ExtArgs>
    metting?: boolean | PersonalPetVaccine$mettingArgs<ExtArgs>
  }, ExtArgs["result"]["personalPetVaccine"]>

  export type PersonalPetVaccineSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clientPetId?: boolean
    vaccineId?: boolean
    mettingId?: boolean
    clientPet?: boolean | ClientPetDefaultArgs<ExtArgs>
    vaccine?: boolean | VaccineDefaultArgs<ExtArgs>
    metting?: boolean | PersonalPetVaccine$mettingArgs<ExtArgs>
  }, ExtArgs["result"]["personalPetVaccine"]>

  export type PersonalPetVaccineSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clientPetId?: boolean
    vaccineId?: boolean
    mettingId?: boolean
    clientPet?: boolean | ClientPetDefaultArgs<ExtArgs>
    vaccine?: boolean | VaccineDefaultArgs<ExtArgs>
    metting?: boolean | PersonalPetVaccine$mettingArgs<ExtArgs>
  }, ExtArgs["result"]["personalPetVaccine"]>

  export type PersonalPetVaccineSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clientPetId?: boolean
    vaccineId?: boolean
    mettingId?: boolean
  }

  export type PersonalPetVaccineOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "clientPetId" | "vaccineId" | "mettingId", ExtArgs["result"]["personalPetVaccine"]>
  export type PersonalPetVaccineInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clientPet?: boolean | ClientPetDefaultArgs<ExtArgs>
    vaccine?: boolean | VaccineDefaultArgs<ExtArgs>
    metting?: boolean | PersonalPetVaccine$mettingArgs<ExtArgs>
  }
  export type PersonalPetVaccineIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clientPet?: boolean | ClientPetDefaultArgs<ExtArgs>
    vaccine?: boolean | VaccineDefaultArgs<ExtArgs>
    metting?: boolean | PersonalPetVaccine$mettingArgs<ExtArgs>
  }
  export type PersonalPetVaccineIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clientPet?: boolean | ClientPetDefaultArgs<ExtArgs>
    vaccine?: boolean | VaccineDefaultArgs<ExtArgs>
    metting?: boolean | PersonalPetVaccine$mettingArgs<ExtArgs>
  }

  export type $PersonalPetVaccinePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PersonalPetVaccine"
    objects: {
      clientPet: Prisma.$ClientPetPayload<ExtArgs>
      vaccine: Prisma.$VaccinePayload<ExtArgs>
      metting: Prisma.$MettingPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      clientPetId: string
      vaccineId: string
      mettingId: string | null
    }, ExtArgs["result"]["personalPetVaccine"]>
    composites: {}
  }

  type PersonalPetVaccineGetPayload<S extends boolean | null | undefined | PersonalPetVaccineDefaultArgs> = $Result.GetResult<Prisma.$PersonalPetVaccinePayload, S>

  type PersonalPetVaccineCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PersonalPetVaccineFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PersonalPetVaccineCountAggregateInputType | true
    }

  export interface PersonalPetVaccineDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PersonalPetVaccine'], meta: { name: 'PersonalPetVaccine' } }
    /**
     * Find zero or one PersonalPetVaccine that matches the filter.
     * @param {PersonalPetVaccineFindUniqueArgs} args - Arguments to find a PersonalPetVaccine
     * @example
     * // Get one PersonalPetVaccine
     * const personalPetVaccine = await prisma.personalPetVaccine.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PersonalPetVaccineFindUniqueArgs>(args: SelectSubset<T, PersonalPetVaccineFindUniqueArgs<ExtArgs>>): Prisma__PersonalPetVaccineClient<$Result.GetResult<Prisma.$PersonalPetVaccinePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PersonalPetVaccine that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PersonalPetVaccineFindUniqueOrThrowArgs} args - Arguments to find a PersonalPetVaccine
     * @example
     * // Get one PersonalPetVaccine
     * const personalPetVaccine = await prisma.personalPetVaccine.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PersonalPetVaccineFindUniqueOrThrowArgs>(args: SelectSubset<T, PersonalPetVaccineFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PersonalPetVaccineClient<$Result.GetResult<Prisma.$PersonalPetVaccinePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PersonalPetVaccine that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonalPetVaccineFindFirstArgs} args - Arguments to find a PersonalPetVaccine
     * @example
     * // Get one PersonalPetVaccine
     * const personalPetVaccine = await prisma.personalPetVaccine.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PersonalPetVaccineFindFirstArgs>(args?: SelectSubset<T, PersonalPetVaccineFindFirstArgs<ExtArgs>>): Prisma__PersonalPetVaccineClient<$Result.GetResult<Prisma.$PersonalPetVaccinePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PersonalPetVaccine that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonalPetVaccineFindFirstOrThrowArgs} args - Arguments to find a PersonalPetVaccine
     * @example
     * // Get one PersonalPetVaccine
     * const personalPetVaccine = await prisma.personalPetVaccine.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PersonalPetVaccineFindFirstOrThrowArgs>(args?: SelectSubset<T, PersonalPetVaccineFindFirstOrThrowArgs<ExtArgs>>): Prisma__PersonalPetVaccineClient<$Result.GetResult<Prisma.$PersonalPetVaccinePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PersonalPetVaccines that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonalPetVaccineFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PersonalPetVaccines
     * const personalPetVaccines = await prisma.personalPetVaccine.findMany()
     * 
     * // Get first 10 PersonalPetVaccines
     * const personalPetVaccines = await prisma.personalPetVaccine.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const personalPetVaccineWithIdOnly = await prisma.personalPetVaccine.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PersonalPetVaccineFindManyArgs>(args?: SelectSubset<T, PersonalPetVaccineFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersonalPetVaccinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PersonalPetVaccine.
     * @param {PersonalPetVaccineCreateArgs} args - Arguments to create a PersonalPetVaccine.
     * @example
     * // Create one PersonalPetVaccine
     * const PersonalPetVaccine = await prisma.personalPetVaccine.create({
     *   data: {
     *     // ... data to create a PersonalPetVaccine
     *   }
     * })
     * 
     */
    create<T extends PersonalPetVaccineCreateArgs>(args: SelectSubset<T, PersonalPetVaccineCreateArgs<ExtArgs>>): Prisma__PersonalPetVaccineClient<$Result.GetResult<Prisma.$PersonalPetVaccinePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PersonalPetVaccines.
     * @param {PersonalPetVaccineCreateManyArgs} args - Arguments to create many PersonalPetVaccines.
     * @example
     * // Create many PersonalPetVaccines
     * const personalPetVaccine = await prisma.personalPetVaccine.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PersonalPetVaccineCreateManyArgs>(args?: SelectSubset<T, PersonalPetVaccineCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PersonalPetVaccines and returns the data saved in the database.
     * @param {PersonalPetVaccineCreateManyAndReturnArgs} args - Arguments to create many PersonalPetVaccines.
     * @example
     * // Create many PersonalPetVaccines
     * const personalPetVaccine = await prisma.personalPetVaccine.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PersonalPetVaccines and only return the `id`
     * const personalPetVaccineWithIdOnly = await prisma.personalPetVaccine.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PersonalPetVaccineCreateManyAndReturnArgs>(args?: SelectSubset<T, PersonalPetVaccineCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersonalPetVaccinePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PersonalPetVaccine.
     * @param {PersonalPetVaccineDeleteArgs} args - Arguments to delete one PersonalPetVaccine.
     * @example
     * // Delete one PersonalPetVaccine
     * const PersonalPetVaccine = await prisma.personalPetVaccine.delete({
     *   where: {
     *     // ... filter to delete one PersonalPetVaccine
     *   }
     * })
     * 
     */
    delete<T extends PersonalPetVaccineDeleteArgs>(args: SelectSubset<T, PersonalPetVaccineDeleteArgs<ExtArgs>>): Prisma__PersonalPetVaccineClient<$Result.GetResult<Prisma.$PersonalPetVaccinePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PersonalPetVaccine.
     * @param {PersonalPetVaccineUpdateArgs} args - Arguments to update one PersonalPetVaccine.
     * @example
     * // Update one PersonalPetVaccine
     * const personalPetVaccine = await prisma.personalPetVaccine.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PersonalPetVaccineUpdateArgs>(args: SelectSubset<T, PersonalPetVaccineUpdateArgs<ExtArgs>>): Prisma__PersonalPetVaccineClient<$Result.GetResult<Prisma.$PersonalPetVaccinePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PersonalPetVaccines.
     * @param {PersonalPetVaccineDeleteManyArgs} args - Arguments to filter PersonalPetVaccines to delete.
     * @example
     * // Delete a few PersonalPetVaccines
     * const { count } = await prisma.personalPetVaccine.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PersonalPetVaccineDeleteManyArgs>(args?: SelectSubset<T, PersonalPetVaccineDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PersonalPetVaccines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonalPetVaccineUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PersonalPetVaccines
     * const personalPetVaccine = await prisma.personalPetVaccine.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PersonalPetVaccineUpdateManyArgs>(args: SelectSubset<T, PersonalPetVaccineUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PersonalPetVaccines and returns the data updated in the database.
     * @param {PersonalPetVaccineUpdateManyAndReturnArgs} args - Arguments to update many PersonalPetVaccines.
     * @example
     * // Update many PersonalPetVaccines
     * const personalPetVaccine = await prisma.personalPetVaccine.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PersonalPetVaccines and only return the `id`
     * const personalPetVaccineWithIdOnly = await prisma.personalPetVaccine.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PersonalPetVaccineUpdateManyAndReturnArgs>(args: SelectSubset<T, PersonalPetVaccineUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersonalPetVaccinePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PersonalPetVaccine.
     * @param {PersonalPetVaccineUpsertArgs} args - Arguments to update or create a PersonalPetVaccine.
     * @example
     * // Update or create a PersonalPetVaccine
     * const personalPetVaccine = await prisma.personalPetVaccine.upsert({
     *   create: {
     *     // ... data to create a PersonalPetVaccine
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PersonalPetVaccine we want to update
     *   }
     * })
     */
    upsert<T extends PersonalPetVaccineUpsertArgs>(args: SelectSubset<T, PersonalPetVaccineUpsertArgs<ExtArgs>>): Prisma__PersonalPetVaccineClient<$Result.GetResult<Prisma.$PersonalPetVaccinePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PersonalPetVaccines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonalPetVaccineCountArgs} args - Arguments to filter PersonalPetVaccines to count.
     * @example
     * // Count the number of PersonalPetVaccines
     * const count = await prisma.personalPetVaccine.count({
     *   where: {
     *     // ... the filter for the PersonalPetVaccines we want to count
     *   }
     * })
    **/
    count<T extends PersonalPetVaccineCountArgs>(
      args?: Subset<T, PersonalPetVaccineCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PersonalPetVaccineCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PersonalPetVaccine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonalPetVaccineAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PersonalPetVaccineAggregateArgs>(args: Subset<T, PersonalPetVaccineAggregateArgs>): Prisma.PrismaPromise<GetPersonalPetVaccineAggregateType<T>>

    /**
     * Group by PersonalPetVaccine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonalPetVaccineGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PersonalPetVaccineGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PersonalPetVaccineGroupByArgs['orderBy'] }
        : { orderBy?: PersonalPetVaccineGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PersonalPetVaccineGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPersonalPetVaccineGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PersonalPetVaccine model
   */
  readonly fields: PersonalPetVaccineFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PersonalPetVaccine.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PersonalPetVaccineClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    clientPet<T extends ClientPetDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientPetDefaultArgs<ExtArgs>>): Prisma__ClientPetClient<$Result.GetResult<Prisma.$ClientPetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    vaccine<T extends VaccineDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VaccineDefaultArgs<ExtArgs>>): Prisma__VaccineClient<$Result.GetResult<Prisma.$VaccinePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    metting<T extends PersonalPetVaccine$mettingArgs<ExtArgs> = {}>(args?: Subset<T, PersonalPetVaccine$mettingArgs<ExtArgs>>): Prisma__MettingClient<$Result.GetResult<Prisma.$MettingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PersonalPetVaccine model
   */
  interface PersonalPetVaccineFieldRefs {
    readonly id: FieldRef<"PersonalPetVaccine", 'String'>
    readonly createdAt: FieldRef<"PersonalPetVaccine", 'DateTime'>
    readonly updatedAt: FieldRef<"PersonalPetVaccine", 'DateTime'>
    readonly clientPetId: FieldRef<"PersonalPetVaccine", 'String'>
    readonly vaccineId: FieldRef<"PersonalPetVaccine", 'String'>
    readonly mettingId: FieldRef<"PersonalPetVaccine", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PersonalPetVaccine findUnique
   */
  export type PersonalPetVaccineFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalPetVaccine
     */
    select?: PersonalPetVaccineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonalPetVaccine
     */
    omit?: PersonalPetVaccineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonalPetVaccineInclude<ExtArgs> | null
    /**
     * Filter, which PersonalPetVaccine to fetch.
     */
    where: PersonalPetVaccineWhereUniqueInput
  }

  /**
   * PersonalPetVaccine findUniqueOrThrow
   */
  export type PersonalPetVaccineFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalPetVaccine
     */
    select?: PersonalPetVaccineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonalPetVaccine
     */
    omit?: PersonalPetVaccineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonalPetVaccineInclude<ExtArgs> | null
    /**
     * Filter, which PersonalPetVaccine to fetch.
     */
    where: PersonalPetVaccineWhereUniqueInput
  }

  /**
   * PersonalPetVaccine findFirst
   */
  export type PersonalPetVaccineFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalPetVaccine
     */
    select?: PersonalPetVaccineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonalPetVaccine
     */
    omit?: PersonalPetVaccineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonalPetVaccineInclude<ExtArgs> | null
    /**
     * Filter, which PersonalPetVaccine to fetch.
     */
    where?: PersonalPetVaccineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PersonalPetVaccines to fetch.
     */
    orderBy?: PersonalPetVaccineOrderByWithRelationInput | PersonalPetVaccineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PersonalPetVaccines.
     */
    cursor?: PersonalPetVaccineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PersonalPetVaccines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PersonalPetVaccines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PersonalPetVaccines.
     */
    distinct?: PersonalPetVaccineScalarFieldEnum | PersonalPetVaccineScalarFieldEnum[]
  }

  /**
   * PersonalPetVaccine findFirstOrThrow
   */
  export type PersonalPetVaccineFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalPetVaccine
     */
    select?: PersonalPetVaccineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonalPetVaccine
     */
    omit?: PersonalPetVaccineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonalPetVaccineInclude<ExtArgs> | null
    /**
     * Filter, which PersonalPetVaccine to fetch.
     */
    where?: PersonalPetVaccineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PersonalPetVaccines to fetch.
     */
    orderBy?: PersonalPetVaccineOrderByWithRelationInput | PersonalPetVaccineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PersonalPetVaccines.
     */
    cursor?: PersonalPetVaccineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PersonalPetVaccines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PersonalPetVaccines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PersonalPetVaccines.
     */
    distinct?: PersonalPetVaccineScalarFieldEnum | PersonalPetVaccineScalarFieldEnum[]
  }

  /**
   * PersonalPetVaccine findMany
   */
  export type PersonalPetVaccineFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalPetVaccine
     */
    select?: PersonalPetVaccineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonalPetVaccine
     */
    omit?: PersonalPetVaccineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonalPetVaccineInclude<ExtArgs> | null
    /**
     * Filter, which PersonalPetVaccines to fetch.
     */
    where?: PersonalPetVaccineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PersonalPetVaccines to fetch.
     */
    orderBy?: PersonalPetVaccineOrderByWithRelationInput | PersonalPetVaccineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PersonalPetVaccines.
     */
    cursor?: PersonalPetVaccineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PersonalPetVaccines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PersonalPetVaccines.
     */
    skip?: number
    distinct?: PersonalPetVaccineScalarFieldEnum | PersonalPetVaccineScalarFieldEnum[]
  }

  /**
   * PersonalPetVaccine create
   */
  export type PersonalPetVaccineCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalPetVaccine
     */
    select?: PersonalPetVaccineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonalPetVaccine
     */
    omit?: PersonalPetVaccineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonalPetVaccineInclude<ExtArgs> | null
    /**
     * The data needed to create a PersonalPetVaccine.
     */
    data: XOR<PersonalPetVaccineCreateInput, PersonalPetVaccineUncheckedCreateInput>
  }

  /**
   * PersonalPetVaccine createMany
   */
  export type PersonalPetVaccineCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PersonalPetVaccines.
     */
    data: PersonalPetVaccineCreateManyInput | PersonalPetVaccineCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PersonalPetVaccine createManyAndReturn
   */
  export type PersonalPetVaccineCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalPetVaccine
     */
    select?: PersonalPetVaccineSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PersonalPetVaccine
     */
    omit?: PersonalPetVaccineOmit<ExtArgs> | null
    /**
     * The data used to create many PersonalPetVaccines.
     */
    data: PersonalPetVaccineCreateManyInput | PersonalPetVaccineCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonalPetVaccineIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PersonalPetVaccine update
   */
  export type PersonalPetVaccineUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalPetVaccine
     */
    select?: PersonalPetVaccineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonalPetVaccine
     */
    omit?: PersonalPetVaccineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonalPetVaccineInclude<ExtArgs> | null
    /**
     * The data needed to update a PersonalPetVaccine.
     */
    data: XOR<PersonalPetVaccineUpdateInput, PersonalPetVaccineUncheckedUpdateInput>
    /**
     * Choose, which PersonalPetVaccine to update.
     */
    where: PersonalPetVaccineWhereUniqueInput
  }

  /**
   * PersonalPetVaccine updateMany
   */
  export type PersonalPetVaccineUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PersonalPetVaccines.
     */
    data: XOR<PersonalPetVaccineUpdateManyMutationInput, PersonalPetVaccineUncheckedUpdateManyInput>
    /**
     * Filter which PersonalPetVaccines to update
     */
    where?: PersonalPetVaccineWhereInput
    /**
     * Limit how many PersonalPetVaccines to update.
     */
    limit?: number
  }

  /**
   * PersonalPetVaccine updateManyAndReturn
   */
  export type PersonalPetVaccineUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalPetVaccine
     */
    select?: PersonalPetVaccineSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PersonalPetVaccine
     */
    omit?: PersonalPetVaccineOmit<ExtArgs> | null
    /**
     * The data used to update PersonalPetVaccines.
     */
    data: XOR<PersonalPetVaccineUpdateManyMutationInput, PersonalPetVaccineUncheckedUpdateManyInput>
    /**
     * Filter which PersonalPetVaccines to update
     */
    where?: PersonalPetVaccineWhereInput
    /**
     * Limit how many PersonalPetVaccines to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonalPetVaccineIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PersonalPetVaccine upsert
   */
  export type PersonalPetVaccineUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalPetVaccine
     */
    select?: PersonalPetVaccineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonalPetVaccine
     */
    omit?: PersonalPetVaccineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonalPetVaccineInclude<ExtArgs> | null
    /**
     * The filter to search for the PersonalPetVaccine to update in case it exists.
     */
    where: PersonalPetVaccineWhereUniqueInput
    /**
     * In case the PersonalPetVaccine found by the `where` argument doesn't exist, create a new PersonalPetVaccine with this data.
     */
    create: XOR<PersonalPetVaccineCreateInput, PersonalPetVaccineUncheckedCreateInput>
    /**
     * In case the PersonalPetVaccine was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PersonalPetVaccineUpdateInput, PersonalPetVaccineUncheckedUpdateInput>
  }

  /**
   * PersonalPetVaccine delete
   */
  export type PersonalPetVaccineDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalPetVaccine
     */
    select?: PersonalPetVaccineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonalPetVaccine
     */
    omit?: PersonalPetVaccineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonalPetVaccineInclude<ExtArgs> | null
    /**
     * Filter which PersonalPetVaccine to delete.
     */
    where: PersonalPetVaccineWhereUniqueInput
  }

  /**
   * PersonalPetVaccine deleteMany
   */
  export type PersonalPetVaccineDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PersonalPetVaccines to delete
     */
    where?: PersonalPetVaccineWhereInput
    /**
     * Limit how many PersonalPetVaccines to delete.
     */
    limit?: number
  }

  /**
   * PersonalPetVaccine.metting
   */
  export type PersonalPetVaccine$mettingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Metting
     */
    select?: MettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Metting
     */
    omit?: MettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MettingInclude<ExtArgs> | null
    where?: MettingWhereInput
  }

  /**
   * PersonalPetVaccine without action
   */
  export type PersonalPetVaccineDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalPetVaccine
     */
    select?: PersonalPetVaccineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonalPetVaccine
     */
    omit?: PersonalPetVaccineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonalPetVaccineInclude<ExtArgs> | null
  }


  /**
   * Model Metting
   */

  export type AggregateMetting = {
    _count: MettingCountAggregateOutputType | null
    _avg: MettingAvgAggregateOutputType | null
    _sum: MettingSumAggregateOutputType | null
    _min: MettingMinAggregateOutputType | null
    _max: MettingMaxAggregateOutputType | null
  }

  export type MettingAvgAggregateOutputType = {
    duration: Decimal | null
    petWeight: number | null
    petSize: number | null
  }

  export type MettingSumAggregateOutputType = {
    duration: Decimal | null
    petWeight: number | null
    petSize: number | null
  }

  export type MettingMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    date: Date | null
    duration: Decimal | null
    description: string | null
    petWeight: number | null
    petSize: number | null
    clientPetId: string | null
    veterinarianId: string | null
  }

  export type MettingMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    date: Date | null
    duration: Decimal | null
    description: string | null
    petWeight: number | null
    petSize: number | null
    clientPetId: string | null
    veterinarianId: string | null
  }

  export type MettingCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    date: number
    duration: number
    description: number
    petWeight: number
    petSize: number
    clientPetId: number
    veterinarianId: number
    _all: number
  }


  export type MettingAvgAggregateInputType = {
    duration?: true
    petWeight?: true
    petSize?: true
  }

  export type MettingSumAggregateInputType = {
    duration?: true
    petWeight?: true
    petSize?: true
  }

  export type MettingMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    date?: true
    duration?: true
    description?: true
    petWeight?: true
    petSize?: true
    clientPetId?: true
    veterinarianId?: true
  }

  export type MettingMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    date?: true
    duration?: true
    description?: true
    petWeight?: true
    petSize?: true
    clientPetId?: true
    veterinarianId?: true
  }

  export type MettingCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    date?: true
    duration?: true
    description?: true
    petWeight?: true
    petSize?: true
    clientPetId?: true
    veterinarianId?: true
    _all?: true
  }

  export type MettingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Metting to aggregate.
     */
    where?: MettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Mettings to fetch.
     */
    orderBy?: MettingOrderByWithRelationInput | MettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Mettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Mettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Mettings
    **/
    _count?: true | MettingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MettingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MettingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MettingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MettingMaxAggregateInputType
  }

  export type GetMettingAggregateType<T extends MettingAggregateArgs> = {
        [P in keyof T & keyof AggregateMetting]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMetting[P]>
      : GetScalarType<T[P], AggregateMetting[P]>
  }




  export type MettingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MettingWhereInput
    orderBy?: MettingOrderByWithAggregationInput | MettingOrderByWithAggregationInput[]
    by: MettingScalarFieldEnum[] | MettingScalarFieldEnum
    having?: MettingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MettingCountAggregateInputType | true
    _avg?: MettingAvgAggregateInputType
    _sum?: MettingSumAggregateInputType
    _min?: MettingMinAggregateInputType
    _max?: MettingMaxAggregateInputType
  }

  export type MettingGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    date: Date
    duration: Decimal
    description: string | null
    petWeight: number | null
    petSize: number | null
    clientPetId: string
    veterinarianId: string
    _count: MettingCountAggregateOutputType | null
    _avg: MettingAvgAggregateOutputType | null
    _sum: MettingSumAggregateOutputType | null
    _min: MettingMinAggregateOutputType | null
    _max: MettingMaxAggregateOutputType | null
  }

  type GetMettingGroupByPayload<T extends MettingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MettingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MettingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MettingGroupByOutputType[P]>
            : GetScalarType<T[P], MettingGroupByOutputType[P]>
        }
      >
    >


  export type MettingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    date?: boolean
    duration?: boolean
    description?: boolean
    petWeight?: boolean
    petSize?: boolean
    clientPetId?: boolean
    veterinarianId?: boolean
    clientPet?: boolean | ClientPetDefaultArgs<ExtArgs>
    veterinarian?: boolean | VeterinarianProfileDefaultArgs<ExtArgs>
    personalPetVaccine?: boolean | Metting$personalPetVaccineArgs<ExtArgs>
    _count?: boolean | MettingCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["metting"]>

  export type MettingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    date?: boolean
    duration?: boolean
    description?: boolean
    petWeight?: boolean
    petSize?: boolean
    clientPetId?: boolean
    veterinarianId?: boolean
    clientPet?: boolean | ClientPetDefaultArgs<ExtArgs>
    veterinarian?: boolean | VeterinarianProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["metting"]>

  export type MettingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    date?: boolean
    duration?: boolean
    description?: boolean
    petWeight?: boolean
    petSize?: boolean
    clientPetId?: boolean
    veterinarianId?: boolean
    clientPet?: boolean | ClientPetDefaultArgs<ExtArgs>
    veterinarian?: boolean | VeterinarianProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["metting"]>

  export type MettingSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    date?: boolean
    duration?: boolean
    description?: boolean
    petWeight?: boolean
    petSize?: boolean
    clientPetId?: boolean
    veterinarianId?: boolean
  }

  export type MettingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "date" | "duration" | "description" | "petWeight" | "petSize" | "clientPetId" | "veterinarianId", ExtArgs["result"]["metting"]>
  export type MettingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clientPet?: boolean | ClientPetDefaultArgs<ExtArgs>
    veterinarian?: boolean | VeterinarianProfileDefaultArgs<ExtArgs>
    personalPetVaccine?: boolean | Metting$personalPetVaccineArgs<ExtArgs>
    _count?: boolean | MettingCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MettingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clientPet?: boolean | ClientPetDefaultArgs<ExtArgs>
    veterinarian?: boolean | VeterinarianProfileDefaultArgs<ExtArgs>
  }
  export type MettingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clientPet?: boolean | ClientPetDefaultArgs<ExtArgs>
    veterinarian?: boolean | VeterinarianProfileDefaultArgs<ExtArgs>
  }

  export type $MettingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Metting"
    objects: {
      clientPet: Prisma.$ClientPetPayload<ExtArgs>
      veterinarian: Prisma.$VeterinarianProfilePayload<ExtArgs>
      personalPetVaccine: Prisma.$PersonalPetVaccinePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      date: Date
      duration: Prisma.Decimal
      description: string | null
      petWeight: number | null
      petSize: number | null
      clientPetId: string
      veterinarianId: string
    }, ExtArgs["result"]["metting"]>
    composites: {}
  }

  type MettingGetPayload<S extends boolean | null | undefined | MettingDefaultArgs> = $Result.GetResult<Prisma.$MettingPayload, S>

  type MettingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MettingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MettingCountAggregateInputType | true
    }

  export interface MettingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Metting'], meta: { name: 'Metting' } }
    /**
     * Find zero or one Metting that matches the filter.
     * @param {MettingFindUniqueArgs} args - Arguments to find a Metting
     * @example
     * // Get one Metting
     * const metting = await prisma.metting.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MettingFindUniqueArgs>(args: SelectSubset<T, MettingFindUniqueArgs<ExtArgs>>): Prisma__MettingClient<$Result.GetResult<Prisma.$MettingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Metting that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MettingFindUniqueOrThrowArgs} args - Arguments to find a Metting
     * @example
     * // Get one Metting
     * const metting = await prisma.metting.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MettingFindUniqueOrThrowArgs>(args: SelectSubset<T, MettingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MettingClient<$Result.GetResult<Prisma.$MettingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Metting that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MettingFindFirstArgs} args - Arguments to find a Metting
     * @example
     * // Get one Metting
     * const metting = await prisma.metting.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MettingFindFirstArgs>(args?: SelectSubset<T, MettingFindFirstArgs<ExtArgs>>): Prisma__MettingClient<$Result.GetResult<Prisma.$MettingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Metting that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MettingFindFirstOrThrowArgs} args - Arguments to find a Metting
     * @example
     * // Get one Metting
     * const metting = await prisma.metting.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MettingFindFirstOrThrowArgs>(args?: SelectSubset<T, MettingFindFirstOrThrowArgs<ExtArgs>>): Prisma__MettingClient<$Result.GetResult<Prisma.$MettingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Mettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MettingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Mettings
     * const mettings = await prisma.metting.findMany()
     * 
     * // Get first 10 Mettings
     * const mettings = await prisma.metting.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mettingWithIdOnly = await prisma.metting.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MettingFindManyArgs>(args?: SelectSubset<T, MettingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MettingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Metting.
     * @param {MettingCreateArgs} args - Arguments to create a Metting.
     * @example
     * // Create one Metting
     * const Metting = await prisma.metting.create({
     *   data: {
     *     // ... data to create a Metting
     *   }
     * })
     * 
     */
    create<T extends MettingCreateArgs>(args: SelectSubset<T, MettingCreateArgs<ExtArgs>>): Prisma__MettingClient<$Result.GetResult<Prisma.$MettingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Mettings.
     * @param {MettingCreateManyArgs} args - Arguments to create many Mettings.
     * @example
     * // Create many Mettings
     * const metting = await prisma.metting.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MettingCreateManyArgs>(args?: SelectSubset<T, MettingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Mettings and returns the data saved in the database.
     * @param {MettingCreateManyAndReturnArgs} args - Arguments to create many Mettings.
     * @example
     * // Create many Mettings
     * const metting = await prisma.metting.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Mettings and only return the `id`
     * const mettingWithIdOnly = await prisma.metting.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MettingCreateManyAndReturnArgs>(args?: SelectSubset<T, MettingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MettingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Metting.
     * @param {MettingDeleteArgs} args - Arguments to delete one Metting.
     * @example
     * // Delete one Metting
     * const Metting = await prisma.metting.delete({
     *   where: {
     *     // ... filter to delete one Metting
     *   }
     * })
     * 
     */
    delete<T extends MettingDeleteArgs>(args: SelectSubset<T, MettingDeleteArgs<ExtArgs>>): Prisma__MettingClient<$Result.GetResult<Prisma.$MettingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Metting.
     * @param {MettingUpdateArgs} args - Arguments to update one Metting.
     * @example
     * // Update one Metting
     * const metting = await prisma.metting.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MettingUpdateArgs>(args: SelectSubset<T, MettingUpdateArgs<ExtArgs>>): Prisma__MettingClient<$Result.GetResult<Prisma.$MettingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Mettings.
     * @param {MettingDeleteManyArgs} args - Arguments to filter Mettings to delete.
     * @example
     * // Delete a few Mettings
     * const { count } = await prisma.metting.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MettingDeleteManyArgs>(args?: SelectSubset<T, MettingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Mettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MettingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Mettings
     * const metting = await prisma.metting.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MettingUpdateManyArgs>(args: SelectSubset<T, MettingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Mettings and returns the data updated in the database.
     * @param {MettingUpdateManyAndReturnArgs} args - Arguments to update many Mettings.
     * @example
     * // Update many Mettings
     * const metting = await prisma.metting.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Mettings and only return the `id`
     * const mettingWithIdOnly = await prisma.metting.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MettingUpdateManyAndReturnArgs>(args: SelectSubset<T, MettingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MettingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Metting.
     * @param {MettingUpsertArgs} args - Arguments to update or create a Metting.
     * @example
     * // Update or create a Metting
     * const metting = await prisma.metting.upsert({
     *   create: {
     *     // ... data to create a Metting
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Metting we want to update
     *   }
     * })
     */
    upsert<T extends MettingUpsertArgs>(args: SelectSubset<T, MettingUpsertArgs<ExtArgs>>): Prisma__MettingClient<$Result.GetResult<Prisma.$MettingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Mettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MettingCountArgs} args - Arguments to filter Mettings to count.
     * @example
     * // Count the number of Mettings
     * const count = await prisma.metting.count({
     *   where: {
     *     // ... the filter for the Mettings we want to count
     *   }
     * })
    **/
    count<T extends MettingCountArgs>(
      args?: Subset<T, MettingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MettingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Metting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MettingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MettingAggregateArgs>(args: Subset<T, MettingAggregateArgs>): Prisma.PrismaPromise<GetMettingAggregateType<T>>

    /**
     * Group by Metting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MettingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MettingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MettingGroupByArgs['orderBy'] }
        : { orderBy?: MettingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MettingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMettingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Metting model
   */
  readonly fields: MettingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Metting.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MettingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    clientPet<T extends ClientPetDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientPetDefaultArgs<ExtArgs>>): Prisma__ClientPetClient<$Result.GetResult<Prisma.$ClientPetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    veterinarian<T extends VeterinarianProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VeterinarianProfileDefaultArgs<ExtArgs>>): Prisma__VeterinarianProfileClient<$Result.GetResult<Prisma.$VeterinarianProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    personalPetVaccine<T extends Metting$personalPetVaccineArgs<ExtArgs> = {}>(args?: Subset<T, Metting$personalPetVaccineArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersonalPetVaccinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Metting model
   */
  interface MettingFieldRefs {
    readonly id: FieldRef<"Metting", 'String'>
    readonly createdAt: FieldRef<"Metting", 'DateTime'>
    readonly updatedAt: FieldRef<"Metting", 'DateTime'>
    readonly date: FieldRef<"Metting", 'DateTime'>
    readonly duration: FieldRef<"Metting", 'Decimal'>
    readonly description: FieldRef<"Metting", 'String'>
    readonly petWeight: FieldRef<"Metting", 'Int'>
    readonly petSize: FieldRef<"Metting", 'Int'>
    readonly clientPetId: FieldRef<"Metting", 'String'>
    readonly veterinarianId: FieldRef<"Metting", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Metting findUnique
   */
  export type MettingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Metting
     */
    select?: MettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Metting
     */
    omit?: MettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MettingInclude<ExtArgs> | null
    /**
     * Filter, which Metting to fetch.
     */
    where: MettingWhereUniqueInput
  }

  /**
   * Metting findUniqueOrThrow
   */
  export type MettingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Metting
     */
    select?: MettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Metting
     */
    omit?: MettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MettingInclude<ExtArgs> | null
    /**
     * Filter, which Metting to fetch.
     */
    where: MettingWhereUniqueInput
  }

  /**
   * Metting findFirst
   */
  export type MettingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Metting
     */
    select?: MettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Metting
     */
    omit?: MettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MettingInclude<ExtArgs> | null
    /**
     * Filter, which Metting to fetch.
     */
    where?: MettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Mettings to fetch.
     */
    orderBy?: MettingOrderByWithRelationInput | MettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Mettings.
     */
    cursor?: MettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Mettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Mettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Mettings.
     */
    distinct?: MettingScalarFieldEnum | MettingScalarFieldEnum[]
  }

  /**
   * Metting findFirstOrThrow
   */
  export type MettingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Metting
     */
    select?: MettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Metting
     */
    omit?: MettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MettingInclude<ExtArgs> | null
    /**
     * Filter, which Metting to fetch.
     */
    where?: MettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Mettings to fetch.
     */
    orderBy?: MettingOrderByWithRelationInput | MettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Mettings.
     */
    cursor?: MettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Mettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Mettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Mettings.
     */
    distinct?: MettingScalarFieldEnum | MettingScalarFieldEnum[]
  }

  /**
   * Metting findMany
   */
  export type MettingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Metting
     */
    select?: MettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Metting
     */
    omit?: MettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MettingInclude<ExtArgs> | null
    /**
     * Filter, which Mettings to fetch.
     */
    where?: MettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Mettings to fetch.
     */
    orderBy?: MettingOrderByWithRelationInput | MettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Mettings.
     */
    cursor?: MettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Mettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Mettings.
     */
    skip?: number
    distinct?: MettingScalarFieldEnum | MettingScalarFieldEnum[]
  }

  /**
   * Metting create
   */
  export type MettingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Metting
     */
    select?: MettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Metting
     */
    omit?: MettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MettingInclude<ExtArgs> | null
    /**
     * The data needed to create a Metting.
     */
    data: XOR<MettingCreateInput, MettingUncheckedCreateInput>
  }

  /**
   * Metting createMany
   */
  export type MettingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Mettings.
     */
    data: MettingCreateManyInput | MettingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Metting createManyAndReturn
   */
  export type MettingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Metting
     */
    select?: MettingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Metting
     */
    omit?: MettingOmit<ExtArgs> | null
    /**
     * The data used to create many Mettings.
     */
    data: MettingCreateManyInput | MettingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MettingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Metting update
   */
  export type MettingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Metting
     */
    select?: MettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Metting
     */
    omit?: MettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MettingInclude<ExtArgs> | null
    /**
     * The data needed to update a Metting.
     */
    data: XOR<MettingUpdateInput, MettingUncheckedUpdateInput>
    /**
     * Choose, which Metting to update.
     */
    where: MettingWhereUniqueInput
  }

  /**
   * Metting updateMany
   */
  export type MettingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Mettings.
     */
    data: XOR<MettingUpdateManyMutationInput, MettingUncheckedUpdateManyInput>
    /**
     * Filter which Mettings to update
     */
    where?: MettingWhereInput
    /**
     * Limit how many Mettings to update.
     */
    limit?: number
  }

  /**
   * Metting updateManyAndReturn
   */
  export type MettingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Metting
     */
    select?: MettingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Metting
     */
    omit?: MettingOmit<ExtArgs> | null
    /**
     * The data used to update Mettings.
     */
    data: XOR<MettingUpdateManyMutationInput, MettingUncheckedUpdateManyInput>
    /**
     * Filter which Mettings to update
     */
    where?: MettingWhereInput
    /**
     * Limit how many Mettings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MettingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Metting upsert
   */
  export type MettingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Metting
     */
    select?: MettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Metting
     */
    omit?: MettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MettingInclude<ExtArgs> | null
    /**
     * The filter to search for the Metting to update in case it exists.
     */
    where: MettingWhereUniqueInput
    /**
     * In case the Metting found by the `where` argument doesn't exist, create a new Metting with this data.
     */
    create: XOR<MettingCreateInput, MettingUncheckedCreateInput>
    /**
     * In case the Metting was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MettingUpdateInput, MettingUncheckedUpdateInput>
  }

  /**
   * Metting delete
   */
  export type MettingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Metting
     */
    select?: MettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Metting
     */
    omit?: MettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MettingInclude<ExtArgs> | null
    /**
     * Filter which Metting to delete.
     */
    where: MettingWhereUniqueInput
  }

  /**
   * Metting deleteMany
   */
  export type MettingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Mettings to delete
     */
    where?: MettingWhereInput
    /**
     * Limit how many Mettings to delete.
     */
    limit?: number
  }

  /**
   * Metting.personalPetVaccine
   */
  export type Metting$personalPetVaccineArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalPetVaccine
     */
    select?: PersonalPetVaccineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonalPetVaccine
     */
    omit?: PersonalPetVaccineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonalPetVaccineInclude<ExtArgs> | null
    where?: PersonalPetVaccineWhereInput
    orderBy?: PersonalPetVaccineOrderByWithRelationInput | PersonalPetVaccineOrderByWithRelationInput[]
    cursor?: PersonalPetVaccineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PersonalPetVaccineScalarFieldEnum | PersonalPetVaccineScalarFieldEnum[]
  }

  /**
   * Metting without action
   */
  export type MettingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Metting
     */
    select?: MettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Metting
     */
    omit?: MettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MettingInclude<ExtArgs> | null
  }


  /**
   * Model Product
   */

  export type AggregateProduct = {
    _count: ProductCountAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  export type ProductMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    name: string | null
    description: string | null
    qrCode: string | null
    websiteUrl: string | null
    picture: string | null
    brandId: string | null
  }

  export type ProductMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    name: string | null
    description: string | null
    qrCode: string | null
    websiteUrl: string | null
    picture: string | null
    brandId: string | null
  }

  export type ProductCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    name: number
    description: number
    qrCode: number
    websiteUrl: number
    picture: number
    brandId: number
    _all: number
  }


  export type ProductMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    description?: true
    qrCode?: true
    websiteUrl?: true
    picture?: true
    brandId?: true
  }

  export type ProductMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    description?: true
    qrCode?: true
    websiteUrl?: true
    picture?: true
    brandId?: true
  }

  export type ProductCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    description?: true
    qrCode?: true
    websiteUrl?: true
    picture?: true
    brandId?: true
    _all?: true
  }

  export type ProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Product to aggregate.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Products
    **/
    _count?: true | ProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductMaxAggregateInputType
  }

  export type GetProductAggregateType<T extends ProductAggregateArgs> = {
        [P in keyof T & keyof AggregateProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduct[P]>
      : GetScalarType<T[P], AggregateProduct[P]>
  }




  export type ProductGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithAggregationInput | ProductOrderByWithAggregationInput[]
    by: ProductScalarFieldEnum[] | ProductScalarFieldEnum
    having?: ProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCountAggregateInputType | true
    _min?: ProductMinAggregateInputType
    _max?: ProductMaxAggregateInputType
  }

  export type ProductGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    name: string
    description: string | null
    qrCode: string
    websiteUrl: string | null
    picture: string | null
    brandId: string
    _count: ProductCountAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  type GetProductGroupByPayload<T extends ProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductGroupByOutputType[P]>
            : GetScalarType<T[P], ProductGroupByOutputType[P]>
        }
      >
    >


  export type ProductSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    description?: boolean
    qrCode?: boolean
    websiteUrl?: boolean
    picture?: boolean
    brandId?: boolean
    brand?: boolean | BrandDefaultArgs<ExtArgs>
    clinicProducts?: boolean | Product$clinicProductsArgs<ExtArgs>
    Food?: boolean | Product$FoodArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    description?: boolean
    qrCode?: boolean
    websiteUrl?: boolean
    picture?: boolean
    brandId?: boolean
    brand?: boolean | BrandDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    description?: boolean
    qrCode?: boolean
    websiteUrl?: boolean
    picture?: boolean
    brandId?: boolean
    brand?: boolean | BrandDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    description?: boolean
    qrCode?: boolean
    websiteUrl?: boolean
    picture?: boolean
    brandId?: boolean
  }

  export type ProductOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "name" | "description" | "qrCode" | "websiteUrl" | "picture" | "brandId", ExtArgs["result"]["product"]>
  export type ProductInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    brand?: boolean | BrandDefaultArgs<ExtArgs>
    clinicProducts?: boolean | Product$clinicProductsArgs<ExtArgs>
    Food?: boolean | Product$FoodArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProductIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    brand?: boolean | BrandDefaultArgs<ExtArgs>
  }
  export type ProductIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    brand?: boolean | BrandDefaultArgs<ExtArgs>
  }

  export type $ProductPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Product"
    objects: {
      brand: Prisma.$BrandPayload<ExtArgs>
      clinicProducts: Prisma.$ClinicProductPayload<ExtArgs>[]
      Food: Prisma.$FoodPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      name: string
      description: string | null
      qrCode: string
      websiteUrl: string | null
      picture: string | null
      brandId: string
    }, ExtArgs["result"]["product"]>
    composites: {}
  }

  type ProductGetPayload<S extends boolean | null | undefined | ProductDefaultArgs> = $Result.GetResult<Prisma.$ProductPayload, S>

  type ProductCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductCountAggregateInputType | true
    }

  export interface ProductDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Product'], meta: { name: 'Product' } }
    /**
     * Find zero or one Product that matches the filter.
     * @param {ProductFindUniqueArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductFindUniqueArgs>(args: SelectSubset<T, ProductFindUniqueArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Product that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductFindUniqueOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Product that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductFindFirstArgs>(args?: SelectSubset<T, ProductFindFirstArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Product that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.product.findMany()
     * 
     * // Get first 10 Products
     * const products = await prisma.product.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productWithIdOnly = await prisma.product.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductFindManyArgs>(args?: SelectSubset<T, ProductFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Product.
     * @param {ProductCreateArgs} args - Arguments to create a Product.
     * @example
     * // Create one Product
     * const Product = await prisma.product.create({
     *   data: {
     *     // ... data to create a Product
     *   }
     * })
     * 
     */
    create<T extends ProductCreateArgs>(args: SelectSubset<T, ProductCreateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Products.
     * @param {ProductCreateManyArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductCreateManyArgs>(args?: SelectSubset<T, ProductCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Products and returns the data saved in the database.
     * @param {ProductCreateManyAndReturnArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Products and only return the `id`
     * const productWithIdOnly = await prisma.product.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Product.
     * @param {ProductDeleteArgs} args - Arguments to delete one Product.
     * @example
     * // Delete one Product
     * const Product = await prisma.product.delete({
     *   where: {
     *     // ... filter to delete one Product
     *   }
     * })
     * 
     */
    delete<T extends ProductDeleteArgs>(args: SelectSubset<T, ProductDeleteArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Product.
     * @param {ProductUpdateArgs} args - Arguments to update one Product.
     * @example
     * // Update one Product
     * const product = await prisma.product.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductUpdateArgs>(args: SelectSubset<T, ProductUpdateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Products.
     * @param {ProductDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.product.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductDeleteManyArgs>(args?: SelectSubset<T, ProductDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductUpdateManyArgs>(args: SelectSubset<T, ProductUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products and returns the data updated in the database.
     * @param {ProductUpdateManyAndReturnArgs} args - Arguments to update many Products.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Products and only return the `id`
     * const productWithIdOnly = await prisma.product.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Product.
     * @param {ProductUpsertArgs} args - Arguments to update or create a Product.
     * @example
     * // Update or create a Product
     * const product = await prisma.product.upsert({
     *   create: {
     *     // ... data to create a Product
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Product we want to update
     *   }
     * })
     */
    upsert<T extends ProductUpsertArgs>(args: SelectSubset<T, ProductUpsertArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.product.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
    **/
    count<T extends ProductCountArgs>(
      args?: Subset<T, ProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductAggregateArgs>(args: Subset<T, ProductAggregateArgs>): Prisma.PrismaPromise<GetProductAggregateType<T>>

    /**
     * Group by Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductGroupByArgs['orderBy'] }
        : { orderBy?: ProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Product model
   */
  readonly fields: ProductFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Product.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    brand<T extends BrandDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BrandDefaultArgs<ExtArgs>>): Prisma__BrandClient<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    clinicProducts<T extends Product$clinicProductsArgs<ExtArgs> = {}>(args?: Subset<T, Product$clinicProductsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClinicProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Food<T extends Product$FoodArgs<ExtArgs> = {}>(args?: Subset<T, Product$FoodArgs<ExtArgs>>): Prisma__FoodClient<$Result.GetResult<Prisma.$FoodPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Product model
   */
  interface ProductFieldRefs {
    readonly id: FieldRef<"Product", 'String'>
    readonly createdAt: FieldRef<"Product", 'DateTime'>
    readonly updatedAt: FieldRef<"Product", 'DateTime'>
    readonly name: FieldRef<"Product", 'String'>
    readonly description: FieldRef<"Product", 'String'>
    readonly qrCode: FieldRef<"Product", 'String'>
    readonly websiteUrl: FieldRef<"Product", 'String'>
    readonly picture: FieldRef<"Product", 'String'>
    readonly brandId: FieldRef<"Product", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Product findUnique
   */
  export type ProductFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findUniqueOrThrow
   */
  export type ProductFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findFirst
   */
  export type ProductFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findFirstOrThrow
   */
  export type ProductFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findMany
   */
  export type ProductFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Products to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product create
   */
  export type ProductCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to create a Product.
     */
    data: XOR<ProductCreateInput, ProductUncheckedCreateInput>
  }

  /**
   * Product createMany
   */
  export type ProductCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Product createManyAndReturn
   */
  export type ProductCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Product update
   */
  export type ProductUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to update a Product.
     */
    data: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
    /**
     * Choose, which Product to update.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product updateMany
   */
  export type ProductUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to update.
     */
    limit?: number
  }

  /**
   * Product updateManyAndReturn
   */
  export type ProductUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Product upsert
   */
  export type ProductUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The filter to search for the Product to update in case it exists.
     */
    where: ProductWhereUniqueInput
    /**
     * In case the Product found by the `where` argument doesn't exist, create a new Product with this data.
     */
    create: XOR<ProductCreateInput, ProductUncheckedCreateInput>
    /**
     * In case the Product was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
  }

  /**
   * Product delete
   */
  export type ProductDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter which Product to delete.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product deleteMany
   */
  export type ProductDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Products to delete
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to delete.
     */
    limit?: number
  }

  /**
   * Product.clinicProducts
   */
  export type Product$clinicProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicProduct
     */
    select?: ClinicProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicProduct
     */
    omit?: ClinicProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicProductInclude<ExtArgs> | null
    where?: ClinicProductWhereInput
    orderBy?: ClinicProductOrderByWithRelationInput | ClinicProductOrderByWithRelationInput[]
    cursor?: ClinicProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClinicProductScalarFieldEnum | ClinicProductScalarFieldEnum[]
  }

  /**
   * Product.Food
   */
  export type Product$FoodArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Food
     */
    select?: FoodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Food
     */
    omit?: FoodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodInclude<ExtArgs> | null
    where?: FoodWhereInput
  }

  /**
   * Product without action
   */
  export type ProductDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
  }


  /**
   * Model Food
   */

  export type AggregateFood = {
    _count: FoodCountAggregateOutputType | null
    _avg: FoodAvgAggregateOutputType | null
    _sum: FoodSumAggregateOutputType | null
    _min: FoodMinAggregateOutputType | null
    _max: FoodMaxAggregateOutputType | null
  }

  export type FoodAvgAggregateOutputType = {
    caloriesPer100: Decimal | null
    proteinPer100: Decimal | null
    fatPercentage: Decimal | null
    fiberPercentage: Decimal | null
    moisturePercentage: Decimal | null
  }

  export type FoodSumAggregateOutputType = {
    caloriesPer100: Decimal | null
    proteinPer100: Decimal | null
    fatPercentage: Decimal | null
    fiberPercentage: Decimal | null
    moisturePercentage: Decimal | null
  }

  export type FoodMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    caloriesPer100: Decimal | null
    proteinPer100: Decimal | null
    fatPercentage: Decimal | null
    fiberPercentage: Decimal | null
    moisturePercentage: Decimal | null
    type: $Enums.FoodType | null
    productId: string | null
  }

  export type FoodMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    caloriesPer100: Decimal | null
    proteinPer100: Decimal | null
    fatPercentage: Decimal | null
    fiberPercentage: Decimal | null
    moisturePercentage: Decimal | null
    type: $Enums.FoodType | null
    productId: string | null
  }

  export type FoodCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    caloriesPer100: number
    proteinPer100: number
    fatPercentage: number
    fiberPercentage: number
    moisturePercentage: number
    type: number
    productId: number
    _all: number
  }


  export type FoodAvgAggregateInputType = {
    caloriesPer100?: true
    proteinPer100?: true
    fatPercentage?: true
    fiberPercentage?: true
    moisturePercentage?: true
  }

  export type FoodSumAggregateInputType = {
    caloriesPer100?: true
    proteinPer100?: true
    fatPercentage?: true
    fiberPercentage?: true
    moisturePercentage?: true
  }

  export type FoodMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    caloriesPer100?: true
    proteinPer100?: true
    fatPercentage?: true
    fiberPercentage?: true
    moisturePercentage?: true
    type?: true
    productId?: true
  }

  export type FoodMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    caloriesPer100?: true
    proteinPer100?: true
    fatPercentage?: true
    fiberPercentage?: true
    moisturePercentage?: true
    type?: true
    productId?: true
  }

  export type FoodCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    caloriesPer100?: true
    proteinPer100?: true
    fatPercentage?: true
    fiberPercentage?: true
    moisturePercentage?: true
    type?: true
    productId?: true
    _all?: true
  }

  export type FoodAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Food to aggregate.
     */
    where?: FoodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Foods to fetch.
     */
    orderBy?: FoodOrderByWithRelationInput | FoodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FoodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Foods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Foods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Foods
    **/
    _count?: true | FoodCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FoodAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FoodSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FoodMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FoodMaxAggregateInputType
  }

  export type GetFoodAggregateType<T extends FoodAggregateArgs> = {
        [P in keyof T & keyof AggregateFood]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFood[P]>
      : GetScalarType<T[P], AggregateFood[P]>
  }




  export type FoodGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FoodWhereInput
    orderBy?: FoodOrderByWithAggregationInput | FoodOrderByWithAggregationInput[]
    by: FoodScalarFieldEnum[] | FoodScalarFieldEnum
    having?: FoodScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FoodCountAggregateInputType | true
    _avg?: FoodAvgAggregateInputType
    _sum?: FoodSumAggregateInputType
    _min?: FoodMinAggregateInputType
    _max?: FoodMaxAggregateInputType
  }

  export type FoodGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    caloriesPer100: Decimal | null
    proteinPer100: Decimal | null
    fatPercentage: Decimal | null
    fiberPercentage: Decimal | null
    moisturePercentage: Decimal | null
    type: $Enums.FoodType
    productId: string
    _count: FoodCountAggregateOutputType | null
    _avg: FoodAvgAggregateOutputType | null
    _sum: FoodSumAggregateOutputType | null
    _min: FoodMinAggregateOutputType | null
    _max: FoodMaxAggregateOutputType | null
  }

  type GetFoodGroupByPayload<T extends FoodGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FoodGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FoodGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FoodGroupByOutputType[P]>
            : GetScalarType<T[P], FoodGroupByOutputType[P]>
        }
      >
    >


  export type FoodSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    caloriesPer100?: boolean
    proteinPer100?: boolean
    fatPercentage?: boolean
    fiberPercentage?: boolean
    moisturePercentage?: boolean
    type?: boolean
    productId?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    foodPets?: boolean | Food$foodPetsArgs<ExtArgs>
    _count?: boolean | FoodCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["food"]>

  export type FoodSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    caloriesPer100?: boolean
    proteinPer100?: boolean
    fatPercentage?: boolean
    fiberPercentage?: boolean
    moisturePercentage?: boolean
    type?: boolean
    productId?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["food"]>

  export type FoodSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    caloriesPer100?: boolean
    proteinPer100?: boolean
    fatPercentage?: boolean
    fiberPercentage?: boolean
    moisturePercentage?: boolean
    type?: boolean
    productId?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["food"]>

  export type FoodSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    caloriesPer100?: boolean
    proteinPer100?: boolean
    fatPercentage?: boolean
    fiberPercentage?: boolean
    moisturePercentage?: boolean
    type?: boolean
    productId?: boolean
  }

  export type FoodOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "caloriesPer100" | "proteinPer100" | "fatPercentage" | "fiberPercentage" | "moisturePercentage" | "type" | "productId", ExtArgs["result"]["food"]>
  export type FoodInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    foodPets?: boolean | Food$foodPetsArgs<ExtArgs>
    _count?: boolean | FoodCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FoodIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type FoodIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $FoodPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Food"
    objects: {
      product: Prisma.$ProductPayload<ExtArgs>
      foodPets: Prisma.$FoodPetPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      caloriesPer100: Prisma.Decimal | null
      proteinPer100: Prisma.Decimal | null
      fatPercentage: Prisma.Decimal | null
      fiberPercentage: Prisma.Decimal | null
      moisturePercentage: Prisma.Decimal | null
      type: $Enums.FoodType
      productId: string
    }, ExtArgs["result"]["food"]>
    composites: {}
  }

  type FoodGetPayload<S extends boolean | null | undefined | FoodDefaultArgs> = $Result.GetResult<Prisma.$FoodPayload, S>

  type FoodCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FoodFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FoodCountAggregateInputType | true
    }

  export interface FoodDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Food'], meta: { name: 'Food' } }
    /**
     * Find zero or one Food that matches the filter.
     * @param {FoodFindUniqueArgs} args - Arguments to find a Food
     * @example
     * // Get one Food
     * const food = await prisma.food.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FoodFindUniqueArgs>(args: SelectSubset<T, FoodFindUniqueArgs<ExtArgs>>): Prisma__FoodClient<$Result.GetResult<Prisma.$FoodPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Food that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FoodFindUniqueOrThrowArgs} args - Arguments to find a Food
     * @example
     * // Get one Food
     * const food = await prisma.food.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FoodFindUniqueOrThrowArgs>(args: SelectSubset<T, FoodFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FoodClient<$Result.GetResult<Prisma.$FoodPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Food that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodFindFirstArgs} args - Arguments to find a Food
     * @example
     * // Get one Food
     * const food = await prisma.food.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FoodFindFirstArgs>(args?: SelectSubset<T, FoodFindFirstArgs<ExtArgs>>): Prisma__FoodClient<$Result.GetResult<Prisma.$FoodPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Food that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodFindFirstOrThrowArgs} args - Arguments to find a Food
     * @example
     * // Get one Food
     * const food = await prisma.food.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FoodFindFirstOrThrowArgs>(args?: SelectSubset<T, FoodFindFirstOrThrowArgs<ExtArgs>>): Prisma__FoodClient<$Result.GetResult<Prisma.$FoodPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Foods that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Foods
     * const foods = await prisma.food.findMany()
     * 
     * // Get first 10 Foods
     * const foods = await prisma.food.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const foodWithIdOnly = await prisma.food.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FoodFindManyArgs>(args?: SelectSubset<T, FoodFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FoodPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Food.
     * @param {FoodCreateArgs} args - Arguments to create a Food.
     * @example
     * // Create one Food
     * const Food = await prisma.food.create({
     *   data: {
     *     // ... data to create a Food
     *   }
     * })
     * 
     */
    create<T extends FoodCreateArgs>(args: SelectSubset<T, FoodCreateArgs<ExtArgs>>): Prisma__FoodClient<$Result.GetResult<Prisma.$FoodPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Foods.
     * @param {FoodCreateManyArgs} args - Arguments to create many Foods.
     * @example
     * // Create many Foods
     * const food = await prisma.food.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FoodCreateManyArgs>(args?: SelectSubset<T, FoodCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Foods and returns the data saved in the database.
     * @param {FoodCreateManyAndReturnArgs} args - Arguments to create many Foods.
     * @example
     * // Create many Foods
     * const food = await prisma.food.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Foods and only return the `id`
     * const foodWithIdOnly = await prisma.food.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FoodCreateManyAndReturnArgs>(args?: SelectSubset<T, FoodCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FoodPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Food.
     * @param {FoodDeleteArgs} args - Arguments to delete one Food.
     * @example
     * // Delete one Food
     * const Food = await prisma.food.delete({
     *   where: {
     *     // ... filter to delete one Food
     *   }
     * })
     * 
     */
    delete<T extends FoodDeleteArgs>(args: SelectSubset<T, FoodDeleteArgs<ExtArgs>>): Prisma__FoodClient<$Result.GetResult<Prisma.$FoodPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Food.
     * @param {FoodUpdateArgs} args - Arguments to update one Food.
     * @example
     * // Update one Food
     * const food = await prisma.food.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FoodUpdateArgs>(args: SelectSubset<T, FoodUpdateArgs<ExtArgs>>): Prisma__FoodClient<$Result.GetResult<Prisma.$FoodPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Foods.
     * @param {FoodDeleteManyArgs} args - Arguments to filter Foods to delete.
     * @example
     * // Delete a few Foods
     * const { count } = await prisma.food.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FoodDeleteManyArgs>(args?: SelectSubset<T, FoodDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Foods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Foods
     * const food = await prisma.food.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FoodUpdateManyArgs>(args: SelectSubset<T, FoodUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Foods and returns the data updated in the database.
     * @param {FoodUpdateManyAndReturnArgs} args - Arguments to update many Foods.
     * @example
     * // Update many Foods
     * const food = await prisma.food.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Foods and only return the `id`
     * const foodWithIdOnly = await prisma.food.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FoodUpdateManyAndReturnArgs>(args: SelectSubset<T, FoodUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FoodPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Food.
     * @param {FoodUpsertArgs} args - Arguments to update or create a Food.
     * @example
     * // Update or create a Food
     * const food = await prisma.food.upsert({
     *   create: {
     *     // ... data to create a Food
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Food we want to update
     *   }
     * })
     */
    upsert<T extends FoodUpsertArgs>(args: SelectSubset<T, FoodUpsertArgs<ExtArgs>>): Prisma__FoodClient<$Result.GetResult<Prisma.$FoodPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Foods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodCountArgs} args - Arguments to filter Foods to count.
     * @example
     * // Count the number of Foods
     * const count = await prisma.food.count({
     *   where: {
     *     // ... the filter for the Foods we want to count
     *   }
     * })
    **/
    count<T extends FoodCountArgs>(
      args?: Subset<T, FoodCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FoodCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Food.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FoodAggregateArgs>(args: Subset<T, FoodAggregateArgs>): Prisma.PrismaPromise<GetFoodAggregateType<T>>

    /**
     * Group by Food.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FoodGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FoodGroupByArgs['orderBy'] }
        : { orderBy?: FoodGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FoodGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFoodGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Food model
   */
  readonly fields: FoodFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Food.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FoodClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    foodPets<T extends Food$foodPetsArgs<ExtArgs> = {}>(args?: Subset<T, Food$foodPetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FoodPetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Food model
   */
  interface FoodFieldRefs {
    readonly id: FieldRef<"Food", 'String'>
    readonly createdAt: FieldRef<"Food", 'DateTime'>
    readonly updatedAt: FieldRef<"Food", 'DateTime'>
    readonly caloriesPer100: FieldRef<"Food", 'Decimal'>
    readonly proteinPer100: FieldRef<"Food", 'Decimal'>
    readonly fatPercentage: FieldRef<"Food", 'Decimal'>
    readonly fiberPercentage: FieldRef<"Food", 'Decimal'>
    readonly moisturePercentage: FieldRef<"Food", 'Decimal'>
    readonly type: FieldRef<"Food", 'FoodType'>
    readonly productId: FieldRef<"Food", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Food findUnique
   */
  export type FoodFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Food
     */
    select?: FoodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Food
     */
    omit?: FoodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodInclude<ExtArgs> | null
    /**
     * Filter, which Food to fetch.
     */
    where: FoodWhereUniqueInput
  }

  /**
   * Food findUniqueOrThrow
   */
  export type FoodFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Food
     */
    select?: FoodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Food
     */
    omit?: FoodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodInclude<ExtArgs> | null
    /**
     * Filter, which Food to fetch.
     */
    where: FoodWhereUniqueInput
  }

  /**
   * Food findFirst
   */
  export type FoodFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Food
     */
    select?: FoodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Food
     */
    omit?: FoodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodInclude<ExtArgs> | null
    /**
     * Filter, which Food to fetch.
     */
    where?: FoodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Foods to fetch.
     */
    orderBy?: FoodOrderByWithRelationInput | FoodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Foods.
     */
    cursor?: FoodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Foods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Foods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Foods.
     */
    distinct?: FoodScalarFieldEnum | FoodScalarFieldEnum[]
  }

  /**
   * Food findFirstOrThrow
   */
  export type FoodFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Food
     */
    select?: FoodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Food
     */
    omit?: FoodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodInclude<ExtArgs> | null
    /**
     * Filter, which Food to fetch.
     */
    where?: FoodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Foods to fetch.
     */
    orderBy?: FoodOrderByWithRelationInput | FoodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Foods.
     */
    cursor?: FoodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Foods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Foods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Foods.
     */
    distinct?: FoodScalarFieldEnum | FoodScalarFieldEnum[]
  }

  /**
   * Food findMany
   */
  export type FoodFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Food
     */
    select?: FoodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Food
     */
    omit?: FoodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodInclude<ExtArgs> | null
    /**
     * Filter, which Foods to fetch.
     */
    where?: FoodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Foods to fetch.
     */
    orderBy?: FoodOrderByWithRelationInput | FoodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Foods.
     */
    cursor?: FoodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Foods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Foods.
     */
    skip?: number
    distinct?: FoodScalarFieldEnum | FoodScalarFieldEnum[]
  }

  /**
   * Food create
   */
  export type FoodCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Food
     */
    select?: FoodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Food
     */
    omit?: FoodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodInclude<ExtArgs> | null
    /**
     * The data needed to create a Food.
     */
    data: XOR<FoodCreateInput, FoodUncheckedCreateInput>
  }

  /**
   * Food createMany
   */
  export type FoodCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Foods.
     */
    data: FoodCreateManyInput | FoodCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Food createManyAndReturn
   */
  export type FoodCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Food
     */
    select?: FoodSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Food
     */
    omit?: FoodOmit<ExtArgs> | null
    /**
     * The data used to create many Foods.
     */
    data: FoodCreateManyInput | FoodCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Food update
   */
  export type FoodUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Food
     */
    select?: FoodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Food
     */
    omit?: FoodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodInclude<ExtArgs> | null
    /**
     * The data needed to update a Food.
     */
    data: XOR<FoodUpdateInput, FoodUncheckedUpdateInput>
    /**
     * Choose, which Food to update.
     */
    where: FoodWhereUniqueInput
  }

  /**
   * Food updateMany
   */
  export type FoodUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Foods.
     */
    data: XOR<FoodUpdateManyMutationInput, FoodUncheckedUpdateManyInput>
    /**
     * Filter which Foods to update
     */
    where?: FoodWhereInput
    /**
     * Limit how many Foods to update.
     */
    limit?: number
  }

  /**
   * Food updateManyAndReturn
   */
  export type FoodUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Food
     */
    select?: FoodSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Food
     */
    omit?: FoodOmit<ExtArgs> | null
    /**
     * The data used to update Foods.
     */
    data: XOR<FoodUpdateManyMutationInput, FoodUncheckedUpdateManyInput>
    /**
     * Filter which Foods to update
     */
    where?: FoodWhereInput
    /**
     * Limit how many Foods to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Food upsert
   */
  export type FoodUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Food
     */
    select?: FoodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Food
     */
    omit?: FoodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodInclude<ExtArgs> | null
    /**
     * The filter to search for the Food to update in case it exists.
     */
    where: FoodWhereUniqueInput
    /**
     * In case the Food found by the `where` argument doesn't exist, create a new Food with this data.
     */
    create: XOR<FoodCreateInput, FoodUncheckedCreateInput>
    /**
     * In case the Food was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FoodUpdateInput, FoodUncheckedUpdateInput>
  }

  /**
   * Food delete
   */
  export type FoodDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Food
     */
    select?: FoodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Food
     */
    omit?: FoodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodInclude<ExtArgs> | null
    /**
     * Filter which Food to delete.
     */
    where: FoodWhereUniqueInput
  }

  /**
   * Food deleteMany
   */
  export type FoodDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Foods to delete
     */
    where?: FoodWhereInput
    /**
     * Limit how many Foods to delete.
     */
    limit?: number
  }

  /**
   * Food.foodPets
   */
  export type Food$foodPetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodPet
     */
    select?: FoodPetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodPet
     */
    omit?: FoodPetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodPetInclude<ExtArgs> | null
    where?: FoodPetWhereInput
    orderBy?: FoodPetOrderByWithRelationInput | FoodPetOrderByWithRelationInput[]
    cursor?: FoodPetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FoodPetScalarFieldEnum | FoodPetScalarFieldEnum[]
  }

  /**
   * Food without action
   */
  export type FoodDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Food
     */
    select?: FoodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Food
     */
    omit?: FoodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodInclude<ExtArgs> | null
  }


  /**
   * Model Brand
   */

  export type AggregateBrand = {
    _count: BrandCountAggregateOutputType | null
    _min: BrandMinAggregateOutputType | null
    _max: BrandMaxAggregateOutputType | null
  }

  export type BrandMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    name: string | null
    logo: string | null
  }

  export type BrandMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    name: string | null
    logo: string | null
  }

  export type BrandCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    name: number
    logo: number
    _all: number
  }


  export type BrandMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    logo?: true
  }

  export type BrandMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    logo?: true
  }

  export type BrandCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    logo?: true
    _all?: true
  }

  export type BrandAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Brand to aggregate.
     */
    where?: BrandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Brands to fetch.
     */
    orderBy?: BrandOrderByWithRelationInput | BrandOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BrandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Brands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Brands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Brands
    **/
    _count?: true | BrandCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BrandMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BrandMaxAggregateInputType
  }

  export type GetBrandAggregateType<T extends BrandAggregateArgs> = {
        [P in keyof T & keyof AggregateBrand]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBrand[P]>
      : GetScalarType<T[P], AggregateBrand[P]>
  }




  export type BrandGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BrandWhereInput
    orderBy?: BrandOrderByWithAggregationInput | BrandOrderByWithAggregationInput[]
    by: BrandScalarFieldEnum[] | BrandScalarFieldEnum
    having?: BrandScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BrandCountAggregateInputType | true
    _min?: BrandMinAggregateInputType
    _max?: BrandMaxAggregateInputType
  }

  export type BrandGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    name: string
    logo: string | null
    _count: BrandCountAggregateOutputType | null
    _min: BrandMinAggregateOutputType | null
    _max: BrandMaxAggregateOutputType | null
  }

  type GetBrandGroupByPayload<T extends BrandGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BrandGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BrandGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BrandGroupByOutputType[P]>
            : GetScalarType<T[P], BrandGroupByOutputType[P]>
        }
      >
    >


  export type BrandSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    logo?: boolean
    product?: boolean | Brand$productArgs<ExtArgs>
    _count?: boolean | BrandCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["brand"]>

  export type BrandSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    logo?: boolean
  }, ExtArgs["result"]["brand"]>

  export type BrandSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    logo?: boolean
  }, ExtArgs["result"]["brand"]>

  export type BrandSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    logo?: boolean
  }

  export type BrandOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "name" | "logo", ExtArgs["result"]["brand"]>
  export type BrandInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | Brand$productArgs<ExtArgs>
    _count?: boolean | BrandCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BrandIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type BrandIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $BrandPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Brand"
    objects: {
      product: Prisma.$ProductPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      name: string
      logo: string | null
    }, ExtArgs["result"]["brand"]>
    composites: {}
  }

  type BrandGetPayload<S extends boolean | null | undefined | BrandDefaultArgs> = $Result.GetResult<Prisma.$BrandPayload, S>

  type BrandCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BrandFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BrandCountAggregateInputType | true
    }

  export interface BrandDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Brand'], meta: { name: 'Brand' } }
    /**
     * Find zero or one Brand that matches the filter.
     * @param {BrandFindUniqueArgs} args - Arguments to find a Brand
     * @example
     * // Get one Brand
     * const brand = await prisma.brand.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BrandFindUniqueArgs>(args: SelectSubset<T, BrandFindUniqueArgs<ExtArgs>>): Prisma__BrandClient<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Brand that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BrandFindUniqueOrThrowArgs} args - Arguments to find a Brand
     * @example
     * // Get one Brand
     * const brand = await prisma.brand.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BrandFindUniqueOrThrowArgs>(args: SelectSubset<T, BrandFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BrandClient<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Brand that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrandFindFirstArgs} args - Arguments to find a Brand
     * @example
     * // Get one Brand
     * const brand = await prisma.brand.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BrandFindFirstArgs>(args?: SelectSubset<T, BrandFindFirstArgs<ExtArgs>>): Prisma__BrandClient<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Brand that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrandFindFirstOrThrowArgs} args - Arguments to find a Brand
     * @example
     * // Get one Brand
     * const brand = await prisma.brand.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BrandFindFirstOrThrowArgs>(args?: SelectSubset<T, BrandFindFirstOrThrowArgs<ExtArgs>>): Prisma__BrandClient<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Brands that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrandFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Brands
     * const brands = await prisma.brand.findMany()
     * 
     * // Get first 10 Brands
     * const brands = await prisma.brand.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const brandWithIdOnly = await prisma.brand.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BrandFindManyArgs>(args?: SelectSubset<T, BrandFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Brand.
     * @param {BrandCreateArgs} args - Arguments to create a Brand.
     * @example
     * // Create one Brand
     * const Brand = await prisma.brand.create({
     *   data: {
     *     // ... data to create a Brand
     *   }
     * })
     * 
     */
    create<T extends BrandCreateArgs>(args: SelectSubset<T, BrandCreateArgs<ExtArgs>>): Prisma__BrandClient<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Brands.
     * @param {BrandCreateManyArgs} args - Arguments to create many Brands.
     * @example
     * // Create many Brands
     * const brand = await prisma.brand.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BrandCreateManyArgs>(args?: SelectSubset<T, BrandCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Brands and returns the data saved in the database.
     * @param {BrandCreateManyAndReturnArgs} args - Arguments to create many Brands.
     * @example
     * // Create many Brands
     * const brand = await prisma.brand.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Brands and only return the `id`
     * const brandWithIdOnly = await prisma.brand.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BrandCreateManyAndReturnArgs>(args?: SelectSubset<T, BrandCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Brand.
     * @param {BrandDeleteArgs} args - Arguments to delete one Brand.
     * @example
     * // Delete one Brand
     * const Brand = await prisma.brand.delete({
     *   where: {
     *     // ... filter to delete one Brand
     *   }
     * })
     * 
     */
    delete<T extends BrandDeleteArgs>(args: SelectSubset<T, BrandDeleteArgs<ExtArgs>>): Prisma__BrandClient<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Brand.
     * @param {BrandUpdateArgs} args - Arguments to update one Brand.
     * @example
     * // Update one Brand
     * const brand = await prisma.brand.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BrandUpdateArgs>(args: SelectSubset<T, BrandUpdateArgs<ExtArgs>>): Prisma__BrandClient<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Brands.
     * @param {BrandDeleteManyArgs} args - Arguments to filter Brands to delete.
     * @example
     * // Delete a few Brands
     * const { count } = await prisma.brand.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BrandDeleteManyArgs>(args?: SelectSubset<T, BrandDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Brands.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrandUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Brands
     * const brand = await prisma.brand.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BrandUpdateManyArgs>(args: SelectSubset<T, BrandUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Brands and returns the data updated in the database.
     * @param {BrandUpdateManyAndReturnArgs} args - Arguments to update many Brands.
     * @example
     * // Update many Brands
     * const brand = await prisma.brand.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Brands and only return the `id`
     * const brandWithIdOnly = await prisma.brand.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BrandUpdateManyAndReturnArgs>(args: SelectSubset<T, BrandUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Brand.
     * @param {BrandUpsertArgs} args - Arguments to update or create a Brand.
     * @example
     * // Update or create a Brand
     * const brand = await prisma.brand.upsert({
     *   create: {
     *     // ... data to create a Brand
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Brand we want to update
     *   }
     * })
     */
    upsert<T extends BrandUpsertArgs>(args: SelectSubset<T, BrandUpsertArgs<ExtArgs>>): Prisma__BrandClient<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Brands.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrandCountArgs} args - Arguments to filter Brands to count.
     * @example
     * // Count the number of Brands
     * const count = await prisma.brand.count({
     *   where: {
     *     // ... the filter for the Brands we want to count
     *   }
     * })
    **/
    count<T extends BrandCountArgs>(
      args?: Subset<T, BrandCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BrandCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Brand.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrandAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BrandAggregateArgs>(args: Subset<T, BrandAggregateArgs>): Prisma.PrismaPromise<GetBrandAggregateType<T>>

    /**
     * Group by Brand.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrandGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BrandGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BrandGroupByArgs['orderBy'] }
        : { orderBy?: BrandGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BrandGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBrandGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Brand model
   */
  readonly fields: BrandFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Brand.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BrandClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product<T extends Brand$productArgs<ExtArgs> = {}>(args?: Subset<T, Brand$productArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Brand model
   */
  interface BrandFieldRefs {
    readonly id: FieldRef<"Brand", 'String'>
    readonly createdAt: FieldRef<"Brand", 'DateTime'>
    readonly updatedAt: FieldRef<"Brand", 'DateTime'>
    readonly name: FieldRef<"Brand", 'String'>
    readonly logo: FieldRef<"Brand", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Brand findUnique
   */
  export type BrandFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Brand
     */
    omit?: BrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrandInclude<ExtArgs> | null
    /**
     * Filter, which Brand to fetch.
     */
    where: BrandWhereUniqueInput
  }

  /**
   * Brand findUniqueOrThrow
   */
  export type BrandFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Brand
     */
    omit?: BrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrandInclude<ExtArgs> | null
    /**
     * Filter, which Brand to fetch.
     */
    where: BrandWhereUniqueInput
  }

  /**
   * Brand findFirst
   */
  export type BrandFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Brand
     */
    omit?: BrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrandInclude<ExtArgs> | null
    /**
     * Filter, which Brand to fetch.
     */
    where?: BrandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Brands to fetch.
     */
    orderBy?: BrandOrderByWithRelationInput | BrandOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Brands.
     */
    cursor?: BrandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Brands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Brands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Brands.
     */
    distinct?: BrandScalarFieldEnum | BrandScalarFieldEnum[]
  }

  /**
   * Brand findFirstOrThrow
   */
  export type BrandFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Brand
     */
    omit?: BrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrandInclude<ExtArgs> | null
    /**
     * Filter, which Brand to fetch.
     */
    where?: BrandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Brands to fetch.
     */
    orderBy?: BrandOrderByWithRelationInput | BrandOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Brands.
     */
    cursor?: BrandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Brands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Brands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Brands.
     */
    distinct?: BrandScalarFieldEnum | BrandScalarFieldEnum[]
  }

  /**
   * Brand findMany
   */
  export type BrandFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Brand
     */
    omit?: BrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrandInclude<ExtArgs> | null
    /**
     * Filter, which Brands to fetch.
     */
    where?: BrandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Brands to fetch.
     */
    orderBy?: BrandOrderByWithRelationInput | BrandOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Brands.
     */
    cursor?: BrandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Brands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Brands.
     */
    skip?: number
    distinct?: BrandScalarFieldEnum | BrandScalarFieldEnum[]
  }

  /**
   * Brand create
   */
  export type BrandCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Brand
     */
    omit?: BrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrandInclude<ExtArgs> | null
    /**
     * The data needed to create a Brand.
     */
    data: XOR<BrandCreateInput, BrandUncheckedCreateInput>
  }

  /**
   * Brand createMany
   */
  export type BrandCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Brands.
     */
    data: BrandCreateManyInput | BrandCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Brand createManyAndReturn
   */
  export type BrandCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Brand
     */
    omit?: BrandOmit<ExtArgs> | null
    /**
     * The data used to create many Brands.
     */
    data: BrandCreateManyInput | BrandCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Brand update
   */
  export type BrandUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Brand
     */
    omit?: BrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrandInclude<ExtArgs> | null
    /**
     * The data needed to update a Brand.
     */
    data: XOR<BrandUpdateInput, BrandUncheckedUpdateInput>
    /**
     * Choose, which Brand to update.
     */
    where: BrandWhereUniqueInput
  }

  /**
   * Brand updateMany
   */
  export type BrandUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Brands.
     */
    data: XOR<BrandUpdateManyMutationInput, BrandUncheckedUpdateManyInput>
    /**
     * Filter which Brands to update
     */
    where?: BrandWhereInput
    /**
     * Limit how many Brands to update.
     */
    limit?: number
  }

  /**
   * Brand updateManyAndReturn
   */
  export type BrandUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Brand
     */
    omit?: BrandOmit<ExtArgs> | null
    /**
     * The data used to update Brands.
     */
    data: XOR<BrandUpdateManyMutationInput, BrandUncheckedUpdateManyInput>
    /**
     * Filter which Brands to update
     */
    where?: BrandWhereInput
    /**
     * Limit how many Brands to update.
     */
    limit?: number
  }

  /**
   * Brand upsert
   */
  export type BrandUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Brand
     */
    omit?: BrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrandInclude<ExtArgs> | null
    /**
     * The filter to search for the Brand to update in case it exists.
     */
    where: BrandWhereUniqueInput
    /**
     * In case the Brand found by the `where` argument doesn't exist, create a new Brand with this data.
     */
    create: XOR<BrandCreateInput, BrandUncheckedCreateInput>
    /**
     * In case the Brand was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BrandUpdateInput, BrandUncheckedUpdateInput>
  }

  /**
   * Brand delete
   */
  export type BrandDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Brand
     */
    omit?: BrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrandInclude<ExtArgs> | null
    /**
     * Filter which Brand to delete.
     */
    where: BrandWhereUniqueInput
  }

  /**
   * Brand deleteMany
   */
  export type BrandDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Brands to delete
     */
    where?: BrandWhereInput
    /**
     * Limit how many Brands to delete.
     */
    limit?: number
  }

  /**
   * Brand.product
   */
  export type Brand$productArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Brand without action
   */
  export type BrandDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Brand
     */
    omit?: BrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrandInclude<ExtArgs> | null
  }


  /**
   * Model ClinicProduct
   */

  export type AggregateClinicProduct = {
    _count: ClinicProductCountAggregateOutputType | null
    _avg: ClinicProductAvgAggregateOutputType | null
    _sum: ClinicProductSumAggregateOutputType | null
    _min: ClinicProductMinAggregateOutputType | null
    _max: ClinicProductMaxAggregateOutputType | null
  }

  export type ClinicProductAvgAggregateOutputType = {
    stock: number | null
    minimumRequired: number | null
  }

  export type ClinicProductSumAggregateOutputType = {
    stock: number | null
    minimumRequired: number | null
  }

  export type ClinicProductMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    stock: number | null
    minimumRequired: number | null
    clinicId: string | null
    productId: string | null
  }

  export type ClinicProductMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    stock: number | null
    minimumRequired: number | null
    clinicId: string | null
    productId: string | null
  }

  export type ClinicProductCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    stock: number
    minimumRequired: number
    clinicId: number
    productId: number
    _all: number
  }


  export type ClinicProductAvgAggregateInputType = {
    stock?: true
    minimumRequired?: true
  }

  export type ClinicProductSumAggregateInputType = {
    stock?: true
    minimumRequired?: true
  }

  export type ClinicProductMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    stock?: true
    minimumRequired?: true
    clinicId?: true
    productId?: true
  }

  export type ClinicProductMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    stock?: true
    minimumRequired?: true
    clinicId?: true
    productId?: true
  }

  export type ClinicProductCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    stock?: true
    minimumRequired?: true
    clinicId?: true
    productId?: true
    _all?: true
  }

  export type ClinicProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClinicProduct to aggregate.
     */
    where?: ClinicProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClinicProducts to fetch.
     */
    orderBy?: ClinicProductOrderByWithRelationInput | ClinicProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClinicProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClinicProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClinicProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ClinicProducts
    **/
    _count?: true | ClinicProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClinicProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClinicProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClinicProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClinicProductMaxAggregateInputType
  }

  export type GetClinicProductAggregateType<T extends ClinicProductAggregateArgs> = {
        [P in keyof T & keyof AggregateClinicProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClinicProduct[P]>
      : GetScalarType<T[P], AggregateClinicProduct[P]>
  }




  export type ClinicProductGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClinicProductWhereInput
    orderBy?: ClinicProductOrderByWithAggregationInput | ClinicProductOrderByWithAggregationInput[]
    by: ClinicProductScalarFieldEnum[] | ClinicProductScalarFieldEnum
    having?: ClinicProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClinicProductCountAggregateInputType | true
    _avg?: ClinicProductAvgAggregateInputType
    _sum?: ClinicProductSumAggregateInputType
    _min?: ClinicProductMinAggregateInputType
    _max?: ClinicProductMaxAggregateInputType
  }

  export type ClinicProductGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    stock: number
    minimumRequired: number
    clinicId: string
    productId: string
    _count: ClinicProductCountAggregateOutputType | null
    _avg: ClinicProductAvgAggregateOutputType | null
    _sum: ClinicProductSumAggregateOutputType | null
    _min: ClinicProductMinAggregateOutputType | null
    _max: ClinicProductMaxAggregateOutputType | null
  }

  type GetClinicProductGroupByPayload<T extends ClinicProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClinicProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClinicProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClinicProductGroupByOutputType[P]>
            : GetScalarType<T[P], ClinicProductGroupByOutputType[P]>
        }
      >
    >


  export type ClinicProductSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    stock?: boolean
    minimumRequired?: boolean
    clinicId?: boolean
    productId?: boolean
    clinic?: boolean | ClientProfileDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clinicProduct"]>

  export type ClinicProductSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    stock?: boolean
    minimumRequired?: boolean
    clinicId?: boolean
    productId?: boolean
    clinic?: boolean | ClientProfileDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clinicProduct"]>

  export type ClinicProductSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    stock?: boolean
    minimumRequired?: boolean
    clinicId?: boolean
    productId?: boolean
    clinic?: boolean | ClientProfileDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clinicProduct"]>

  export type ClinicProductSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    stock?: boolean
    minimumRequired?: boolean
    clinicId?: boolean
    productId?: boolean
  }

  export type ClinicProductOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "stock" | "minimumRequired" | "clinicId" | "productId", ExtArgs["result"]["clinicProduct"]>
  export type ClinicProductInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clinic?: boolean | ClientProfileDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type ClinicProductIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clinic?: boolean | ClientProfileDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type ClinicProductIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clinic?: boolean | ClientProfileDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $ClinicProductPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ClinicProduct"
    objects: {
      clinic: Prisma.$ClientProfilePayload<ExtArgs>
      product: Prisma.$ProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      stock: number
      minimumRequired: number
      clinicId: string
      productId: string
    }, ExtArgs["result"]["clinicProduct"]>
    composites: {}
  }

  type ClinicProductGetPayload<S extends boolean | null | undefined | ClinicProductDefaultArgs> = $Result.GetResult<Prisma.$ClinicProductPayload, S>

  type ClinicProductCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClinicProductFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClinicProductCountAggregateInputType | true
    }

  export interface ClinicProductDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ClinicProduct'], meta: { name: 'ClinicProduct' } }
    /**
     * Find zero or one ClinicProduct that matches the filter.
     * @param {ClinicProductFindUniqueArgs} args - Arguments to find a ClinicProduct
     * @example
     * // Get one ClinicProduct
     * const clinicProduct = await prisma.clinicProduct.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClinicProductFindUniqueArgs>(args: SelectSubset<T, ClinicProductFindUniqueArgs<ExtArgs>>): Prisma__ClinicProductClient<$Result.GetResult<Prisma.$ClinicProductPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ClinicProduct that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClinicProductFindUniqueOrThrowArgs} args - Arguments to find a ClinicProduct
     * @example
     * // Get one ClinicProduct
     * const clinicProduct = await prisma.clinicProduct.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClinicProductFindUniqueOrThrowArgs>(args: SelectSubset<T, ClinicProductFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClinicProductClient<$Result.GetResult<Prisma.$ClinicProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClinicProduct that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicProductFindFirstArgs} args - Arguments to find a ClinicProduct
     * @example
     * // Get one ClinicProduct
     * const clinicProduct = await prisma.clinicProduct.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClinicProductFindFirstArgs>(args?: SelectSubset<T, ClinicProductFindFirstArgs<ExtArgs>>): Prisma__ClinicProductClient<$Result.GetResult<Prisma.$ClinicProductPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClinicProduct that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicProductFindFirstOrThrowArgs} args - Arguments to find a ClinicProduct
     * @example
     * // Get one ClinicProduct
     * const clinicProduct = await prisma.clinicProduct.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClinicProductFindFirstOrThrowArgs>(args?: SelectSubset<T, ClinicProductFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClinicProductClient<$Result.GetResult<Prisma.$ClinicProductPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ClinicProducts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicProductFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ClinicProducts
     * const clinicProducts = await prisma.clinicProduct.findMany()
     * 
     * // Get first 10 ClinicProducts
     * const clinicProducts = await prisma.clinicProduct.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clinicProductWithIdOnly = await prisma.clinicProduct.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClinicProductFindManyArgs>(args?: SelectSubset<T, ClinicProductFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClinicProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ClinicProduct.
     * @param {ClinicProductCreateArgs} args - Arguments to create a ClinicProduct.
     * @example
     * // Create one ClinicProduct
     * const ClinicProduct = await prisma.clinicProduct.create({
     *   data: {
     *     // ... data to create a ClinicProduct
     *   }
     * })
     * 
     */
    create<T extends ClinicProductCreateArgs>(args: SelectSubset<T, ClinicProductCreateArgs<ExtArgs>>): Prisma__ClinicProductClient<$Result.GetResult<Prisma.$ClinicProductPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ClinicProducts.
     * @param {ClinicProductCreateManyArgs} args - Arguments to create many ClinicProducts.
     * @example
     * // Create many ClinicProducts
     * const clinicProduct = await prisma.clinicProduct.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClinicProductCreateManyArgs>(args?: SelectSubset<T, ClinicProductCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ClinicProducts and returns the data saved in the database.
     * @param {ClinicProductCreateManyAndReturnArgs} args - Arguments to create many ClinicProducts.
     * @example
     * // Create many ClinicProducts
     * const clinicProduct = await prisma.clinicProduct.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ClinicProducts and only return the `id`
     * const clinicProductWithIdOnly = await prisma.clinicProduct.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClinicProductCreateManyAndReturnArgs>(args?: SelectSubset<T, ClinicProductCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClinicProductPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ClinicProduct.
     * @param {ClinicProductDeleteArgs} args - Arguments to delete one ClinicProduct.
     * @example
     * // Delete one ClinicProduct
     * const ClinicProduct = await prisma.clinicProduct.delete({
     *   where: {
     *     // ... filter to delete one ClinicProduct
     *   }
     * })
     * 
     */
    delete<T extends ClinicProductDeleteArgs>(args: SelectSubset<T, ClinicProductDeleteArgs<ExtArgs>>): Prisma__ClinicProductClient<$Result.GetResult<Prisma.$ClinicProductPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ClinicProduct.
     * @param {ClinicProductUpdateArgs} args - Arguments to update one ClinicProduct.
     * @example
     * // Update one ClinicProduct
     * const clinicProduct = await prisma.clinicProduct.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClinicProductUpdateArgs>(args: SelectSubset<T, ClinicProductUpdateArgs<ExtArgs>>): Prisma__ClinicProductClient<$Result.GetResult<Prisma.$ClinicProductPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ClinicProducts.
     * @param {ClinicProductDeleteManyArgs} args - Arguments to filter ClinicProducts to delete.
     * @example
     * // Delete a few ClinicProducts
     * const { count } = await prisma.clinicProduct.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClinicProductDeleteManyArgs>(args?: SelectSubset<T, ClinicProductDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClinicProducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ClinicProducts
     * const clinicProduct = await prisma.clinicProduct.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClinicProductUpdateManyArgs>(args: SelectSubset<T, ClinicProductUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClinicProducts and returns the data updated in the database.
     * @param {ClinicProductUpdateManyAndReturnArgs} args - Arguments to update many ClinicProducts.
     * @example
     * // Update many ClinicProducts
     * const clinicProduct = await prisma.clinicProduct.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ClinicProducts and only return the `id`
     * const clinicProductWithIdOnly = await prisma.clinicProduct.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ClinicProductUpdateManyAndReturnArgs>(args: SelectSubset<T, ClinicProductUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClinicProductPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ClinicProduct.
     * @param {ClinicProductUpsertArgs} args - Arguments to update or create a ClinicProduct.
     * @example
     * // Update or create a ClinicProduct
     * const clinicProduct = await prisma.clinicProduct.upsert({
     *   create: {
     *     // ... data to create a ClinicProduct
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ClinicProduct we want to update
     *   }
     * })
     */
    upsert<T extends ClinicProductUpsertArgs>(args: SelectSubset<T, ClinicProductUpsertArgs<ExtArgs>>): Prisma__ClinicProductClient<$Result.GetResult<Prisma.$ClinicProductPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ClinicProducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicProductCountArgs} args - Arguments to filter ClinicProducts to count.
     * @example
     * // Count the number of ClinicProducts
     * const count = await prisma.clinicProduct.count({
     *   where: {
     *     // ... the filter for the ClinicProducts we want to count
     *   }
     * })
    **/
    count<T extends ClinicProductCountArgs>(
      args?: Subset<T, ClinicProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClinicProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ClinicProduct.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClinicProductAggregateArgs>(args: Subset<T, ClinicProductAggregateArgs>): Prisma.PrismaPromise<GetClinicProductAggregateType<T>>

    /**
     * Group by ClinicProduct.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClinicProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClinicProductGroupByArgs['orderBy'] }
        : { orderBy?: ClinicProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClinicProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClinicProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ClinicProduct model
   */
  readonly fields: ClinicProductFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ClinicProduct.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClinicProductClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    clinic<T extends ClientProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientProfileDefaultArgs<ExtArgs>>): Prisma__ClientProfileClient<$Result.GetResult<Prisma.$ClientProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ClinicProduct model
   */
  interface ClinicProductFieldRefs {
    readonly id: FieldRef<"ClinicProduct", 'String'>
    readonly createdAt: FieldRef<"ClinicProduct", 'DateTime'>
    readonly updatedAt: FieldRef<"ClinicProduct", 'DateTime'>
    readonly stock: FieldRef<"ClinicProduct", 'Int'>
    readonly minimumRequired: FieldRef<"ClinicProduct", 'Int'>
    readonly clinicId: FieldRef<"ClinicProduct", 'String'>
    readonly productId: FieldRef<"ClinicProduct", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ClinicProduct findUnique
   */
  export type ClinicProductFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicProduct
     */
    select?: ClinicProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicProduct
     */
    omit?: ClinicProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicProductInclude<ExtArgs> | null
    /**
     * Filter, which ClinicProduct to fetch.
     */
    where: ClinicProductWhereUniqueInput
  }

  /**
   * ClinicProduct findUniqueOrThrow
   */
  export type ClinicProductFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicProduct
     */
    select?: ClinicProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicProduct
     */
    omit?: ClinicProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicProductInclude<ExtArgs> | null
    /**
     * Filter, which ClinicProduct to fetch.
     */
    where: ClinicProductWhereUniqueInput
  }

  /**
   * ClinicProduct findFirst
   */
  export type ClinicProductFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicProduct
     */
    select?: ClinicProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicProduct
     */
    omit?: ClinicProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicProductInclude<ExtArgs> | null
    /**
     * Filter, which ClinicProduct to fetch.
     */
    where?: ClinicProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClinicProducts to fetch.
     */
    orderBy?: ClinicProductOrderByWithRelationInput | ClinicProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClinicProducts.
     */
    cursor?: ClinicProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClinicProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClinicProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClinicProducts.
     */
    distinct?: ClinicProductScalarFieldEnum | ClinicProductScalarFieldEnum[]
  }

  /**
   * ClinicProduct findFirstOrThrow
   */
  export type ClinicProductFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicProduct
     */
    select?: ClinicProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicProduct
     */
    omit?: ClinicProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicProductInclude<ExtArgs> | null
    /**
     * Filter, which ClinicProduct to fetch.
     */
    where?: ClinicProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClinicProducts to fetch.
     */
    orderBy?: ClinicProductOrderByWithRelationInput | ClinicProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClinicProducts.
     */
    cursor?: ClinicProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClinicProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClinicProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClinicProducts.
     */
    distinct?: ClinicProductScalarFieldEnum | ClinicProductScalarFieldEnum[]
  }

  /**
   * ClinicProduct findMany
   */
  export type ClinicProductFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicProduct
     */
    select?: ClinicProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicProduct
     */
    omit?: ClinicProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicProductInclude<ExtArgs> | null
    /**
     * Filter, which ClinicProducts to fetch.
     */
    where?: ClinicProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClinicProducts to fetch.
     */
    orderBy?: ClinicProductOrderByWithRelationInput | ClinicProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ClinicProducts.
     */
    cursor?: ClinicProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClinicProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClinicProducts.
     */
    skip?: number
    distinct?: ClinicProductScalarFieldEnum | ClinicProductScalarFieldEnum[]
  }

  /**
   * ClinicProduct create
   */
  export type ClinicProductCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicProduct
     */
    select?: ClinicProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicProduct
     */
    omit?: ClinicProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicProductInclude<ExtArgs> | null
    /**
     * The data needed to create a ClinicProduct.
     */
    data: XOR<ClinicProductCreateInput, ClinicProductUncheckedCreateInput>
  }

  /**
   * ClinicProduct createMany
   */
  export type ClinicProductCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ClinicProducts.
     */
    data: ClinicProductCreateManyInput | ClinicProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ClinicProduct createManyAndReturn
   */
  export type ClinicProductCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicProduct
     */
    select?: ClinicProductSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicProduct
     */
    omit?: ClinicProductOmit<ExtArgs> | null
    /**
     * The data used to create many ClinicProducts.
     */
    data: ClinicProductCreateManyInput | ClinicProductCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicProductIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ClinicProduct update
   */
  export type ClinicProductUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicProduct
     */
    select?: ClinicProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicProduct
     */
    omit?: ClinicProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicProductInclude<ExtArgs> | null
    /**
     * The data needed to update a ClinicProduct.
     */
    data: XOR<ClinicProductUpdateInput, ClinicProductUncheckedUpdateInput>
    /**
     * Choose, which ClinicProduct to update.
     */
    where: ClinicProductWhereUniqueInput
  }

  /**
   * ClinicProduct updateMany
   */
  export type ClinicProductUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ClinicProducts.
     */
    data: XOR<ClinicProductUpdateManyMutationInput, ClinicProductUncheckedUpdateManyInput>
    /**
     * Filter which ClinicProducts to update
     */
    where?: ClinicProductWhereInput
    /**
     * Limit how many ClinicProducts to update.
     */
    limit?: number
  }

  /**
   * ClinicProduct updateManyAndReturn
   */
  export type ClinicProductUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicProduct
     */
    select?: ClinicProductSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicProduct
     */
    omit?: ClinicProductOmit<ExtArgs> | null
    /**
     * The data used to update ClinicProducts.
     */
    data: XOR<ClinicProductUpdateManyMutationInput, ClinicProductUncheckedUpdateManyInput>
    /**
     * Filter which ClinicProducts to update
     */
    where?: ClinicProductWhereInput
    /**
     * Limit how many ClinicProducts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicProductIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ClinicProduct upsert
   */
  export type ClinicProductUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicProduct
     */
    select?: ClinicProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicProduct
     */
    omit?: ClinicProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicProductInclude<ExtArgs> | null
    /**
     * The filter to search for the ClinicProduct to update in case it exists.
     */
    where: ClinicProductWhereUniqueInput
    /**
     * In case the ClinicProduct found by the `where` argument doesn't exist, create a new ClinicProduct with this data.
     */
    create: XOR<ClinicProductCreateInput, ClinicProductUncheckedCreateInput>
    /**
     * In case the ClinicProduct was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClinicProductUpdateInput, ClinicProductUncheckedUpdateInput>
  }

  /**
   * ClinicProduct delete
   */
  export type ClinicProductDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicProduct
     */
    select?: ClinicProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicProduct
     */
    omit?: ClinicProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicProductInclude<ExtArgs> | null
    /**
     * Filter which ClinicProduct to delete.
     */
    where: ClinicProductWhereUniqueInput
  }

  /**
   * ClinicProduct deleteMany
   */
  export type ClinicProductDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClinicProducts to delete
     */
    where?: ClinicProductWhereInput
    /**
     * Limit how many ClinicProducts to delete.
     */
    limit?: number
  }

  /**
   * ClinicProduct without action
   */
  export type ClinicProductDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicProduct
     */
    select?: ClinicProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicProduct
     */
    omit?: ClinicProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicProductInclude<ExtArgs> | null
  }


  /**
   * Model FoodPet
   */

  export type AggregateFoodPet = {
    _count: FoodPetCountAggregateOutputType | null
    _avg: FoodPetAvgAggregateOutputType | null
    _sum: FoodPetSumAggregateOutputType | null
    _min: FoodPetMinAggregateOutputType | null
    _max: FoodPetMaxAggregateOutputType | null
  }

  export type FoodPetAvgAggregateOutputType = {
    quantity: Decimal | null
  }

  export type FoodPetSumAggregateOutputType = {
    quantity: Decimal | null
  }

  export type FoodPetMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    type: $Enums.FoodPetDay | null
    dateStart: Date | null
    dateEnd: Date | null
    quantity: Decimal | null
    hours: Date | null
    foodId: string | null
    clientPetId: string | null
  }

  export type FoodPetMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    type: $Enums.FoodPetDay | null
    dateStart: Date | null
    dateEnd: Date | null
    quantity: Decimal | null
    hours: Date | null
    foodId: string | null
    clientPetId: string | null
  }

  export type FoodPetCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    type: number
    dateStart: number
    dateEnd: number
    quantity: number
    hours: number
    foodId: number
    clientPetId: number
    _all: number
  }


  export type FoodPetAvgAggregateInputType = {
    quantity?: true
  }

  export type FoodPetSumAggregateInputType = {
    quantity?: true
  }

  export type FoodPetMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    type?: true
    dateStart?: true
    dateEnd?: true
    quantity?: true
    hours?: true
    foodId?: true
    clientPetId?: true
  }

  export type FoodPetMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    type?: true
    dateStart?: true
    dateEnd?: true
    quantity?: true
    hours?: true
    foodId?: true
    clientPetId?: true
  }

  export type FoodPetCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    type?: true
    dateStart?: true
    dateEnd?: true
    quantity?: true
    hours?: true
    foodId?: true
    clientPetId?: true
    _all?: true
  }

  export type FoodPetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FoodPet to aggregate.
     */
    where?: FoodPetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FoodPets to fetch.
     */
    orderBy?: FoodPetOrderByWithRelationInput | FoodPetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FoodPetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FoodPets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FoodPets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FoodPets
    **/
    _count?: true | FoodPetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FoodPetAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FoodPetSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FoodPetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FoodPetMaxAggregateInputType
  }

  export type GetFoodPetAggregateType<T extends FoodPetAggregateArgs> = {
        [P in keyof T & keyof AggregateFoodPet]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFoodPet[P]>
      : GetScalarType<T[P], AggregateFoodPet[P]>
  }




  export type FoodPetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FoodPetWhereInput
    orderBy?: FoodPetOrderByWithAggregationInput | FoodPetOrderByWithAggregationInput[]
    by: FoodPetScalarFieldEnum[] | FoodPetScalarFieldEnum
    having?: FoodPetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FoodPetCountAggregateInputType | true
    _avg?: FoodPetAvgAggregateInputType
    _sum?: FoodPetSumAggregateInputType
    _min?: FoodPetMinAggregateInputType
    _max?: FoodPetMaxAggregateInputType
  }

  export type FoodPetGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    type: $Enums.FoodPetDay
    dateStart: Date
    dateEnd: Date | null
    quantity: Decimal
    hours: Date
    foodId: string
    clientPetId: string
    _count: FoodPetCountAggregateOutputType | null
    _avg: FoodPetAvgAggregateOutputType | null
    _sum: FoodPetSumAggregateOutputType | null
    _min: FoodPetMinAggregateOutputType | null
    _max: FoodPetMaxAggregateOutputType | null
  }

  type GetFoodPetGroupByPayload<T extends FoodPetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FoodPetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FoodPetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FoodPetGroupByOutputType[P]>
            : GetScalarType<T[P], FoodPetGroupByOutputType[P]>
        }
      >
    >


  export type FoodPetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    type?: boolean
    dateStart?: boolean
    dateEnd?: boolean
    quantity?: boolean
    hours?: boolean
    foodId?: boolean
    clientPetId?: boolean
    food?: boolean | FoodDefaultArgs<ExtArgs>
    clientPet?: boolean | ClientPetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["foodPet"]>

  export type FoodPetSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    type?: boolean
    dateStart?: boolean
    dateEnd?: boolean
    quantity?: boolean
    hours?: boolean
    foodId?: boolean
    clientPetId?: boolean
    food?: boolean | FoodDefaultArgs<ExtArgs>
    clientPet?: boolean | ClientPetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["foodPet"]>

  export type FoodPetSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    type?: boolean
    dateStart?: boolean
    dateEnd?: boolean
    quantity?: boolean
    hours?: boolean
    foodId?: boolean
    clientPetId?: boolean
    food?: boolean | FoodDefaultArgs<ExtArgs>
    clientPet?: boolean | ClientPetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["foodPet"]>

  export type FoodPetSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    type?: boolean
    dateStart?: boolean
    dateEnd?: boolean
    quantity?: boolean
    hours?: boolean
    foodId?: boolean
    clientPetId?: boolean
  }

  export type FoodPetOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "type" | "dateStart" | "dateEnd" | "quantity" | "hours" | "foodId" | "clientPetId", ExtArgs["result"]["foodPet"]>
  export type FoodPetInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    food?: boolean | FoodDefaultArgs<ExtArgs>
    clientPet?: boolean | ClientPetDefaultArgs<ExtArgs>
  }
  export type FoodPetIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    food?: boolean | FoodDefaultArgs<ExtArgs>
    clientPet?: boolean | ClientPetDefaultArgs<ExtArgs>
  }
  export type FoodPetIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    food?: boolean | FoodDefaultArgs<ExtArgs>
    clientPet?: boolean | ClientPetDefaultArgs<ExtArgs>
  }

  export type $FoodPetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FoodPet"
    objects: {
      food: Prisma.$FoodPayload<ExtArgs>
      clientPet: Prisma.$ClientPetPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      type: $Enums.FoodPetDay
      dateStart: Date
      dateEnd: Date | null
      quantity: Prisma.Decimal
      hours: Date
      foodId: string
      clientPetId: string
    }, ExtArgs["result"]["foodPet"]>
    composites: {}
  }

  type FoodPetGetPayload<S extends boolean | null | undefined | FoodPetDefaultArgs> = $Result.GetResult<Prisma.$FoodPetPayload, S>

  type FoodPetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FoodPetFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FoodPetCountAggregateInputType | true
    }

  export interface FoodPetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FoodPet'], meta: { name: 'FoodPet' } }
    /**
     * Find zero or one FoodPet that matches the filter.
     * @param {FoodPetFindUniqueArgs} args - Arguments to find a FoodPet
     * @example
     * // Get one FoodPet
     * const foodPet = await prisma.foodPet.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FoodPetFindUniqueArgs>(args: SelectSubset<T, FoodPetFindUniqueArgs<ExtArgs>>): Prisma__FoodPetClient<$Result.GetResult<Prisma.$FoodPetPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FoodPet that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FoodPetFindUniqueOrThrowArgs} args - Arguments to find a FoodPet
     * @example
     * // Get one FoodPet
     * const foodPet = await prisma.foodPet.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FoodPetFindUniqueOrThrowArgs>(args: SelectSubset<T, FoodPetFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FoodPetClient<$Result.GetResult<Prisma.$FoodPetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FoodPet that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodPetFindFirstArgs} args - Arguments to find a FoodPet
     * @example
     * // Get one FoodPet
     * const foodPet = await prisma.foodPet.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FoodPetFindFirstArgs>(args?: SelectSubset<T, FoodPetFindFirstArgs<ExtArgs>>): Prisma__FoodPetClient<$Result.GetResult<Prisma.$FoodPetPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FoodPet that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodPetFindFirstOrThrowArgs} args - Arguments to find a FoodPet
     * @example
     * // Get one FoodPet
     * const foodPet = await prisma.foodPet.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FoodPetFindFirstOrThrowArgs>(args?: SelectSubset<T, FoodPetFindFirstOrThrowArgs<ExtArgs>>): Prisma__FoodPetClient<$Result.GetResult<Prisma.$FoodPetPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FoodPets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodPetFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FoodPets
     * const foodPets = await prisma.foodPet.findMany()
     * 
     * // Get first 10 FoodPets
     * const foodPets = await prisma.foodPet.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const foodPetWithIdOnly = await prisma.foodPet.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FoodPetFindManyArgs>(args?: SelectSubset<T, FoodPetFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FoodPetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FoodPet.
     * @param {FoodPetCreateArgs} args - Arguments to create a FoodPet.
     * @example
     * // Create one FoodPet
     * const FoodPet = await prisma.foodPet.create({
     *   data: {
     *     // ... data to create a FoodPet
     *   }
     * })
     * 
     */
    create<T extends FoodPetCreateArgs>(args: SelectSubset<T, FoodPetCreateArgs<ExtArgs>>): Prisma__FoodPetClient<$Result.GetResult<Prisma.$FoodPetPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FoodPets.
     * @param {FoodPetCreateManyArgs} args - Arguments to create many FoodPets.
     * @example
     * // Create many FoodPets
     * const foodPet = await prisma.foodPet.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FoodPetCreateManyArgs>(args?: SelectSubset<T, FoodPetCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FoodPets and returns the data saved in the database.
     * @param {FoodPetCreateManyAndReturnArgs} args - Arguments to create many FoodPets.
     * @example
     * // Create many FoodPets
     * const foodPet = await prisma.foodPet.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FoodPets and only return the `id`
     * const foodPetWithIdOnly = await prisma.foodPet.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FoodPetCreateManyAndReturnArgs>(args?: SelectSubset<T, FoodPetCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FoodPetPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FoodPet.
     * @param {FoodPetDeleteArgs} args - Arguments to delete one FoodPet.
     * @example
     * // Delete one FoodPet
     * const FoodPet = await prisma.foodPet.delete({
     *   where: {
     *     // ... filter to delete one FoodPet
     *   }
     * })
     * 
     */
    delete<T extends FoodPetDeleteArgs>(args: SelectSubset<T, FoodPetDeleteArgs<ExtArgs>>): Prisma__FoodPetClient<$Result.GetResult<Prisma.$FoodPetPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FoodPet.
     * @param {FoodPetUpdateArgs} args - Arguments to update one FoodPet.
     * @example
     * // Update one FoodPet
     * const foodPet = await prisma.foodPet.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FoodPetUpdateArgs>(args: SelectSubset<T, FoodPetUpdateArgs<ExtArgs>>): Prisma__FoodPetClient<$Result.GetResult<Prisma.$FoodPetPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FoodPets.
     * @param {FoodPetDeleteManyArgs} args - Arguments to filter FoodPets to delete.
     * @example
     * // Delete a few FoodPets
     * const { count } = await prisma.foodPet.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FoodPetDeleteManyArgs>(args?: SelectSubset<T, FoodPetDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FoodPets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodPetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FoodPets
     * const foodPet = await prisma.foodPet.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FoodPetUpdateManyArgs>(args: SelectSubset<T, FoodPetUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FoodPets and returns the data updated in the database.
     * @param {FoodPetUpdateManyAndReturnArgs} args - Arguments to update many FoodPets.
     * @example
     * // Update many FoodPets
     * const foodPet = await prisma.foodPet.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FoodPets and only return the `id`
     * const foodPetWithIdOnly = await prisma.foodPet.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FoodPetUpdateManyAndReturnArgs>(args: SelectSubset<T, FoodPetUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FoodPetPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FoodPet.
     * @param {FoodPetUpsertArgs} args - Arguments to update or create a FoodPet.
     * @example
     * // Update or create a FoodPet
     * const foodPet = await prisma.foodPet.upsert({
     *   create: {
     *     // ... data to create a FoodPet
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FoodPet we want to update
     *   }
     * })
     */
    upsert<T extends FoodPetUpsertArgs>(args: SelectSubset<T, FoodPetUpsertArgs<ExtArgs>>): Prisma__FoodPetClient<$Result.GetResult<Prisma.$FoodPetPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FoodPets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodPetCountArgs} args - Arguments to filter FoodPets to count.
     * @example
     * // Count the number of FoodPets
     * const count = await prisma.foodPet.count({
     *   where: {
     *     // ... the filter for the FoodPets we want to count
     *   }
     * })
    **/
    count<T extends FoodPetCountArgs>(
      args?: Subset<T, FoodPetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FoodPetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FoodPet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodPetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FoodPetAggregateArgs>(args: Subset<T, FoodPetAggregateArgs>): Prisma.PrismaPromise<GetFoodPetAggregateType<T>>

    /**
     * Group by FoodPet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodPetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FoodPetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FoodPetGroupByArgs['orderBy'] }
        : { orderBy?: FoodPetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FoodPetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFoodPetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FoodPet model
   */
  readonly fields: FoodPetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FoodPet.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FoodPetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    food<T extends FoodDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FoodDefaultArgs<ExtArgs>>): Prisma__FoodClient<$Result.GetResult<Prisma.$FoodPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    clientPet<T extends ClientPetDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientPetDefaultArgs<ExtArgs>>): Prisma__ClientPetClient<$Result.GetResult<Prisma.$ClientPetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FoodPet model
   */
  interface FoodPetFieldRefs {
    readonly id: FieldRef<"FoodPet", 'String'>
    readonly createdAt: FieldRef<"FoodPet", 'DateTime'>
    readonly updatedAt: FieldRef<"FoodPet", 'DateTime'>
    readonly type: FieldRef<"FoodPet", 'FoodPetDay'>
    readonly dateStart: FieldRef<"FoodPet", 'DateTime'>
    readonly dateEnd: FieldRef<"FoodPet", 'DateTime'>
    readonly quantity: FieldRef<"FoodPet", 'Decimal'>
    readonly hours: FieldRef<"FoodPet", 'DateTime'>
    readonly foodId: FieldRef<"FoodPet", 'String'>
    readonly clientPetId: FieldRef<"FoodPet", 'String'>
  }
    

  // Custom InputTypes
  /**
   * FoodPet findUnique
   */
  export type FoodPetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodPet
     */
    select?: FoodPetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodPet
     */
    omit?: FoodPetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodPetInclude<ExtArgs> | null
    /**
     * Filter, which FoodPet to fetch.
     */
    where: FoodPetWhereUniqueInput
  }

  /**
   * FoodPet findUniqueOrThrow
   */
  export type FoodPetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodPet
     */
    select?: FoodPetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodPet
     */
    omit?: FoodPetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodPetInclude<ExtArgs> | null
    /**
     * Filter, which FoodPet to fetch.
     */
    where: FoodPetWhereUniqueInput
  }

  /**
   * FoodPet findFirst
   */
  export type FoodPetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodPet
     */
    select?: FoodPetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodPet
     */
    omit?: FoodPetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodPetInclude<ExtArgs> | null
    /**
     * Filter, which FoodPet to fetch.
     */
    where?: FoodPetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FoodPets to fetch.
     */
    orderBy?: FoodPetOrderByWithRelationInput | FoodPetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FoodPets.
     */
    cursor?: FoodPetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FoodPets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FoodPets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FoodPets.
     */
    distinct?: FoodPetScalarFieldEnum | FoodPetScalarFieldEnum[]
  }

  /**
   * FoodPet findFirstOrThrow
   */
  export type FoodPetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodPet
     */
    select?: FoodPetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodPet
     */
    omit?: FoodPetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodPetInclude<ExtArgs> | null
    /**
     * Filter, which FoodPet to fetch.
     */
    where?: FoodPetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FoodPets to fetch.
     */
    orderBy?: FoodPetOrderByWithRelationInput | FoodPetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FoodPets.
     */
    cursor?: FoodPetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FoodPets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FoodPets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FoodPets.
     */
    distinct?: FoodPetScalarFieldEnum | FoodPetScalarFieldEnum[]
  }

  /**
   * FoodPet findMany
   */
  export type FoodPetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodPet
     */
    select?: FoodPetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodPet
     */
    omit?: FoodPetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodPetInclude<ExtArgs> | null
    /**
     * Filter, which FoodPets to fetch.
     */
    where?: FoodPetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FoodPets to fetch.
     */
    orderBy?: FoodPetOrderByWithRelationInput | FoodPetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FoodPets.
     */
    cursor?: FoodPetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FoodPets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FoodPets.
     */
    skip?: number
    distinct?: FoodPetScalarFieldEnum | FoodPetScalarFieldEnum[]
  }

  /**
   * FoodPet create
   */
  export type FoodPetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodPet
     */
    select?: FoodPetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodPet
     */
    omit?: FoodPetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodPetInclude<ExtArgs> | null
    /**
     * The data needed to create a FoodPet.
     */
    data: XOR<FoodPetCreateInput, FoodPetUncheckedCreateInput>
  }

  /**
   * FoodPet createMany
   */
  export type FoodPetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FoodPets.
     */
    data: FoodPetCreateManyInput | FoodPetCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FoodPet createManyAndReturn
   */
  export type FoodPetCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodPet
     */
    select?: FoodPetSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FoodPet
     */
    omit?: FoodPetOmit<ExtArgs> | null
    /**
     * The data used to create many FoodPets.
     */
    data: FoodPetCreateManyInput | FoodPetCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodPetIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FoodPet update
   */
  export type FoodPetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodPet
     */
    select?: FoodPetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodPet
     */
    omit?: FoodPetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodPetInclude<ExtArgs> | null
    /**
     * The data needed to update a FoodPet.
     */
    data: XOR<FoodPetUpdateInput, FoodPetUncheckedUpdateInput>
    /**
     * Choose, which FoodPet to update.
     */
    where: FoodPetWhereUniqueInput
  }

  /**
   * FoodPet updateMany
   */
  export type FoodPetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FoodPets.
     */
    data: XOR<FoodPetUpdateManyMutationInput, FoodPetUncheckedUpdateManyInput>
    /**
     * Filter which FoodPets to update
     */
    where?: FoodPetWhereInput
    /**
     * Limit how many FoodPets to update.
     */
    limit?: number
  }

  /**
   * FoodPet updateManyAndReturn
   */
  export type FoodPetUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodPet
     */
    select?: FoodPetSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FoodPet
     */
    omit?: FoodPetOmit<ExtArgs> | null
    /**
     * The data used to update FoodPets.
     */
    data: XOR<FoodPetUpdateManyMutationInput, FoodPetUncheckedUpdateManyInput>
    /**
     * Filter which FoodPets to update
     */
    where?: FoodPetWhereInput
    /**
     * Limit how many FoodPets to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodPetIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FoodPet upsert
   */
  export type FoodPetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodPet
     */
    select?: FoodPetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodPet
     */
    omit?: FoodPetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodPetInclude<ExtArgs> | null
    /**
     * The filter to search for the FoodPet to update in case it exists.
     */
    where: FoodPetWhereUniqueInput
    /**
     * In case the FoodPet found by the `where` argument doesn't exist, create a new FoodPet with this data.
     */
    create: XOR<FoodPetCreateInput, FoodPetUncheckedCreateInput>
    /**
     * In case the FoodPet was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FoodPetUpdateInput, FoodPetUncheckedUpdateInput>
  }

  /**
   * FoodPet delete
   */
  export type FoodPetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodPet
     */
    select?: FoodPetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodPet
     */
    omit?: FoodPetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodPetInclude<ExtArgs> | null
    /**
     * Filter which FoodPet to delete.
     */
    where: FoodPetWhereUniqueInput
  }

  /**
   * FoodPet deleteMany
   */
  export type FoodPetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FoodPets to delete
     */
    where?: FoodPetWhereInput
    /**
     * Limit how many FoodPets to delete.
     */
    limit?: number
  }

  /**
   * FoodPet without action
   */
  export type FoodPetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodPet
     */
    select?: FoodPetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodPet
     */
    omit?: FoodPetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodPetInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    role: $Enums.UserRole | null
    createdAt: Date | null
    updatedAt: Date | null
    firstname: string | null
    lastname: string | null
    password: string | null
    picture: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    role: $Enums.UserRole | null
    createdAt: Date | null
    updatedAt: Date | null
    firstname: string | null
    lastname: string | null
    password: string | null
    picture: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    role: number
    createdAt: number
    updatedAt: number
    firstname: number
    lastname: number
    password: number
    picture: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    firstname?: true
    lastname?: true
    password?: true
    picture?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    firstname?: true
    lastname?: true
    password?: true
    picture?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    firstname?: true
    lastname?: true
    password?: true
    picture?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    role: $Enums.UserRole
    createdAt: Date
    updatedAt: Date
    firstname: string
    lastname: string
    password: string
    picture: string | null
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    firstname?: boolean
    lastname?: boolean
    password?: boolean
    picture?: boolean
    clientProfile?: boolean | User$clientProfileArgs<ExtArgs>
    veterinarianProfile?: boolean | User$veterinarianProfileArgs<ExtArgs>
    clinicProfile?: boolean | User$clinicProfileArgs<ExtArgs>
    secretaryProfile?: boolean | User$secretaryProfileArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    firstname?: boolean
    lastname?: boolean
    password?: boolean
    picture?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    firstname?: boolean
    lastname?: boolean
    password?: boolean
    picture?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    firstname?: boolean
    lastname?: boolean
    password?: boolean
    picture?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "role" | "createdAt" | "updatedAt" | "firstname" | "lastname" | "password" | "picture", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clientProfile?: boolean | User$clientProfileArgs<ExtArgs>
    veterinarianProfile?: boolean | User$veterinarianProfileArgs<ExtArgs>
    clinicProfile?: boolean | User$clinicProfileArgs<ExtArgs>
    secretaryProfile?: boolean | User$secretaryProfileArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      clientProfile: Prisma.$ClientProfilePayload<ExtArgs> | null
      veterinarianProfile: Prisma.$VeterinarianProfilePayload<ExtArgs> | null
      clinicProfile: Prisma.$ClinicProfilePayload<ExtArgs> | null
      secretaryProfile: Prisma.$SecretaryProfilePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      role: $Enums.UserRole
      createdAt: Date
      updatedAt: Date
      firstname: string
      lastname: string
      password: string
      picture: string | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    clientProfile<T extends User$clientProfileArgs<ExtArgs> = {}>(args?: Subset<T, User$clientProfileArgs<ExtArgs>>): Prisma__ClientProfileClient<$Result.GetResult<Prisma.$ClientProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    veterinarianProfile<T extends User$veterinarianProfileArgs<ExtArgs> = {}>(args?: Subset<T, User$veterinarianProfileArgs<ExtArgs>>): Prisma__VeterinarianProfileClient<$Result.GetResult<Prisma.$VeterinarianProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    clinicProfile<T extends User$clinicProfileArgs<ExtArgs> = {}>(args?: Subset<T, User$clinicProfileArgs<ExtArgs>>): Prisma__ClinicProfileClient<$Result.GetResult<Prisma.$ClinicProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    secretaryProfile<T extends User$secretaryProfileArgs<ExtArgs> = {}>(args?: Subset<T, User$secretaryProfileArgs<ExtArgs>>): Prisma__SecretaryProfileClient<$Result.GetResult<Prisma.$SecretaryProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly firstname: FieldRef<"User", 'String'>
    readonly lastname: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly picture: FieldRef<"User", 'String'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.clientProfile
   */
  export type User$clientProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientProfile
     */
    select?: ClientProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientProfile
     */
    omit?: ClientProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientProfileInclude<ExtArgs> | null
    where?: ClientProfileWhereInput
  }

  /**
   * User.veterinarianProfile
   */
  export type User$veterinarianProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VeterinarianProfile
     */
    select?: VeterinarianProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VeterinarianProfile
     */
    omit?: VeterinarianProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VeterinarianProfileInclude<ExtArgs> | null
    where?: VeterinarianProfileWhereInput
  }

  /**
   * User.clinicProfile
   */
  export type User$clinicProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicProfile
     */
    select?: ClinicProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicProfile
     */
    omit?: ClinicProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicProfileInclude<ExtArgs> | null
    where?: ClinicProfileWhereInput
  }

  /**
   * User.secretaryProfile
   */
  export type User$secretaryProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecretaryProfile
     */
    select?: SecretaryProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecretaryProfile
     */
    omit?: SecretaryProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecretaryProfileInclude<ExtArgs> | null
    where?: SecretaryProfileWhereInput
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model ClientProfile
   */

  export type AggregateClientProfile = {
    _count: ClientProfileCountAggregateOutputType | null
    _min: ClientProfileMinAggregateOutputType | null
    _max: ClientProfileMaxAggregateOutputType | null
  }

  export type ClientProfileMinAggregateOutputType = {
    id: string | null
    dateOfBirth: Date | null
    address: string | null
    phone: string | null
    userId: string | null
  }

  export type ClientProfileMaxAggregateOutputType = {
    id: string | null
    dateOfBirth: Date | null
    address: string | null
    phone: string | null
    userId: string | null
  }

  export type ClientProfileCountAggregateOutputType = {
    id: number
    dateOfBirth: number
    address: number
    phone: number
    userId: number
    _all: number
  }


  export type ClientProfileMinAggregateInputType = {
    id?: true
    dateOfBirth?: true
    address?: true
    phone?: true
    userId?: true
  }

  export type ClientProfileMaxAggregateInputType = {
    id?: true
    dateOfBirth?: true
    address?: true
    phone?: true
    userId?: true
  }

  export type ClientProfileCountAggregateInputType = {
    id?: true
    dateOfBirth?: true
    address?: true
    phone?: true
    userId?: true
    _all?: true
  }

  export type ClientProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClientProfile to aggregate.
     */
    where?: ClientProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientProfiles to fetch.
     */
    orderBy?: ClientProfileOrderByWithRelationInput | ClientProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClientProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ClientProfiles
    **/
    _count?: true | ClientProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClientProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClientProfileMaxAggregateInputType
  }

  export type GetClientProfileAggregateType<T extends ClientProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateClientProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClientProfile[P]>
      : GetScalarType<T[P], AggregateClientProfile[P]>
  }




  export type ClientProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientProfileWhereInput
    orderBy?: ClientProfileOrderByWithAggregationInput | ClientProfileOrderByWithAggregationInput[]
    by: ClientProfileScalarFieldEnum[] | ClientProfileScalarFieldEnum
    having?: ClientProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClientProfileCountAggregateInputType | true
    _min?: ClientProfileMinAggregateInputType
    _max?: ClientProfileMaxAggregateInputType
  }

  export type ClientProfileGroupByOutputType = {
    id: string
    dateOfBirth: Date
    address: string | null
    phone: string | null
    userId: string
    _count: ClientProfileCountAggregateOutputType | null
    _min: ClientProfileMinAggregateOutputType | null
    _max: ClientProfileMaxAggregateOutputType | null
  }

  type GetClientProfileGroupByPayload<T extends ClientProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClientProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClientProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClientProfileGroupByOutputType[P]>
            : GetScalarType<T[P], ClientProfileGroupByOutputType[P]>
        }
      >
    >


  export type ClientProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dateOfBirth?: boolean
    address?: boolean
    phone?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    secretaryProfile?: boolean | ClientProfile$secretaryProfileArgs<ExtArgs>
    veterinarianProfile?: boolean | ClientProfile$veterinarianProfileArgs<ExtArgs>
    clientPet?: boolean | ClientProfile$clientPetArgs<ExtArgs>
    clinicProducts?: boolean | ClientProfile$clinicProductsArgs<ExtArgs>
    _count?: boolean | ClientProfileCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clientProfile"]>

  export type ClientProfileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dateOfBirth?: boolean
    address?: boolean
    phone?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clientProfile"]>

  export type ClientProfileSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dateOfBirth?: boolean
    address?: boolean
    phone?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clientProfile"]>

  export type ClientProfileSelectScalar = {
    id?: boolean
    dateOfBirth?: boolean
    address?: boolean
    phone?: boolean
    userId?: boolean
  }

  export type ClientProfileOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "dateOfBirth" | "address" | "phone" | "userId", ExtArgs["result"]["clientProfile"]>
  export type ClientProfileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    secretaryProfile?: boolean | ClientProfile$secretaryProfileArgs<ExtArgs>
    veterinarianProfile?: boolean | ClientProfile$veterinarianProfileArgs<ExtArgs>
    clientPet?: boolean | ClientProfile$clientPetArgs<ExtArgs>
    clinicProducts?: boolean | ClientProfile$clinicProductsArgs<ExtArgs>
    _count?: boolean | ClientProfileCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ClientProfileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ClientProfileIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ClientProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ClientProfile"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      secretaryProfile: Prisma.$SecretaryProfilePayload<ExtArgs> | null
      veterinarianProfile: Prisma.$VeterinarianProfilePayload<ExtArgs> | null
      clientPet: Prisma.$ClientPetPayload<ExtArgs>[]
      clinicProducts: Prisma.$ClinicProductPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      dateOfBirth: Date
      address: string | null
      phone: string | null
      userId: string
    }, ExtArgs["result"]["clientProfile"]>
    composites: {}
  }

  type ClientProfileGetPayload<S extends boolean | null | undefined | ClientProfileDefaultArgs> = $Result.GetResult<Prisma.$ClientProfilePayload, S>

  type ClientProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClientProfileFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClientProfileCountAggregateInputType | true
    }

  export interface ClientProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ClientProfile'], meta: { name: 'ClientProfile' } }
    /**
     * Find zero or one ClientProfile that matches the filter.
     * @param {ClientProfileFindUniqueArgs} args - Arguments to find a ClientProfile
     * @example
     * // Get one ClientProfile
     * const clientProfile = await prisma.clientProfile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClientProfileFindUniqueArgs>(args: SelectSubset<T, ClientProfileFindUniqueArgs<ExtArgs>>): Prisma__ClientProfileClient<$Result.GetResult<Prisma.$ClientProfilePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ClientProfile that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClientProfileFindUniqueOrThrowArgs} args - Arguments to find a ClientProfile
     * @example
     * // Get one ClientProfile
     * const clientProfile = await prisma.clientProfile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClientProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, ClientProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClientProfileClient<$Result.GetResult<Prisma.$ClientProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClientProfile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientProfileFindFirstArgs} args - Arguments to find a ClientProfile
     * @example
     * // Get one ClientProfile
     * const clientProfile = await prisma.clientProfile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClientProfileFindFirstArgs>(args?: SelectSubset<T, ClientProfileFindFirstArgs<ExtArgs>>): Prisma__ClientProfileClient<$Result.GetResult<Prisma.$ClientProfilePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClientProfile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientProfileFindFirstOrThrowArgs} args - Arguments to find a ClientProfile
     * @example
     * // Get one ClientProfile
     * const clientProfile = await prisma.clientProfile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClientProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, ClientProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClientProfileClient<$Result.GetResult<Prisma.$ClientProfilePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ClientProfiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ClientProfiles
     * const clientProfiles = await prisma.clientProfile.findMany()
     * 
     * // Get first 10 ClientProfiles
     * const clientProfiles = await prisma.clientProfile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clientProfileWithIdOnly = await prisma.clientProfile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClientProfileFindManyArgs>(args?: SelectSubset<T, ClientProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientProfilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ClientProfile.
     * @param {ClientProfileCreateArgs} args - Arguments to create a ClientProfile.
     * @example
     * // Create one ClientProfile
     * const ClientProfile = await prisma.clientProfile.create({
     *   data: {
     *     // ... data to create a ClientProfile
     *   }
     * })
     * 
     */
    create<T extends ClientProfileCreateArgs>(args: SelectSubset<T, ClientProfileCreateArgs<ExtArgs>>): Prisma__ClientProfileClient<$Result.GetResult<Prisma.$ClientProfilePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ClientProfiles.
     * @param {ClientProfileCreateManyArgs} args - Arguments to create many ClientProfiles.
     * @example
     * // Create many ClientProfiles
     * const clientProfile = await prisma.clientProfile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClientProfileCreateManyArgs>(args?: SelectSubset<T, ClientProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ClientProfiles and returns the data saved in the database.
     * @param {ClientProfileCreateManyAndReturnArgs} args - Arguments to create many ClientProfiles.
     * @example
     * // Create many ClientProfiles
     * const clientProfile = await prisma.clientProfile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ClientProfiles and only return the `id`
     * const clientProfileWithIdOnly = await prisma.clientProfile.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClientProfileCreateManyAndReturnArgs>(args?: SelectSubset<T, ClientProfileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientProfilePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ClientProfile.
     * @param {ClientProfileDeleteArgs} args - Arguments to delete one ClientProfile.
     * @example
     * // Delete one ClientProfile
     * const ClientProfile = await prisma.clientProfile.delete({
     *   where: {
     *     // ... filter to delete one ClientProfile
     *   }
     * })
     * 
     */
    delete<T extends ClientProfileDeleteArgs>(args: SelectSubset<T, ClientProfileDeleteArgs<ExtArgs>>): Prisma__ClientProfileClient<$Result.GetResult<Prisma.$ClientProfilePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ClientProfile.
     * @param {ClientProfileUpdateArgs} args - Arguments to update one ClientProfile.
     * @example
     * // Update one ClientProfile
     * const clientProfile = await prisma.clientProfile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClientProfileUpdateArgs>(args: SelectSubset<T, ClientProfileUpdateArgs<ExtArgs>>): Prisma__ClientProfileClient<$Result.GetResult<Prisma.$ClientProfilePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ClientProfiles.
     * @param {ClientProfileDeleteManyArgs} args - Arguments to filter ClientProfiles to delete.
     * @example
     * // Delete a few ClientProfiles
     * const { count } = await prisma.clientProfile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClientProfileDeleteManyArgs>(args?: SelectSubset<T, ClientProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClientProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ClientProfiles
     * const clientProfile = await prisma.clientProfile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClientProfileUpdateManyArgs>(args: SelectSubset<T, ClientProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClientProfiles and returns the data updated in the database.
     * @param {ClientProfileUpdateManyAndReturnArgs} args - Arguments to update many ClientProfiles.
     * @example
     * // Update many ClientProfiles
     * const clientProfile = await prisma.clientProfile.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ClientProfiles and only return the `id`
     * const clientProfileWithIdOnly = await prisma.clientProfile.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ClientProfileUpdateManyAndReturnArgs>(args: SelectSubset<T, ClientProfileUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientProfilePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ClientProfile.
     * @param {ClientProfileUpsertArgs} args - Arguments to update or create a ClientProfile.
     * @example
     * // Update or create a ClientProfile
     * const clientProfile = await prisma.clientProfile.upsert({
     *   create: {
     *     // ... data to create a ClientProfile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ClientProfile we want to update
     *   }
     * })
     */
    upsert<T extends ClientProfileUpsertArgs>(args: SelectSubset<T, ClientProfileUpsertArgs<ExtArgs>>): Prisma__ClientProfileClient<$Result.GetResult<Prisma.$ClientProfilePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ClientProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientProfileCountArgs} args - Arguments to filter ClientProfiles to count.
     * @example
     * // Count the number of ClientProfiles
     * const count = await prisma.clientProfile.count({
     *   where: {
     *     // ... the filter for the ClientProfiles we want to count
     *   }
     * })
    **/
    count<T extends ClientProfileCountArgs>(
      args?: Subset<T, ClientProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClientProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ClientProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClientProfileAggregateArgs>(args: Subset<T, ClientProfileAggregateArgs>): Prisma.PrismaPromise<GetClientProfileAggregateType<T>>

    /**
     * Group by ClientProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClientProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClientProfileGroupByArgs['orderBy'] }
        : { orderBy?: ClientProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClientProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClientProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ClientProfile model
   */
  readonly fields: ClientProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ClientProfile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClientProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    secretaryProfile<T extends ClientProfile$secretaryProfileArgs<ExtArgs> = {}>(args?: Subset<T, ClientProfile$secretaryProfileArgs<ExtArgs>>): Prisma__SecretaryProfileClient<$Result.GetResult<Prisma.$SecretaryProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    veterinarianProfile<T extends ClientProfile$veterinarianProfileArgs<ExtArgs> = {}>(args?: Subset<T, ClientProfile$veterinarianProfileArgs<ExtArgs>>): Prisma__VeterinarianProfileClient<$Result.GetResult<Prisma.$VeterinarianProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    clientPet<T extends ClientProfile$clientPetArgs<ExtArgs> = {}>(args?: Subset<T, ClientProfile$clientPetArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientPetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    clinicProducts<T extends ClientProfile$clinicProductsArgs<ExtArgs> = {}>(args?: Subset<T, ClientProfile$clinicProductsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClinicProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ClientProfile model
   */
  interface ClientProfileFieldRefs {
    readonly id: FieldRef<"ClientProfile", 'String'>
    readonly dateOfBirth: FieldRef<"ClientProfile", 'DateTime'>
    readonly address: FieldRef<"ClientProfile", 'String'>
    readonly phone: FieldRef<"ClientProfile", 'String'>
    readonly userId: FieldRef<"ClientProfile", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ClientProfile findUnique
   */
  export type ClientProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientProfile
     */
    select?: ClientProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientProfile
     */
    omit?: ClientProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientProfileInclude<ExtArgs> | null
    /**
     * Filter, which ClientProfile to fetch.
     */
    where: ClientProfileWhereUniqueInput
  }

  /**
   * ClientProfile findUniqueOrThrow
   */
  export type ClientProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientProfile
     */
    select?: ClientProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientProfile
     */
    omit?: ClientProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientProfileInclude<ExtArgs> | null
    /**
     * Filter, which ClientProfile to fetch.
     */
    where: ClientProfileWhereUniqueInput
  }

  /**
   * ClientProfile findFirst
   */
  export type ClientProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientProfile
     */
    select?: ClientProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientProfile
     */
    omit?: ClientProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientProfileInclude<ExtArgs> | null
    /**
     * Filter, which ClientProfile to fetch.
     */
    where?: ClientProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientProfiles to fetch.
     */
    orderBy?: ClientProfileOrderByWithRelationInput | ClientProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClientProfiles.
     */
    cursor?: ClientProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClientProfiles.
     */
    distinct?: ClientProfileScalarFieldEnum | ClientProfileScalarFieldEnum[]
  }

  /**
   * ClientProfile findFirstOrThrow
   */
  export type ClientProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientProfile
     */
    select?: ClientProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientProfile
     */
    omit?: ClientProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientProfileInclude<ExtArgs> | null
    /**
     * Filter, which ClientProfile to fetch.
     */
    where?: ClientProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientProfiles to fetch.
     */
    orderBy?: ClientProfileOrderByWithRelationInput | ClientProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClientProfiles.
     */
    cursor?: ClientProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClientProfiles.
     */
    distinct?: ClientProfileScalarFieldEnum | ClientProfileScalarFieldEnum[]
  }

  /**
   * ClientProfile findMany
   */
  export type ClientProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientProfile
     */
    select?: ClientProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientProfile
     */
    omit?: ClientProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientProfileInclude<ExtArgs> | null
    /**
     * Filter, which ClientProfiles to fetch.
     */
    where?: ClientProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientProfiles to fetch.
     */
    orderBy?: ClientProfileOrderByWithRelationInput | ClientProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ClientProfiles.
     */
    cursor?: ClientProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientProfiles.
     */
    skip?: number
    distinct?: ClientProfileScalarFieldEnum | ClientProfileScalarFieldEnum[]
  }

  /**
   * ClientProfile create
   */
  export type ClientProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientProfile
     */
    select?: ClientProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientProfile
     */
    omit?: ClientProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientProfileInclude<ExtArgs> | null
    /**
     * The data needed to create a ClientProfile.
     */
    data: XOR<ClientProfileCreateInput, ClientProfileUncheckedCreateInput>
  }

  /**
   * ClientProfile createMany
   */
  export type ClientProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ClientProfiles.
     */
    data: ClientProfileCreateManyInput | ClientProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ClientProfile createManyAndReturn
   */
  export type ClientProfileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientProfile
     */
    select?: ClientProfileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ClientProfile
     */
    omit?: ClientProfileOmit<ExtArgs> | null
    /**
     * The data used to create many ClientProfiles.
     */
    data: ClientProfileCreateManyInput | ClientProfileCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientProfileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ClientProfile update
   */
  export type ClientProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientProfile
     */
    select?: ClientProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientProfile
     */
    omit?: ClientProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientProfileInclude<ExtArgs> | null
    /**
     * The data needed to update a ClientProfile.
     */
    data: XOR<ClientProfileUpdateInput, ClientProfileUncheckedUpdateInput>
    /**
     * Choose, which ClientProfile to update.
     */
    where: ClientProfileWhereUniqueInput
  }

  /**
   * ClientProfile updateMany
   */
  export type ClientProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ClientProfiles.
     */
    data: XOR<ClientProfileUpdateManyMutationInput, ClientProfileUncheckedUpdateManyInput>
    /**
     * Filter which ClientProfiles to update
     */
    where?: ClientProfileWhereInput
    /**
     * Limit how many ClientProfiles to update.
     */
    limit?: number
  }

  /**
   * ClientProfile updateManyAndReturn
   */
  export type ClientProfileUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientProfile
     */
    select?: ClientProfileSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ClientProfile
     */
    omit?: ClientProfileOmit<ExtArgs> | null
    /**
     * The data used to update ClientProfiles.
     */
    data: XOR<ClientProfileUpdateManyMutationInput, ClientProfileUncheckedUpdateManyInput>
    /**
     * Filter which ClientProfiles to update
     */
    where?: ClientProfileWhereInput
    /**
     * Limit how many ClientProfiles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientProfileIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ClientProfile upsert
   */
  export type ClientProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientProfile
     */
    select?: ClientProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientProfile
     */
    omit?: ClientProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientProfileInclude<ExtArgs> | null
    /**
     * The filter to search for the ClientProfile to update in case it exists.
     */
    where: ClientProfileWhereUniqueInput
    /**
     * In case the ClientProfile found by the `where` argument doesn't exist, create a new ClientProfile with this data.
     */
    create: XOR<ClientProfileCreateInput, ClientProfileUncheckedCreateInput>
    /**
     * In case the ClientProfile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClientProfileUpdateInput, ClientProfileUncheckedUpdateInput>
  }

  /**
   * ClientProfile delete
   */
  export type ClientProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientProfile
     */
    select?: ClientProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientProfile
     */
    omit?: ClientProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientProfileInclude<ExtArgs> | null
    /**
     * Filter which ClientProfile to delete.
     */
    where: ClientProfileWhereUniqueInput
  }

  /**
   * ClientProfile deleteMany
   */
  export type ClientProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClientProfiles to delete
     */
    where?: ClientProfileWhereInput
    /**
     * Limit how many ClientProfiles to delete.
     */
    limit?: number
  }

  /**
   * ClientProfile.secretaryProfile
   */
  export type ClientProfile$secretaryProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecretaryProfile
     */
    select?: SecretaryProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecretaryProfile
     */
    omit?: SecretaryProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecretaryProfileInclude<ExtArgs> | null
    where?: SecretaryProfileWhereInput
  }

  /**
   * ClientProfile.veterinarianProfile
   */
  export type ClientProfile$veterinarianProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VeterinarianProfile
     */
    select?: VeterinarianProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VeterinarianProfile
     */
    omit?: VeterinarianProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VeterinarianProfileInclude<ExtArgs> | null
    where?: VeterinarianProfileWhereInput
  }

  /**
   * ClientProfile.clientPet
   */
  export type ClientProfile$clientPetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientPet
     */
    select?: ClientPetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientPet
     */
    omit?: ClientPetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientPetInclude<ExtArgs> | null
    where?: ClientPetWhereInput
    orderBy?: ClientPetOrderByWithRelationInput | ClientPetOrderByWithRelationInput[]
    cursor?: ClientPetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClientPetScalarFieldEnum | ClientPetScalarFieldEnum[]
  }

  /**
   * ClientProfile.clinicProducts
   */
  export type ClientProfile$clinicProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicProduct
     */
    select?: ClinicProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicProduct
     */
    omit?: ClinicProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicProductInclude<ExtArgs> | null
    where?: ClinicProductWhereInput
    orderBy?: ClinicProductOrderByWithRelationInput | ClinicProductOrderByWithRelationInput[]
    cursor?: ClinicProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClinicProductScalarFieldEnum | ClinicProductScalarFieldEnum[]
  }

  /**
   * ClientProfile without action
   */
  export type ClientProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientProfile
     */
    select?: ClientProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientProfile
     */
    omit?: ClientProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientProfileInclude<ExtArgs> | null
  }


  /**
   * Model VeterinarianProfile
   */

  export type AggregateVeterinarianProfile = {
    _count: VeterinarianProfileCountAggregateOutputType | null
    _avg: VeterinarianProfileAvgAggregateOutputType | null
    _sum: VeterinarianProfileSumAggregateOutputType | null
    _min: VeterinarianProfileMinAggregateOutputType | null
    _max: VeterinarianProfileMaxAggregateOutputType | null
  }

  export type VeterinarianProfileAvgAggregateOutputType = {
    yearsExperience: number | null
  }

  export type VeterinarianProfileSumAggregateOutputType = {
    yearsExperience: number | null
  }

  export type VeterinarianProfileMinAggregateOutputType = {
    id: string | null
    licenseNumber: string | null
    specialty: string | null
    yearsExperience: number | null
    bio: string | null
    clinicId: string | null
    userId: string | null
  }

  export type VeterinarianProfileMaxAggregateOutputType = {
    id: string | null
    licenseNumber: string | null
    specialty: string | null
    yearsExperience: number | null
    bio: string | null
    clinicId: string | null
    userId: string | null
  }

  export type VeterinarianProfileCountAggregateOutputType = {
    id: number
    licenseNumber: number
    specialty: number
    yearsExperience: number
    bio: number
    clinicId: number
    userId: number
    _all: number
  }


  export type VeterinarianProfileAvgAggregateInputType = {
    yearsExperience?: true
  }

  export type VeterinarianProfileSumAggregateInputType = {
    yearsExperience?: true
  }

  export type VeterinarianProfileMinAggregateInputType = {
    id?: true
    licenseNumber?: true
    specialty?: true
    yearsExperience?: true
    bio?: true
    clinicId?: true
    userId?: true
  }

  export type VeterinarianProfileMaxAggregateInputType = {
    id?: true
    licenseNumber?: true
    specialty?: true
    yearsExperience?: true
    bio?: true
    clinicId?: true
    userId?: true
  }

  export type VeterinarianProfileCountAggregateInputType = {
    id?: true
    licenseNumber?: true
    specialty?: true
    yearsExperience?: true
    bio?: true
    clinicId?: true
    userId?: true
    _all?: true
  }

  export type VeterinarianProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VeterinarianProfile to aggregate.
     */
    where?: VeterinarianProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VeterinarianProfiles to fetch.
     */
    orderBy?: VeterinarianProfileOrderByWithRelationInput | VeterinarianProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VeterinarianProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VeterinarianProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VeterinarianProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VeterinarianProfiles
    **/
    _count?: true | VeterinarianProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VeterinarianProfileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VeterinarianProfileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VeterinarianProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VeterinarianProfileMaxAggregateInputType
  }

  export type GetVeterinarianProfileAggregateType<T extends VeterinarianProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateVeterinarianProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVeterinarianProfile[P]>
      : GetScalarType<T[P], AggregateVeterinarianProfile[P]>
  }




  export type VeterinarianProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VeterinarianProfileWhereInput
    orderBy?: VeterinarianProfileOrderByWithAggregationInput | VeterinarianProfileOrderByWithAggregationInput[]
    by: VeterinarianProfileScalarFieldEnum[] | VeterinarianProfileScalarFieldEnum
    having?: VeterinarianProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VeterinarianProfileCountAggregateInputType | true
    _avg?: VeterinarianProfileAvgAggregateInputType
    _sum?: VeterinarianProfileSumAggregateInputType
    _min?: VeterinarianProfileMinAggregateInputType
    _max?: VeterinarianProfileMaxAggregateInputType
  }

  export type VeterinarianProfileGroupByOutputType = {
    id: string
    licenseNumber: string
    specialty: string
    yearsExperience: number
    bio: string | null
    clinicId: string
    userId: string
    _count: VeterinarianProfileCountAggregateOutputType | null
    _avg: VeterinarianProfileAvgAggregateOutputType | null
    _sum: VeterinarianProfileSumAggregateOutputType | null
    _min: VeterinarianProfileMinAggregateOutputType | null
    _max: VeterinarianProfileMaxAggregateOutputType | null
  }

  type GetVeterinarianProfileGroupByPayload<T extends VeterinarianProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VeterinarianProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VeterinarianProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VeterinarianProfileGroupByOutputType[P]>
            : GetScalarType<T[P], VeterinarianProfileGroupByOutputType[P]>
        }
      >
    >


  export type VeterinarianProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    licenseNumber?: boolean
    specialty?: boolean
    yearsExperience?: boolean
    bio?: boolean
    clinicId?: boolean
    userId?: boolean
    clinic?: boolean | ClientProfileDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    clinicProfiles?: boolean | VeterinarianProfile$clinicProfilesArgs<ExtArgs>
    clientPet?: boolean | VeterinarianProfile$clientPetArgs<ExtArgs>
    metting?: boolean | VeterinarianProfile$mettingArgs<ExtArgs>
    _count?: boolean | VeterinarianProfileCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["veterinarianProfile"]>

  export type VeterinarianProfileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    licenseNumber?: boolean
    specialty?: boolean
    yearsExperience?: boolean
    bio?: boolean
    clinicId?: boolean
    userId?: boolean
    clinic?: boolean | ClientProfileDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["veterinarianProfile"]>

  export type VeterinarianProfileSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    licenseNumber?: boolean
    specialty?: boolean
    yearsExperience?: boolean
    bio?: boolean
    clinicId?: boolean
    userId?: boolean
    clinic?: boolean | ClientProfileDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["veterinarianProfile"]>

  export type VeterinarianProfileSelectScalar = {
    id?: boolean
    licenseNumber?: boolean
    specialty?: boolean
    yearsExperience?: boolean
    bio?: boolean
    clinicId?: boolean
    userId?: boolean
  }

  export type VeterinarianProfileOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "licenseNumber" | "specialty" | "yearsExperience" | "bio" | "clinicId" | "userId", ExtArgs["result"]["veterinarianProfile"]>
  export type VeterinarianProfileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clinic?: boolean | ClientProfileDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    clinicProfiles?: boolean | VeterinarianProfile$clinicProfilesArgs<ExtArgs>
    clientPet?: boolean | VeterinarianProfile$clientPetArgs<ExtArgs>
    metting?: boolean | VeterinarianProfile$mettingArgs<ExtArgs>
    _count?: boolean | VeterinarianProfileCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type VeterinarianProfileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clinic?: boolean | ClientProfileDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type VeterinarianProfileIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clinic?: boolean | ClientProfileDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $VeterinarianProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VeterinarianProfile"
    objects: {
      clinic: Prisma.$ClientProfilePayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
      clinicProfiles: Prisma.$ClinicProfilePayload<ExtArgs>[]
      clientPet: Prisma.$ClientPetPayload<ExtArgs>[]
      metting: Prisma.$MettingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      licenseNumber: string
      specialty: string
      yearsExperience: number
      bio: string | null
      clinicId: string
      userId: string
    }, ExtArgs["result"]["veterinarianProfile"]>
    composites: {}
  }

  type VeterinarianProfileGetPayload<S extends boolean | null | undefined | VeterinarianProfileDefaultArgs> = $Result.GetResult<Prisma.$VeterinarianProfilePayload, S>

  type VeterinarianProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VeterinarianProfileFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VeterinarianProfileCountAggregateInputType | true
    }

  export interface VeterinarianProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VeterinarianProfile'], meta: { name: 'VeterinarianProfile' } }
    /**
     * Find zero or one VeterinarianProfile that matches the filter.
     * @param {VeterinarianProfileFindUniqueArgs} args - Arguments to find a VeterinarianProfile
     * @example
     * // Get one VeterinarianProfile
     * const veterinarianProfile = await prisma.veterinarianProfile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VeterinarianProfileFindUniqueArgs>(args: SelectSubset<T, VeterinarianProfileFindUniqueArgs<ExtArgs>>): Prisma__VeterinarianProfileClient<$Result.GetResult<Prisma.$VeterinarianProfilePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VeterinarianProfile that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VeterinarianProfileFindUniqueOrThrowArgs} args - Arguments to find a VeterinarianProfile
     * @example
     * // Get one VeterinarianProfile
     * const veterinarianProfile = await prisma.veterinarianProfile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VeterinarianProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, VeterinarianProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VeterinarianProfileClient<$Result.GetResult<Prisma.$VeterinarianProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VeterinarianProfile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VeterinarianProfileFindFirstArgs} args - Arguments to find a VeterinarianProfile
     * @example
     * // Get one VeterinarianProfile
     * const veterinarianProfile = await prisma.veterinarianProfile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VeterinarianProfileFindFirstArgs>(args?: SelectSubset<T, VeterinarianProfileFindFirstArgs<ExtArgs>>): Prisma__VeterinarianProfileClient<$Result.GetResult<Prisma.$VeterinarianProfilePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VeterinarianProfile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VeterinarianProfileFindFirstOrThrowArgs} args - Arguments to find a VeterinarianProfile
     * @example
     * // Get one VeterinarianProfile
     * const veterinarianProfile = await prisma.veterinarianProfile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VeterinarianProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, VeterinarianProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__VeterinarianProfileClient<$Result.GetResult<Prisma.$VeterinarianProfilePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VeterinarianProfiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VeterinarianProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VeterinarianProfiles
     * const veterinarianProfiles = await prisma.veterinarianProfile.findMany()
     * 
     * // Get first 10 VeterinarianProfiles
     * const veterinarianProfiles = await prisma.veterinarianProfile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const veterinarianProfileWithIdOnly = await prisma.veterinarianProfile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VeterinarianProfileFindManyArgs>(args?: SelectSubset<T, VeterinarianProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VeterinarianProfilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VeterinarianProfile.
     * @param {VeterinarianProfileCreateArgs} args - Arguments to create a VeterinarianProfile.
     * @example
     * // Create one VeterinarianProfile
     * const VeterinarianProfile = await prisma.veterinarianProfile.create({
     *   data: {
     *     // ... data to create a VeterinarianProfile
     *   }
     * })
     * 
     */
    create<T extends VeterinarianProfileCreateArgs>(args: SelectSubset<T, VeterinarianProfileCreateArgs<ExtArgs>>): Prisma__VeterinarianProfileClient<$Result.GetResult<Prisma.$VeterinarianProfilePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VeterinarianProfiles.
     * @param {VeterinarianProfileCreateManyArgs} args - Arguments to create many VeterinarianProfiles.
     * @example
     * // Create many VeterinarianProfiles
     * const veterinarianProfile = await prisma.veterinarianProfile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VeterinarianProfileCreateManyArgs>(args?: SelectSubset<T, VeterinarianProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VeterinarianProfiles and returns the data saved in the database.
     * @param {VeterinarianProfileCreateManyAndReturnArgs} args - Arguments to create many VeterinarianProfiles.
     * @example
     * // Create many VeterinarianProfiles
     * const veterinarianProfile = await prisma.veterinarianProfile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VeterinarianProfiles and only return the `id`
     * const veterinarianProfileWithIdOnly = await prisma.veterinarianProfile.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VeterinarianProfileCreateManyAndReturnArgs>(args?: SelectSubset<T, VeterinarianProfileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VeterinarianProfilePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VeterinarianProfile.
     * @param {VeterinarianProfileDeleteArgs} args - Arguments to delete one VeterinarianProfile.
     * @example
     * // Delete one VeterinarianProfile
     * const VeterinarianProfile = await prisma.veterinarianProfile.delete({
     *   where: {
     *     // ... filter to delete one VeterinarianProfile
     *   }
     * })
     * 
     */
    delete<T extends VeterinarianProfileDeleteArgs>(args: SelectSubset<T, VeterinarianProfileDeleteArgs<ExtArgs>>): Prisma__VeterinarianProfileClient<$Result.GetResult<Prisma.$VeterinarianProfilePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VeterinarianProfile.
     * @param {VeterinarianProfileUpdateArgs} args - Arguments to update one VeterinarianProfile.
     * @example
     * // Update one VeterinarianProfile
     * const veterinarianProfile = await prisma.veterinarianProfile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VeterinarianProfileUpdateArgs>(args: SelectSubset<T, VeterinarianProfileUpdateArgs<ExtArgs>>): Prisma__VeterinarianProfileClient<$Result.GetResult<Prisma.$VeterinarianProfilePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VeterinarianProfiles.
     * @param {VeterinarianProfileDeleteManyArgs} args - Arguments to filter VeterinarianProfiles to delete.
     * @example
     * // Delete a few VeterinarianProfiles
     * const { count } = await prisma.veterinarianProfile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VeterinarianProfileDeleteManyArgs>(args?: SelectSubset<T, VeterinarianProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VeterinarianProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VeterinarianProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VeterinarianProfiles
     * const veterinarianProfile = await prisma.veterinarianProfile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VeterinarianProfileUpdateManyArgs>(args: SelectSubset<T, VeterinarianProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VeterinarianProfiles and returns the data updated in the database.
     * @param {VeterinarianProfileUpdateManyAndReturnArgs} args - Arguments to update many VeterinarianProfiles.
     * @example
     * // Update many VeterinarianProfiles
     * const veterinarianProfile = await prisma.veterinarianProfile.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VeterinarianProfiles and only return the `id`
     * const veterinarianProfileWithIdOnly = await prisma.veterinarianProfile.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VeterinarianProfileUpdateManyAndReturnArgs>(args: SelectSubset<T, VeterinarianProfileUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VeterinarianProfilePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VeterinarianProfile.
     * @param {VeterinarianProfileUpsertArgs} args - Arguments to update or create a VeterinarianProfile.
     * @example
     * // Update or create a VeterinarianProfile
     * const veterinarianProfile = await prisma.veterinarianProfile.upsert({
     *   create: {
     *     // ... data to create a VeterinarianProfile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VeterinarianProfile we want to update
     *   }
     * })
     */
    upsert<T extends VeterinarianProfileUpsertArgs>(args: SelectSubset<T, VeterinarianProfileUpsertArgs<ExtArgs>>): Prisma__VeterinarianProfileClient<$Result.GetResult<Prisma.$VeterinarianProfilePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VeterinarianProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VeterinarianProfileCountArgs} args - Arguments to filter VeterinarianProfiles to count.
     * @example
     * // Count the number of VeterinarianProfiles
     * const count = await prisma.veterinarianProfile.count({
     *   where: {
     *     // ... the filter for the VeterinarianProfiles we want to count
     *   }
     * })
    **/
    count<T extends VeterinarianProfileCountArgs>(
      args?: Subset<T, VeterinarianProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VeterinarianProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VeterinarianProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VeterinarianProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VeterinarianProfileAggregateArgs>(args: Subset<T, VeterinarianProfileAggregateArgs>): Prisma.PrismaPromise<GetVeterinarianProfileAggregateType<T>>

    /**
     * Group by VeterinarianProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VeterinarianProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VeterinarianProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VeterinarianProfileGroupByArgs['orderBy'] }
        : { orderBy?: VeterinarianProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VeterinarianProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVeterinarianProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VeterinarianProfile model
   */
  readonly fields: VeterinarianProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VeterinarianProfile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VeterinarianProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    clinic<T extends ClientProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientProfileDefaultArgs<ExtArgs>>): Prisma__ClientProfileClient<$Result.GetResult<Prisma.$ClientProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    clinicProfiles<T extends VeterinarianProfile$clinicProfilesArgs<ExtArgs> = {}>(args?: Subset<T, VeterinarianProfile$clinicProfilesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClinicProfilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    clientPet<T extends VeterinarianProfile$clientPetArgs<ExtArgs> = {}>(args?: Subset<T, VeterinarianProfile$clientPetArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientPetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    metting<T extends VeterinarianProfile$mettingArgs<ExtArgs> = {}>(args?: Subset<T, VeterinarianProfile$mettingArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MettingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VeterinarianProfile model
   */
  interface VeterinarianProfileFieldRefs {
    readonly id: FieldRef<"VeterinarianProfile", 'String'>
    readonly licenseNumber: FieldRef<"VeterinarianProfile", 'String'>
    readonly specialty: FieldRef<"VeterinarianProfile", 'String'>
    readonly yearsExperience: FieldRef<"VeterinarianProfile", 'Int'>
    readonly bio: FieldRef<"VeterinarianProfile", 'String'>
    readonly clinicId: FieldRef<"VeterinarianProfile", 'String'>
    readonly userId: FieldRef<"VeterinarianProfile", 'String'>
  }
    

  // Custom InputTypes
  /**
   * VeterinarianProfile findUnique
   */
  export type VeterinarianProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VeterinarianProfile
     */
    select?: VeterinarianProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VeterinarianProfile
     */
    omit?: VeterinarianProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VeterinarianProfileInclude<ExtArgs> | null
    /**
     * Filter, which VeterinarianProfile to fetch.
     */
    where: VeterinarianProfileWhereUniqueInput
  }

  /**
   * VeterinarianProfile findUniqueOrThrow
   */
  export type VeterinarianProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VeterinarianProfile
     */
    select?: VeterinarianProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VeterinarianProfile
     */
    omit?: VeterinarianProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VeterinarianProfileInclude<ExtArgs> | null
    /**
     * Filter, which VeterinarianProfile to fetch.
     */
    where: VeterinarianProfileWhereUniqueInput
  }

  /**
   * VeterinarianProfile findFirst
   */
  export type VeterinarianProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VeterinarianProfile
     */
    select?: VeterinarianProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VeterinarianProfile
     */
    omit?: VeterinarianProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VeterinarianProfileInclude<ExtArgs> | null
    /**
     * Filter, which VeterinarianProfile to fetch.
     */
    where?: VeterinarianProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VeterinarianProfiles to fetch.
     */
    orderBy?: VeterinarianProfileOrderByWithRelationInput | VeterinarianProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VeterinarianProfiles.
     */
    cursor?: VeterinarianProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VeterinarianProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VeterinarianProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VeterinarianProfiles.
     */
    distinct?: VeterinarianProfileScalarFieldEnum | VeterinarianProfileScalarFieldEnum[]
  }

  /**
   * VeterinarianProfile findFirstOrThrow
   */
  export type VeterinarianProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VeterinarianProfile
     */
    select?: VeterinarianProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VeterinarianProfile
     */
    omit?: VeterinarianProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VeterinarianProfileInclude<ExtArgs> | null
    /**
     * Filter, which VeterinarianProfile to fetch.
     */
    where?: VeterinarianProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VeterinarianProfiles to fetch.
     */
    orderBy?: VeterinarianProfileOrderByWithRelationInput | VeterinarianProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VeterinarianProfiles.
     */
    cursor?: VeterinarianProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VeterinarianProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VeterinarianProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VeterinarianProfiles.
     */
    distinct?: VeterinarianProfileScalarFieldEnum | VeterinarianProfileScalarFieldEnum[]
  }

  /**
   * VeterinarianProfile findMany
   */
  export type VeterinarianProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VeterinarianProfile
     */
    select?: VeterinarianProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VeterinarianProfile
     */
    omit?: VeterinarianProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VeterinarianProfileInclude<ExtArgs> | null
    /**
     * Filter, which VeterinarianProfiles to fetch.
     */
    where?: VeterinarianProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VeterinarianProfiles to fetch.
     */
    orderBy?: VeterinarianProfileOrderByWithRelationInput | VeterinarianProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VeterinarianProfiles.
     */
    cursor?: VeterinarianProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VeterinarianProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VeterinarianProfiles.
     */
    skip?: number
    distinct?: VeterinarianProfileScalarFieldEnum | VeterinarianProfileScalarFieldEnum[]
  }

  /**
   * VeterinarianProfile create
   */
  export type VeterinarianProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VeterinarianProfile
     */
    select?: VeterinarianProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VeterinarianProfile
     */
    omit?: VeterinarianProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VeterinarianProfileInclude<ExtArgs> | null
    /**
     * The data needed to create a VeterinarianProfile.
     */
    data: XOR<VeterinarianProfileCreateInput, VeterinarianProfileUncheckedCreateInput>
  }

  /**
   * VeterinarianProfile createMany
   */
  export type VeterinarianProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VeterinarianProfiles.
     */
    data: VeterinarianProfileCreateManyInput | VeterinarianProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VeterinarianProfile createManyAndReturn
   */
  export type VeterinarianProfileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VeterinarianProfile
     */
    select?: VeterinarianProfileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VeterinarianProfile
     */
    omit?: VeterinarianProfileOmit<ExtArgs> | null
    /**
     * The data used to create many VeterinarianProfiles.
     */
    data: VeterinarianProfileCreateManyInput | VeterinarianProfileCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VeterinarianProfileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VeterinarianProfile update
   */
  export type VeterinarianProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VeterinarianProfile
     */
    select?: VeterinarianProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VeterinarianProfile
     */
    omit?: VeterinarianProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VeterinarianProfileInclude<ExtArgs> | null
    /**
     * The data needed to update a VeterinarianProfile.
     */
    data: XOR<VeterinarianProfileUpdateInput, VeterinarianProfileUncheckedUpdateInput>
    /**
     * Choose, which VeterinarianProfile to update.
     */
    where: VeterinarianProfileWhereUniqueInput
  }

  /**
   * VeterinarianProfile updateMany
   */
  export type VeterinarianProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VeterinarianProfiles.
     */
    data: XOR<VeterinarianProfileUpdateManyMutationInput, VeterinarianProfileUncheckedUpdateManyInput>
    /**
     * Filter which VeterinarianProfiles to update
     */
    where?: VeterinarianProfileWhereInput
    /**
     * Limit how many VeterinarianProfiles to update.
     */
    limit?: number
  }

  /**
   * VeterinarianProfile updateManyAndReturn
   */
  export type VeterinarianProfileUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VeterinarianProfile
     */
    select?: VeterinarianProfileSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VeterinarianProfile
     */
    omit?: VeterinarianProfileOmit<ExtArgs> | null
    /**
     * The data used to update VeterinarianProfiles.
     */
    data: XOR<VeterinarianProfileUpdateManyMutationInput, VeterinarianProfileUncheckedUpdateManyInput>
    /**
     * Filter which VeterinarianProfiles to update
     */
    where?: VeterinarianProfileWhereInput
    /**
     * Limit how many VeterinarianProfiles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VeterinarianProfileIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * VeterinarianProfile upsert
   */
  export type VeterinarianProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VeterinarianProfile
     */
    select?: VeterinarianProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VeterinarianProfile
     */
    omit?: VeterinarianProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VeterinarianProfileInclude<ExtArgs> | null
    /**
     * The filter to search for the VeterinarianProfile to update in case it exists.
     */
    where: VeterinarianProfileWhereUniqueInput
    /**
     * In case the VeterinarianProfile found by the `where` argument doesn't exist, create a new VeterinarianProfile with this data.
     */
    create: XOR<VeterinarianProfileCreateInput, VeterinarianProfileUncheckedCreateInput>
    /**
     * In case the VeterinarianProfile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VeterinarianProfileUpdateInput, VeterinarianProfileUncheckedUpdateInput>
  }

  /**
   * VeterinarianProfile delete
   */
  export type VeterinarianProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VeterinarianProfile
     */
    select?: VeterinarianProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VeterinarianProfile
     */
    omit?: VeterinarianProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VeterinarianProfileInclude<ExtArgs> | null
    /**
     * Filter which VeterinarianProfile to delete.
     */
    where: VeterinarianProfileWhereUniqueInput
  }

  /**
   * VeterinarianProfile deleteMany
   */
  export type VeterinarianProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VeterinarianProfiles to delete
     */
    where?: VeterinarianProfileWhereInput
    /**
     * Limit how many VeterinarianProfiles to delete.
     */
    limit?: number
  }

  /**
   * VeterinarianProfile.clinicProfiles
   */
  export type VeterinarianProfile$clinicProfilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicProfile
     */
    select?: ClinicProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicProfile
     */
    omit?: ClinicProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicProfileInclude<ExtArgs> | null
    where?: ClinicProfileWhereInput
    orderBy?: ClinicProfileOrderByWithRelationInput | ClinicProfileOrderByWithRelationInput[]
    cursor?: ClinicProfileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClinicProfileScalarFieldEnum | ClinicProfileScalarFieldEnum[]
  }

  /**
   * VeterinarianProfile.clientPet
   */
  export type VeterinarianProfile$clientPetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientPet
     */
    select?: ClientPetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientPet
     */
    omit?: ClientPetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientPetInclude<ExtArgs> | null
    where?: ClientPetWhereInput
    orderBy?: ClientPetOrderByWithRelationInput | ClientPetOrderByWithRelationInput[]
    cursor?: ClientPetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClientPetScalarFieldEnum | ClientPetScalarFieldEnum[]
  }

  /**
   * VeterinarianProfile.metting
   */
  export type VeterinarianProfile$mettingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Metting
     */
    select?: MettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Metting
     */
    omit?: MettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MettingInclude<ExtArgs> | null
    where?: MettingWhereInput
    orderBy?: MettingOrderByWithRelationInput | MettingOrderByWithRelationInput[]
    cursor?: MettingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MettingScalarFieldEnum | MettingScalarFieldEnum[]
  }

  /**
   * VeterinarianProfile without action
   */
  export type VeterinarianProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VeterinarianProfile
     */
    select?: VeterinarianProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VeterinarianProfile
     */
    omit?: VeterinarianProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VeterinarianProfileInclude<ExtArgs> | null
  }


  /**
   * Model ClinicProfile
   */

  export type AggregateClinicProfile = {
    _count: ClinicProfileCountAggregateOutputType | null
    _min: ClinicProfileMinAggregateOutputType | null
    _max: ClinicProfileMaxAggregateOutputType | null
  }

  export type ClinicProfileMinAggregateOutputType = {
    id: string | null
    name: string | null
    address: string | null
    siret: string | null
    phone: string | null
    description: string | null
    website: string | null
    userId: string | null
    veterinarianProfileId: string | null
  }

  export type ClinicProfileMaxAggregateOutputType = {
    id: string | null
    name: string | null
    address: string | null
    siret: string | null
    phone: string | null
    description: string | null
    website: string | null
    userId: string | null
    veterinarianProfileId: string | null
  }

  export type ClinicProfileCountAggregateOutputType = {
    id: number
    name: number
    address: number
    siret: number
    phone: number
    description: number
    website: number
    userId: number
    veterinarianProfileId: number
    _all: number
  }


  export type ClinicProfileMinAggregateInputType = {
    id?: true
    name?: true
    address?: true
    siret?: true
    phone?: true
    description?: true
    website?: true
    userId?: true
    veterinarianProfileId?: true
  }

  export type ClinicProfileMaxAggregateInputType = {
    id?: true
    name?: true
    address?: true
    siret?: true
    phone?: true
    description?: true
    website?: true
    userId?: true
    veterinarianProfileId?: true
  }

  export type ClinicProfileCountAggregateInputType = {
    id?: true
    name?: true
    address?: true
    siret?: true
    phone?: true
    description?: true
    website?: true
    userId?: true
    veterinarianProfileId?: true
    _all?: true
  }

  export type ClinicProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClinicProfile to aggregate.
     */
    where?: ClinicProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClinicProfiles to fetch.
     */
    orderBy?: ClinicProfileOrderByWithRelationInput | ClinicProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClinicProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClinicProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClinicProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ClinicProfiles
    **/
    _count?: true | ClinicProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClinicProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClinicProfileMaxAggregateInputType
  }

  export type GetClinicProfileAggregateType<T extends ClinicProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateClinicProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClinicProfile[P]>
      : GetScalarType<T[P], AggregateClinicProfile[P]>
  }




  export type ClinicProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClinicProfileWhereInput
    orderBy?: ClinicProfileOrderByWithAggregationInput | ClinicProfileOrderByWithAggregationInput[]
    by: ClinicProfileScalarFieldEnum[] | ClinicProfileScalarFieldEnum
    having?: ClinicProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClinicProfileCountAggregateInputType | true
    _min?: ClinicProfileMinAggregateInputType
    _max?: ClinicProfileMaxAggregateInputType
  }

  export type ClinicProfileGroupByOutputType = {
    id: string
    name: string
    address: string
    siret: string
    phone: string
    description: string | null
    website: string
    userId: string
    veterinarianProfileId: string | null
    _count: ClinicProfileCountAggregateOutputType | null
    _min: ClinicProfileMinAggregateOutputType | null
    _max: ClinicProfileMaxAggregateOutputType | null
  }

  type GetClinicProfileGroupByPayload<T extends ClinicProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClinicProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClinicProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClinicProfileGroupByOutputType[P]>
            : GetScalarType<T[P], ClinicProfileGroupByOutputType[P]>
        }
      >
    >


  export type ClinicProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean
    siret?: boolean
    phone?: boolean
    description?: boolean
    website?: boolean
    userId?: boolean
    veterinarianProfileId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    veterinarianProfile?: boolean | ClinicProfile$veterinarianProfileArgs<ExtArgs>
  }, ExtArgs["result"]["clinicProfile"]>

  export type ClinicProfileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean
    siret?: boolean
    phone?: boolean
    description?: boolean
    website?: boolean
    userId?: boolean
    veterinarianProfileId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    veterinarianProfile?: boolean | ClinicProfile$veterinarianProfileArgs<ExtArgs>
  }, ExtArgs["result"]["clinicProfile"]>

  export type ClinicProfileSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean
    siret?: boolean
    phone?: boolean
    description?: boolean
    website?: boolean
    userId?: boolean
    veterinarianProfileId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    veterinarianProfile?: boolean | ClinicProfile$veterinarianProfileArgs<ExtArgs>
  }, ExtArgs["result"]["clinicProfile"]>

  export type ClinicProfileSelectScalar = {
    id?: boolean
    name?: boolean
    address?: boolean
    siret?: boolean
    phone?: boolean
    description?: boolean
    website?: boolean
    userId?: boolean
    veterinarianProfileId?: boolean
  }

  export type ClinicProfileOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "address" | "siret" | "phone" | "description" | "website" | "userId" | "veterinarianProfileId", ExtArgs["result"]["clinicProfile"]>
  export type ClinicProfileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    veterinarianProfile?: boolean | ClinicProfile$veterinarianProfileArgs<ExtArgs>
  }
  export type ClinicProfileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    veterinarianProfile?: boolean | ClinicProfile$veterinarianProfileArgs<ExtArgs>
  }
  export type ClinicProfileIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    veterinarianProfile?: boolean | ClinicProfile$veterinarianProfileArgs<ExtArgs>
  }

  export type $ClinicProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ClinicProfile"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      veterinarianProfile: Prisma.$VeterinarianProfilePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      address: string
      siret: string
      phone: string
      description: string | null
      website: string
      userId: string
      veterinarianProfileId: string | null
    }, ExtArgs["result"]["clinicProfile"]>
    composites: {}
  }

  type ClinicProfileGetPayload<S extends boolean | null | undefined | ClinicProfileDefaultArgs> = $Result.GetResult<Prisma.$ClinicProfilePayload, S>

  type ClinicProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClinicProfileFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClinicProfileCountAggregateInputType | true
    }

  export interface ClinicProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ClinicProfile'], meta: { name: 'ClinicProfile' } }
    /**
     * Find zero or one ClinicProfile that matches the filter.
     * @param {ClinicProfileFindUniqueArgs} args - Arguments to find a ClinicProfile
     * @example
     * // Get one ClinicProfile
     * const clinicProfile = await prisma.clinicProfile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClinicProfileFindUniqueArgs>(args: SelectSubset<T, ClinicProfileFindUniqueArgs<ExtArgs>>): Prisma__ClinicProfileClient<$Result.GetResult<Prisma.$ClinicProfilePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ClinicProfile that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClinicProfileFindUniqueOrThrowArgs} args - Arguments to find a ClinicProfile
     * @example
     * // Get one ClinicProfile
     * const clinicProfile = await prisma.clinicProfile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClinicProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, ClinicProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClinicProfileClient<$Result.GetResult<Prisma.$ClinicProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClinicProfile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicProfileFindFirstArgs} args - Arguments to find a ClinicProfile
     * @example
     * // Get one ClinicProfile
     * const clinicProfile = await prisma.clinicProfile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClinicProfileFindFirstArgs>(args?: SelectSubset<T, ClinicProfileFindFirstArgs<ExtArgs>>): Prisma__ClinicProfileClient<$Result.GetResult<Prisma.$ClinicProfilePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClinicProfile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicProfileFindFirstOrThrowArgs} args - Arguments to find a ClinicProfile
     * @example
     * // Get one ClinicProfile
     * const clinicProfile = await prisma.clinicProfile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClinicProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, ClinicProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClinicProfileClient<$Result.GetResult<Prisma.$ClinicProfilePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ClinicProfiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ClinicProfiles
     * const clinicProfiles = await prisma.clinicProfile.findMany()
     * 
     * // Get first 10 ClinicProfiles
     * const clinicProfiles = await prisma.clinicProfile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clinicProfileWithIdOnly = await prisma.clinicProfile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClinicProfileFindManyArgs>(args?: SelectSubset<T, ClinicProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClinicProfilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ClinicProfile.
     * @param {ClinicProfileCreateArgs} args - Arguments to create a ClinicProfile.
     * @example
     * // Create one ClinicProfile
     * const ClinicProfile = await prisma.clinicProfile.create({
     *   data: {
     *     // ... data to create a ClinicProfile
     *   }
     * })
     * 
     */
    create<T extends ClinicProfileCreateArgs>(args: SelectSubset<T, ClinicProfileCreateArgs<ExtArgs>>): Prisma__ClinicProfileClient<$Result.GetResult<Prisma.$ClinicProfilePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ClinicProfiles.
     * @param {ClinicProfileCreateManyArgs} args - Arguments to create many ClinicProfiles.
     * @example
     * // Create many ClinicProfiles
     * const clinicProfile = await prisma.clinicProfile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClinicProfileCreateManyArgs>(args?: SelectSubset<T, ClinicProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ClinicProfiles and returns the data saved in the database.
     * @param {ClinicProfileCreateManyAndReturnArgs} args - Arguments to create many ClinicProfiles.
     * @example
     * // Create many ClinicProfiles
     * const clinicProfile = await prisma.clinicProfile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ClinicProfiles and only return the `id`
     * const clinicProfileWithIdOnly = await prisma.clinicProfile.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClinicProfileCreateManyAndReturnArgs>(args?: SelectSubset<T, ClinicProfileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClinicProfilePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ClinicProfile.
     * @param {ClinicProfileDeleteArgs} args - Arguments to delete one ClinicProfile.
     * @example
     * // Delete one ClinicProfile
     * const ClinicProfile = await prisma.clinicProfile.delete({
     *   where: {
     *     // ... filter to delete one ClinicProfile
     *   }
     * })
     * 
     */
    delete<T extends ClinicProfileDeleteArgs>(args: SelectSubset<T, ClinicProfileDeleteArgs<ExtArgs>>): Prisma__ClinicProfileClient<$Result.GetResult<Prisma.$ClinicProfilePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ClinicProfile.
     * @param {ClinicProfileUpdateArgs} args - Arguments to update one ClinicProfile.
     * @example
     * // Update one ClinicProfile
     * const clinicProfile = await prisma.clinicProfile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClinicProfileUpdateArgs>(args: SelectSubset<T, ClinicProfileUpdateArgs<ExtArgs>>): Prisma__ClinicProfileClient<$Result.GetResult<Prisma.$ClinicProfilePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ClinicProfiles.
     * @param {ClinicProfileDeleteManyArgs} args - Arguments to filter ClinicProfiles to delete.
     * @example
     * // Delete a few ClinicProfiles
     * const { count } = await prisma.clinicProfile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClinicProfileDeleteManyArgs>(args?: SelectSubset<T, ClinicProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClinicProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ClinicProfiles
     * const clinicProfile = await prisma.clinicProfile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClinicProfileUpdateManyArgs>(args: SelectSubset<T, ClinicProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClinicProfiles and returns the data updated in the database.
     * @param {ClinicProfileUpdateManyAndReturnArgs} args - Arguments to update many ClinicProfiles.
     * @example
     * // Update many ClinicProfiles
     * const clinicProfile = await prisma.clinicProfile.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ClinicProfiles and only return the `id`
     * const clinicProfileWithIdOnly = await prisma.clinicProfile.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ClinicProfileUpdateManyAndReturnArgs>(args: SelectSubset<T, ClinicProfileUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClinicProfilePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ClinicProfile.
     * @param {ClinicProfileUpsertArgs} args - Arguments to update or create a ClinicProfile.
     * @example
     * // Update or create a ClinicProfile
     * const clinicProfile = await prisma.clinicProfile.upsert({
     *   create: {
     *     // ... data to create a ClinicProfile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ClinicProfile we want to update
     *   }
     * })
     */
    upsert<T extends ClinicProfileUpsertArgs>(args: SelectSubset<T, ClinicProfileUpsertArgs<ExtArgs>>): Prisma__ClinicProfileClient<$Result.GetResult<Prisma.$ClinicProfilePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ClinicProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicProfileCountArgs} args - Arguments to filter ClinicProfiles to count.
     * @example
     * // Count the number of ClinicProfiles
     * const count = await prisma.clinicProfile.count({
     *   where: {
     *     // ... the filter for the ClinicProfiles we want to count
     *   }
     * })
    **/
    count<T extends ClinicProfileCountArgs>(
      args?: Subset<T, ClinicProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClinicProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ClinicProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClinicProfileAggregateArgs>(args: Subset<T, ClinicProfileAggregateArgs>): Prisma.PrismaPromise<GetClinicProfileAggregateType<T>>

    /**
     * Group by ClinicProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClinicProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClinicProfileGroupByArgs['orderBy'] }
        : { orderBy?: ClinicProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClinicProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClinicProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ClinicProfile model
   */
  readonly fields: ClinicProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ClinicProfile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClinicProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    veterinarianProfile<T extends ClinicProfile$veterinarianProfileArgs<ExtArgs> = {}>(args?: Subset<T, ClinicProfile$veterinarianProfileArgs<ExtArgs>>): Prisma__VeterinarianProfileClient<$Result.GetResult<Prisma.$VeterinarianProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ClinicProfile model
   */
  interface ClinicProfileFieldRefs {
    readonly id: FieldRef<"ClinicProfile", 'String'>
    readonly name: FieldRef<"ClinicProfile", 'String'>
    readonly address: FieldRef<"ClinicProfile", 'String'>
    readonly siret: FieldRef<"ClinicProfile", 'String'>
    readonly phone: FieldRef<"ClinicProfile", 'String'>
    readonly description: FieldRef<"ClinicProfile", 'String'>
    readonly website: FieldRef<"ClinicProfile", 'String'>
    readonly userId: FieldRef<"ClinicProfile", 'String'>
    readonly veterinarianProfileId: FieldRef<"ClinicProfile", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ClinicProfile findUnique
   */
  export type ClinicProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicProfile
     */
    select?: ClinicProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicProfile
     */
    omit?: ClinicProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicProfileInclude<ExtArgs> | null
    /**
     * Filter, which ClinicProfile to fetch.
     */
    where: ClinicProfileWhereUniqueInput
  }

  /**
   * ClinicProfile findUniqueOrThrow
   */
  export type ClinicProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicProfile
     */
    select?: ClinicProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicProfile
     */
    omit?: ClinicProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicProfileInclude<ExtArgs> | null
    /**
     * Filter, which ClinicProfile to fetch.
     */
    where: ClinicProfileWhereUniqueInput
  }

  /**
   * ClinicProfile findFirst
   */
  export type ClinicProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicProfile
     */
    select?: ClinicProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicProfile
     */
    omit?: ClinicProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicProfileInclude<ExtArgs> | null
    /**
     * Filter, which ClinicProfile to fetch.
     */
    where?: ClinicProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClinicProfiles to fetch.
     */
    orderBy?: ClinicProfileOrderByWithRelationInput | ClinicProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClinicProfiles.
     */
    cursor?: ClinicProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClinicProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClinicProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClinicProfiles.
     */
    distinct?: ClinicProfileScalarFieldEnum | ClinicProfileScalarFieldEnum[]
  }

  /**
   * ClinicProfile findFirstOrThrow
   */
  export type ClinicProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicProfile
     */
    select?: ClinicProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicProfile
     */
    omit?: ClinicProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicProfileInclude<ExtArgs> | null
    /**
     * Filter, which ClinicProfile to fetch.
     */
    where?: ClinicProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClinicProfiles to fetch.
     */
    orderBy?: ClinicProfileOrderByWithRelationInput | ClinicProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClinicProfiles.
     */
    cursor?: ClinicProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClinicProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClinicProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClinicProfiles.
     */
    distinct?: ClinicProfileScalarFieldEnum | ClinicProfileScalarFieldEnum[]
  }

  /**
   * ClinicProfile findMany
   */
  export type ClinicProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicProfile
     */
    select?: ClinicProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicProfile
     */
    omit?: ClinicProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicProfileInclude<ExtArgs> | null
    /**
     * Filter, which ClinicProfiles to fetch.
     */
    where?: ClinicProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClinicProfiles to fetch.
     */
    orderBy?: ClinicProfileOrderByWithRelationInput | ClinicProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ClinicProfiles.
     */
    cursor?: ClinicProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClinicProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClinicProfiles.
     */
    skip?: number
    distinct?: ClinicProfileScalarFieldEnum | ClinicProfileScalarFieldEnum[]
  }

  /**
   * ClinicProfile create
   */
  export type ClinicProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicProfile
     */
    select?: ClinicProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicProfile
     */
    omit?: ClinicProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicProfileInclude<ExtArgs> | null
    /**
     * The data needed to create a ClinicProfile.
     */
    data: XOR<ClinicProfileCreateInput, ClinicProfileUncheckedCreateInput>
  }

  /**
   * ClinicProfile createMany
   */
  export type ClinicProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ClinicProfiles.
     */
    data: ClinicProfileCreateManyInput | ClinicProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ClinicProfile createManyAndReturn
   */
  export type ClinicProfileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicProfile
     */
    select?: ClinicProfileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicProfile
     */
    omit?: ClinicProfileOmit<ExtArgs> | null
    /**
     * The data used to create many ClinicProfiles.
     */
    data: ClinicProfileCreateManyInput | ClinicProfileCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicProfileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ClinicProfile update
   */
  export type ClinicProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicProfile
     */
    select?: ClinicProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicProfile
     */
    omit?: ClinicProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicProfileInclude<ExtArgs> | null
    /**
     * The data needed to update a ClinicProfile.
     */
    data: XOR<ClinicProfileUpdateInput, ClinicProfileUncheckedUpdateInput>
    /**
     * Choose, which ClinicProfile to update.
     */
    where: ClinicProfileWhereUniqueInput
  }

  /**
   * ClinicProfile updateMany
   */
  export type ClinicProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ClinicProfiles.
     */
    data: XOR<ClinicProfileUpdateManyMutationInput, ClinicProfileUncheckedUpdateManyInput>
    /**
     * Filter which ClinicProfiles to update
     */
    where?: ClinicProfileWhereInput
    /**
     * Limit how many ClinicProfiles to update.
     */
    limit?: number
  }

  /**
   * ClinicProfile updateManyAndReturn
   */
  export type ClinicProfileUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicProfile
     */
    select?: ClinicProfileSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicProfile
     */
    omit?: ClinicProfileOmit<ExtArgs> | null
    /**
     * The data used to update ClinicProfiles.
     */
    data: XOR<ClinicProfileUpdateManyMutationInput, ClinicProfileUncheckedUpdateManyInput>
    /**
     * Filter which ClinicProfiles to update
     */
    where?: ClinicProfileWhereInput
    /**
     * Limit how many ClinicProfiles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicProfileIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ClinicProfile upsert
   */
  export type ClinicProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicProfile
     */
    select?: ClinicProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicProfile
     */
    omit?: ClinicProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicProfileInclude<ExtArgs> | null
    /**
     * The filter to search for the ClinicProfile to update in case it exists.
     */
    where: ClinicProfileWhereUniqueInput
    /**
     * In case the ClinicProfile found by the `where` argument doesn't exist, create a new ClinicProfile with this data.
     */
    create: XOR<ClinicProfileCreateInput, ClinicProfileUncheckedCreateInput>
    /**
     * In case the ClinicProfile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClinicProfileUpdateInput, ClinicProfileUncheckedUpdateInput>
  }

  /**
   * ClinicProfile delete
   */
  export type ClinicProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicProfile
     */
    select?: ClinicProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicProfile
     */
    omit?: ClinicProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicProfileInclude<ExtArgs> | null
    /**
     * Filter which ClinicProfile to delete.
     */
    where: ClinicProfileWhereUniqueInput
  }

  /**
   * ClinicProfile deleteMany
   */
  export type ClinicProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClinicProfiles to delete
     */
    where?: ClinicProfileWhereInput
    /**
     * Limit how many ClinicProfiles to delete.
     */
    limit?: number
  }

  /**
   * ClinicProfile.veterinarianProfile
   */
  export type ClinicProfile$veterinarianProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VeterinarianProfile
     */
    select?: VeterinarianProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VeterinarianProfile
     */
    omit?: VeterinarianProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VeterinarianProfileInclude<ExtArgs> | null
    where?: VeterinarianProfileWhereInput
  }

  /**
   * ClinicProfile without action
   */
  export type ClinicProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicProfile
     */
    select?: ClinicProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicProfile
     */
    omit?: ClinicProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicProfileInclude<ExtArgs> | null
  }


  /**
   * Model SecretaryProfile
   */

  export type AggregateSecretaryProfile = {
    _count: SecretaryProfileCountAggregateOutputType | null
    _min: SecretaryProfileMinAggregateOutputType | null
    _max: SecretaryProfileMaxAggregateOutputType | null
  }

  export type SecretaryProfileMinAggregateOutputType = {
    id: string | null
    userId: string | null
    clinicId: string | null
  }

  export type SecretaryProfileMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    clinicId: string | null
  }

  export type SecretaryProfileCountAggregateOutputType = {
    id: number
    userId: number
    clinicId: number
    _all: number
  }


  export type SecretaryProfileMinAggregateInputType = {
    id?: true
    userId?: true
    clinicId?: true
  }

  export type SecretaryProfileMaxAggregateInputType = {
    id?: true
    userId?: true
    clinicId?: true
  }

  export type SecretaryProfileCountAggregateInputType = {
    id?: true
    userId?: true
    clinicId?: true
    _all?: true
  }

  export type SecretaryProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SecretaryProfile to aggregate.
     */
    where?: SecretaryProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SecretaryProfiles to fetch.
     */
    orderBy?: SecretaryProfileOrderByWithRelationInput | SecretaryProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SecretaryProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SecretaryProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SecretaryProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SecretaryProfiles
    **/
    _count?: true | SecretaryProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SecretaryProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SecretaryProfileMaxAggregateInputType
  }

  export type GetSecretaryProfileAggregateType<T extends SecretaryProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateSecretaryProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSecretaryProfile[P]>
      : GetScalarType<T[P], AggregateSecretaryProfile[P]>
  }




  export type SecretaryProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SecretaryProfileWhereInput
    orderBy?: SecretaryProfileOrderByWithAggregationInput | SecretaryProfileOrderByWithAggregationInput[]
    by: SecretaryProfileScalarFieldEnum[] | SecretaryProfileScalarFieldEnum
    having?: SecretaryProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SecretaryProfileCountAggregateInputType | true
    _min?: SecretaryProfileMinAggregateInputType
    _max?: SecretaryProfileMaxAggregateInputType
  }

  export type SecretaryProfileGroupByOutputType = {
    id: string
    userId: string
    clinicId: string
    _count: SecretaryProfileCountAggregateOutputType | null
    _min: SecretaryProfileMinAggregateOutputType | null
    _max: SecretaryProfileMaxAggregateOutputType | null
  }

  type GetSecretaryProfileGroupByPayload<T extends SecretaryProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SecretaryProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SecretaryProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SecretaryProfileGroupByOutputType[P]>
            : GetScalarType<T[P], SecretaryProfileGroupByOutputType[P]>
        }
      >
    >


  export type SecretaryProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    clinicId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    clinic?: boolean | ClientProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["secretaryProfile"]>

  export type SecretaryProfileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    clinicId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    clinic?: boolean | ClientProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["secretaryProfile"]>

  export type SecretaryProfileSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    clinicId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    clinic?: boolean | ClientProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["secretaryProfile"]>

  export type SecretaryProfileSelectScalar = {
    id?: boolean
    userId?: boolean
    clinicId?: boolean
  }

  export type SecretaryProfileOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "clinicId", ExtArgs["result"]["secretaryProfile"]>
  export type SecretaryProfileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    clinic?: boolean | ClientProfileDefaultArgs<ExtArgs>
  }
  export type SecretaryProfileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    clinic?: boolean | ClientProfileDefaultArgs<ExtArgs>
  }
  export type SecretaryProfileIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    clinic?: boolean | ClientProfileDefaultArgs<ExtArgs>
  }

  export type $SecretaryProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SecretaryProfile"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      clinic: Prisma.$ClientProfilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      clinicId: string
    }, ExtArgs["result"]["secretaryProfile"]>
    composites: {}
  }

  type SecretaryProfileGetPayload<S extends boolean | null | undefined | SecretaryProfileDefaultArgs> = $Result.GetResult<Prisma.$SecretaryProfilePayload, S>

  type SecretaryProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SecretaryProfileFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SecretaryProfileCountAggregateInputType | true
    }

  export interface SecretaryProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SecretaryProfile'], meta: { name: 'SecretaryProfile' } }
    /**
     * Find zero or one SecretaryProfile that matches the filter.
     * @param {SecretaryProfileFindUniqueArgs} args - Arguments to find a SecretaryProfile
     * @example
     * // Get one SecretaryProfile
     * const secretaryProfile = await prisma.secretaryProfile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SecretaryProfileFindUniqueArgs>(args: SelectSubset<T, SecretaryProfileFindUniqueArgs<ExtArgs>>): Prisma__SecretaryProfileClient<$Result.GetResult<Prisma.$SecretaryProfilePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SecretaryProfile that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SecretaryProfileFindUniqueOrThrowArgs} args - Arguments to find a SecretaryProfile
     * @example
     * // Get one SecretaryProfile
     * const secretaryProfile = await prisma.secretaryProfile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SecretaryProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, SecretaryProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SecretaryProfileClient<$Result.GetResult<Prisma.$SecretaryProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SecretaryProfile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecretaryProfileFindFirstArgs} args - Arguments to find a SecretaryProfile
     * @example
     * // Get one SecretaryProfile
     * const secretaryProfile = await prisma.secretaryProfile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SecretaryProfileFindFirstArgs>(args?: SelectSubset<T, SecretaryProfileFindFirstArgs<ExtArgs>>): Prisma__SecretaryProfileClient<$Result.GetResult<Prisma.$SecretaryProfilePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SecretaryProfile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecretaryProfileFindFirstOrThrowArgs} args - Arguments to find a SecretaryProfile
     * @example
     * // Get one SecretaryProfile
     * const secretaryProfile = await prisma.secretaryProfile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SecretaryProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, SecretaryProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__SecretaryProfileClient<$Result.GetResult<Prisma.$SecretaryProfilePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SecretaryProfiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecretaryProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SecretaryProfiles
     * const secretaryProfiles = await prisma.secretaryProfile.findMany()
     * 
     * // Get first 10 SecretaryProfiles
     * const secretaryProfiles = await prisma.secretaryProfile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const secretaryProfileWithIdOnly = await prisma.secretaryProfile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SecretaryProfileFindManyArgs>(args?: SelectSubset<T, SecretaryProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SecretaryProfilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SecretaryProfile.
     * @param {SecretaryProfileCreateArgs} args - Arguments to create a SecretaryProfile.
     * @example
     * // Create one SecretaryProfile
     * const SecretaryProfile = await prisma.secretaryProfile.create({
     *   data: {
     *     // ... data to create a SecretaryProfile
     *   }
     * })
     * 
     */
    create<T extends SecretaryProfileCreateArgs>(args: SelectSubset<T, SecretaryProfileCreateArgs<ExtArgs>>): Prisma__SecretaryProfileClient<$Result.GetResult<Prisma.$SecretaryProfilePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SecretaryProfiles.
     * @param {SecretaryProfileCreateManyArgs} args - Arguments to create many SecretaryProfiles.
     * @example
     * // Create many SecretaryProfiles
     * const secretaryProfile = await prisma.secretaryProfile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SecretaryProfileCreateManyArgs>(args?: SelectSubset<T, SecretaryProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SecretaryProfiles and returns the data saved in the database.
     * @param {SecretaryProfileCreateManyAndReturnArgs} args - Arguments to create many SecretaryProfiles.
     * @example
     * // Create many SecretaryProfiles
     * const secretaryProfile = await prisma.secretaryProfile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SecretaryProfiles and only return the `id`
     * const secretaryProfileWithIdOnly = await prisma.secretaryProfile.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SecretaryProfileCreateManyAndReturnArgs>(args?: SelectSubset<T, SecretaryProfileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SecretaryProfilePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SecretaryProfile.
     * @param {SecretaryProfileDeleteArgs} args - Arguments to delete one SecretaryProfile.
     * @example
     * // Delete one SecretaryProfile
     * const SecretaryProfile = await prisma.secretaryProfile.delete({
     *   where: {
     *     // ... filter to delete one SecretaryProfile
     *   }
     * })
     * 
     */
    delete<T extends SecretaryProfileDeleteArgs>(args: SelectSubset<T, SecretaryProfileDeleteArgs<ExtArgs>>): Prisma__SecretaryProfileClient<$Result.GetResult<Prisma.$SecretaryProfilePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SecretaryProfile.
     * @param {SecretaryProfileUpdateArgs} args - Arguments to update one SecretaryProfile.
     * @example
     * // Update one SecretaryProfile
     * const secretaryProfile = await prisma.secretaryProfile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SecretaryProfileUpdateArgs>(args: SelectSubset<T, SecretaryProfileUpdateArgs<ExtArgs>>): Prisma__SecretaryProfileClient<$Result.GetResult<Prisma.$SecretaryProfilePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SecretaryProfiles.
     * @param {SecretaryProfileDeleteManyArgs} args - Arguments to filter SecretaryProfiles to delete.
     * @example
     * // Delete a few SecretaryProfiles
     * const { count } = await prisma.secretaryProfile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SecretaryProfileDeleteManyArgs>(args?: SelectSubset<T, SecretaryProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SecretaryProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecretaryProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SecretaryProfiles
     * const secretaryProfile = await prisma.secretaryProfile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SecretaryProfileUpdateManyArgs>(args: SelectSubset<T, SecretaryProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SecretaryProfiles and returns the data updated in the database.
     * @param {SecretaryProfileUpdateManyAndReturnArgs} args - Arguments to update many SecretaryProfiles.
     * @example
     * // Update many SecretaryProfiles
     * const secretaryProfile = await prisma.secretaryProfile.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SecretaryProfiles and only return the `id`
     * const secretaryProfileWithIdOnly = await prisma.secretaryProfile.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SecretaryProfileUpdateManyAndReturnArgs>(args: SelectSubset<T, SecretaryProfileUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SecretaryProfilePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SecretaryProfile.
     * @param {SecretaryProfileUpsertArgs} args - Arguments to update or create a SecretaryProfile.
     * @example
     * // Update or create a SecretaryProfile
     * const secretaryProfile = await prisma.secretaryProfile.upsert({
     *   create: {
     *     // ... data to create a SecretaryProfile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SecretaryProfile we want to update
     *   }
     * })
     */
    upsert<T extends SecretaryProfileUpsertArgs>(args: SelectSubset<T, SecretaryProfileUpsertArgs<ExtArgs>>): Prisma__SecretaryProfileClient<$Result.GetResult<Prisma.$SecretaryProfilePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SecretaryProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecretaryProfileCountArgs} args - Arguments to filter SecretaryProfiles to count.
     * @example
     * // Count the number of SecretaryProfiles
     * const count = await prisma.secretaryProfile.count({
     *   where: {
     *     // ... the filter for the SecretaryProfiles we want to count
     *   }
     * })
    **/
    count<T extends SecretaryProfileCountArgs>(
      args?: Subset<T, SecretaryProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SecretaryProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SecretaryProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecretaryProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SecretaryProfileAggregateArgs>(args: Subset<T, SecretaryProfileAggregateArgs>): Prisma.PrismaPromise<GetSecretaryProfileAggregateType<T>>

    /**
     * Group by SecretaryProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecretaryProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SecretaryProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SecretaryProfileGroupByArgs['orderBy'] }
        : { orderBy?: SecretaryProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SecretaryProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSecretaryProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SecretaryProfile model
   */
  readonly fields: SecretaryProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SecretaryProfile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SecretaryProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    clinic<T extends ClientProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientProfileDefaultArgs<ExtArgs>>): Prisma__ClientProfileClient<$Result.GetResult<Prisma.$ClientProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SecretaryProfile model
   */
  interface SecretaryProfileFieldRefs {
    readonly id: FieldRef<"SecretaryProfile", 'String'>
    readonly userId: FieldRef<"SecretaryProfile", 'String'>
    readonly clinicId: FieldRef<"SecretaryProfile", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SecretaryProfile findUnique
   */
  export type SecretaryProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecretaryProfile
     */
    select?: SecretaryProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecretaryProfile
     */
    omit?: SecretaryProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecretaryProfileInclude<ExtArgs> | null
    /**
     * Filter, which SecretaryProfile to fetch.
     */
    where: SecretaryProfileWhereUniqueInput
  }

  /**
   * SecretaryProfile findUniqueOrThrow
   */
  export type SecretaryProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecretaryProfile
     */
    select?: SecretaryProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecretaryProfile
     */
    omit?: SecretaryProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecretaryProfileInclude<ExtArgs> | null
    /**
     * Filter, which SecretaryProfile to fetch.
     */
    where: SecretaryProfileWhereUniqueInput
  }

  /**
   * SecretaryProfile findFirst
   */
  export type SecretaryProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecretaryProfile
     */
    select?: SecretaryProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecretaryProfile
     */
    omit?: SecretaryProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecretaryProfileInclude<ExtArgs> | null
    /**
     * Filter, which SecretaryProfile to fetch.
     */
    where?: SecretaryProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SecretaryProfiles to fetch.
     */
    orderBy?: SecretaryProfileOrderByWithRelationInput | SecretaryProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SecretaryProfiles.
     */
    cursor?: SecretaryProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SecretaryProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SecretaryProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SecretaryProfiles.
     */
    distinct?: SecretaryProfileScalarFieldEnum | SecretaryProfileScalarFieldEnum[]
  }

  /**
   * SecretaryProfile findFirstOrThrow
   */
  export type SecretaryProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecretaryProfile
     */
    select?: SecretaryProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecretaryProfile
     */
    omit?: SecretaryProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecretaryProfileInclude<ExtArgs> | null
    /**
     * Filter, which SecretaryProfile to fetch.
     */
    where?: SecretaryProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SecretaryProfiles to fetch.
     */
    orderBy?: SecretaryProfileOrderByWithRelationInput | SecretaryProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SecretaryProfiles.
     */
    cursor?: SecretaryProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SecretaryProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SecretaryProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SecretaryProfiles.
     */
    distinct?: SecretaryProfileScalarFieldEnum | SecretaryProfileScalarFieldEnum[]
  }

  /**
   * SecretaryProfile findMany
   */
  export type SecretaryProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecretaryProfile
     */
    select?: SecretaryProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecretaryProfile
     */
    omit?: SecretaryProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecretaryProfileInclude<ExtArgs> | null
    /**
     * Filter, which SecretaryProfiles to fetch.
     */
    where?: SecretaryProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SecretaryProfiles to fetch.
     */
    orderBy?: SecretaryProfileOrderByWithRelationInput | SecretaryProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SecretaryProfiles.
     */
    cursor?: SecretaryProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SecretaryProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SecretaryProfiles.
     */
    skip?: number
    distinct?: SecretaryProfileScalarFieldEnum | SecretaryProfileScalarFieldEnum[]
  }

  /**
   * SecretaryProfile create
   */
  export type SecretaryProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecretaryProfile
     */
    select?: SecretaryProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecretaryProfile
     */
    omit?: SecretaryProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecretaryProfileInclude<ExtArgs> | null
    /**
     * The data needed to create a SecretaryProfile.
     */
    data: XOR<SecretaryProfileCreateInput, SecretaryProfileUncheckedCreateInput>
  }

  /**
   * SecretaryProfile createMany
   */
  export type SecretaryProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SecretaryProfiles.
     */
    data: SecretaryProfileCreateManyInput | SecretaryProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SecretaryProfile createManyAndReturn
   */
  export type SecretaryProfileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecretaryProfile
     */
    select?: SecretaryProfileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SecretaryProfile
     */
    omit?: SecretaryProfileOmit<ExtArgs> | null
    /**
     * The data used to create many SecretaryProfiles.
     */
    data: SecretaryProfileCreateManyInput | SecretaryProfileCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecretaryProfileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SecretaryProfile update
   */
  export type SecretaryProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecretaryProfile
     */
    select?: SecretaryProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecretaryProfile
     */
    omit?: SecretaryProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecretaryProfileInclude<ExtArgs> | null
    /**
     * The data needed to update a SecretaryProfile.
     */
    data: XOR<SecretaryProfileUpdateInput, SecretaryProfileUncheckedUpdateInput>
    /**
     * Choose, which SecretaryProfile to update.
     */
    where: SecretaryProfileWhereUniqueInput
  }

  /**
   * SecretaryProfile updateMany
   */
  export type SecretaryProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SecretaryProfiles.
     */
    data: XOR<SecretaryProfileUpdateManyMutationInput, SecretaryProfileUncheckedUpdateManyInput>
    /**
     * Filter which SecretaryProfiles to update
     */
    where?: SecretaryProfileWhereInput
    /**
     * Limit how many SecretaryProfiles to update.
     */
    limit?: number
  }

  /**
   * SecretaryProfile updateManyAndReturn
   */
  export type SecretaryProfileUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecretaryProfile
     */
    select?: SecretaryProfileSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SecretaryProfile
     */
    omit?: SecretaryProfileOmit<ExtArgs> | null
    /**
     * The data used to update SecretaryProfiles.
     */
    data: XOR<SecretaryProfileUpdateManyMutationInput, SecretaryProfileUncheckedUpdateManyInput>
    /**
     * Filter which SecretaryProfiles to update
     */
    where?: SecretaryProfileWhereInput
    /**
     * Limit how many SecretaryProfiles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecretaryProfileIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SecretaryProfile upsert
   */
  export type SecretaryProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecretaryProfile
     */
    select?: SecretaryProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecretaryProfile
     */
    omit?: SecretaryProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecretaryProfileInclude<ExtArgs> | null
    /**
     * The filter to search for the SecretaryProfile to update in case it exists.
     */
    where: SecretaryProfileWhereUniqueInput
    /**
     * In case the SecretaryProfile found by the `where` argument doesn't exist, create a new SecretaryProfile with this data.
     */
    create: XOR<SecretaryProfileCreateInput, SecretaryProfileUncheckedCreateInput>
    /**
     * In case the SecretaryProfile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SecretaryProfileUpdateInput, SecretaryProfileUncheckedUpdateInput>
  }

  /**
   * SecretaryProfile delete
   */
  export type SecretaryProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecretaryProfile
     */
    select?: SecretaryProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecretaryProfile
     */
    omit?: SecretaryProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecretaryProfileInclude<ExtArgs> | null
    /**
     * Filter which SecretaryProfile to delete.
     */
    where: SecretaryProfileWhereUniqueInput
  }

  /**
   * SecretaryProfile deleteMany
   */
  export type SecretaryProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SecretaryProfiles to delete
     */
    where?: SecretaryProfileWhereInput
    /**
     * Limit how many SecretaryProfiles to delete.
     */
    limit?: number
  }

  /**
   * SecretaryProfile without action
   */
  export type SecretaryProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecretaryProfile
     */
    select?: SecretaryProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecretaryProfile
     */
    omit?: SecretaryProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecretaryProfileInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const ClientPetScalarFieldEnum: {
    id: 'id',
    name: 'name',
    dateOfBirth: 'dateOfBirth',
    description: 'description',
    activity: 'activity',
    attendingVeterinarianId: 'attendingVeterinarianId',
    clientId: 'clientId',
    raceId: 'raceId'
  };

  export type ClientPetScalarFieldEnum = (typeof ClientPetScalarFieldEnum)[keyof typeof ClientPetScalarFieldEnum]


  export const PetScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    name: 'name',
    picture: 'picture'
  };

  export type PetScalarFieldEnum = (typeof PetScalarFieldEnum)[keyof typeof PetScalarFieldEnum]


  export const RaceScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    name: 'name',
    picture: 'picture',
    petId: 'petId'
  };

  export type RaceScalarFieldEnum = (typeof RaceScalarFieldEnum)[keyof typeof RaceScalarFieldEnum]


  export const VaccineScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    name: 'name',
    description: 'description',
    recommendedAge: 'recommendedAge',
    boosterInterval: 'boosterInterval',
    mandatoryCountry: 'mandatoryCountry',
    recommendedCountry: 'recommendedCountry',
    petId: 'petId'
  };

  export type VaccineScalarFieldEnum = (typeof VaccineScalarFieldEnum)[keyof typeof VaccineScalarFieldEnum]


  export const PersonalPetVaccineScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    clientPetId: 'clientPetId',
    vaccineId: 'vaccineId',
    mettingId: 'mettingId'
  };

  export type PersonalPetVaccineScalarFieldEnum = (typeof PersonalPetVaccineScalarFieldEnum)[keyof typeof PersonalPetVaccineScalarFieldEnum]


  export const MettingScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    date: 'date',
    duration: 'duration',
    description: 'description',
    petWeight: 'petWeight',
    petSize: 'petSize',
    clientPetId: 'clientPetId',
    veterinarianId: 'veterinarianId'
  };

  export type MettingScalarFieldEnum = (typeof MettingScalarFieldEnum)[keyof typeof MettingScalarFieldEnum]


  export const ProductScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    name: 'name',
    description: 'description',
    qrCode: 'qrCode',
    websiteUrl: 'websiteUrl',
    picture: 'picture',
    brandId: 'brandId'
  };

  export type ProductScalarFieldEnum = (typeof ProductScalarFieldEnum)[keyof typeof ProductScalarFieldEnum]


  export const FoodScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    caloriesPer100: 'caloriesPer100',
    proteinPer100: 'proteinPer100',
    fatPercentage: 'fatPercentage',
    fiberPercentage: 'fiberPercentage',
    moisturePercentage: 'moisturePercentage',
    type: 'type',
    productId: 'productId'
  };

  export type FoodScalarFieldEnum = (typeof FoodScalarFieldEnum)[keyof typeof FoodScalarFieldEnum]


  export const BrandScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    name: 'name',
    logo: 'logo'
  };

  export type BrandScalarFieldEnum = (typeof BrandScalarFieldEnum)[keyof typeof BrandScalarFieldEnum]


  export const ClinicProductScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    stock: 'stock',
    minimumRequired: 'minimumRequired',
    clinicId: 'clinicId',
    productId: 'productId'
  };

  export type ClinicProductScalarFieldEnum = (typeof ClinicProductScalarFieldEnum)[keyof typeof ClinicProductScalarFieldEnum]


  export const FoodPetScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    type: 'type',
    dateStart: 'dateStart',
    dateEnd: 'dateEnd',
    quantity: 'quantity',
    hours: 'hours',
    foodId: 'foodId',
    clientPetId: 'clientPetId'
  };

  export type FoodPetScalarFieldEnum = (typeof FoodPetScalarFieldEnum)[keyof typeof FoodPetScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    role: 'role',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    firstname: 'firstname',
    lastname: 'lastname',
    password: 'password',
    picture: 'picture'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const ClientProfileScalarFieldEnum: {
    id: 'id',
    dateOfBirth: 'dateOfBirth',
    address: 'address',
    phone: 'phone',
    userId: 'userId'
  };

  export type ClientProfileScalarFieldEnum = (typeof ClientProfileScalarFieldEnum)[keyof typeof ClientProfileScalarFieldEnum]


  export const VeterinarianProfileScalarFieldEnum: {
    id: 'id',
    licenseNumber: 'licenseNumber',
    specialty: 'specialty',
    yearsExperience: 'yearsExperience',
    bio: 'bio',
    clinicId: 'clinicId',
    userId: 'userId'
  };

  export type VeterinarianProfileScalarFieldEnum = (typeof VeterinarianProfileScalarFieldEnum)[keyof typeof VeterinarianProfileScalarFieldEnum]


  export const ClinicProfileScalarFieldEnum: {
    id: 'id',
    name: 'name',
    address: 'address',
    siret: 'siret',
    phone: 'phone',
    description: 'description',
    website: 'website',
    userId: 'userId',
    veterinarianProfileId: 'veterinarianProfileId'
  };

  export type ClinicProfileScalarFieldEnum = (typeof ClinicProfileScalarFieldEnum)[keyof typeof ClinicProfileScalarFieldEnum]


  export const SecretaryProfileScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    clinicId: 'clinicId'
  };

  export type SecretaryProfileScalarFieldEnum = (typeof SecretaryProfileScalarFieldEnum)[keyof typeof SecretaryProfileScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'FoodType'
   */
  export type EnumFoodTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FoodType'>
    


  /**
   * Reference to a field of type 'FoodType[]'
   */
  export type ListEnumFoodTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FoodType[]'>
    


  /**
   * Reference to a field of type 'FoodPetDay'
   */
  export type EnumFoodPetDayFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FoodPetDay'>
    


  /**
   * Reference to a field of type 'FoodPetDay[]'
   */
  export type ListEnumFoodPetDayFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FoodPetDay[]'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type ClientPetWhereInput = {
    AND?: ClientPetWhereInput | ClientPetWhereInput[]
    OR?: ClientPetWhereInput[]
    NOT?: ClientPetWhereInput | ClientPetWhereInput[]
    id?: StringFilter<"ClientPet"> | string
    name?: StringFilter<"ClientPet"> | string
    dateOfBirth?: DateTimeFilter<"ClientPet"> | Date | string
    description?: StringNullableFilter<"ClientPet"> | string | null
    activity?: IntNullableFilter<"ClientPet"> | number | null
    attendingVeterinarianId?: StringNullableFilter<"ClientPet"> | string | null
    clientId?: StringFilter<"ClientPet"> | string
    raceId?: StringFilter<"ClientPet"> | string
    attendingVeterinarian?: XOR<VeterinarianProfileNullableScalarRelationFilter, VeterinarianProfileWhereInput> | null
    client?: XOR<ClientProfileScalarRelationFilter, ClientProfileWhereInput>
    race?: XOR<RaceScalarRelationFilter, RaceWhereInput>
    personalPetVaccine?: PersonalPetVaccineListRelationFilter
    metting?: MettingListRelationFilter
    foodPets?: FoodPetListRelationFilter
  }

  export type ClientPetOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    dateOfBirth?: SortOrder
    description?: SortOrderInput | SortOrder
    activity?: SortOrderInput | SortOrder
    attendingVeterinarianId?: SortOrderInput | SortOrder
    clientId?: SortOrder
    raceId?: SortOrder
    attendingVeterinarian?: VeterinarianProfileOrderByWithRelationInput
    client?: ClientProfileOrderByWithRelationInput
    race?: RaceOrderByWithRelationInput
    personalPetVaccine?: PersonalPetVaccineOrderByRelationAggregateInput
    metting?: MettingOrderByRelationAggregateInput
    foodPets?: FoodPetOrderByRelationAggregateInput
  }

  export type ClientPetWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ClientPetWhereInput | ClientPetWhereInput[]
    OR?: ClientPetWhereInput[]
    NOT?: ClientPetWhereInput | ClientPetWhereInput[]
    name?: StringFilter<"ClientPet"> | string
    dateOfBirth?: DateTimeFilter<"ClientPet"> | Date | string
    description?: StringNullableFilter<"ClientPet"> | string | null
    activity?: IntNullableFilter<"ClientPet"> | number | null
    attendingVeterinarianId?: StringNullableFilter<"ClientPet"> | string | null
    clientId?: StringFilter<"ClientPet"> | string
    raceId?: StringFilter<"ClientPet"> | string
    attendingVeterinarian?: XOR<VeterinarianProfileNullableScalarRelationFilter, VeterinarianProfileWhereInput> | null
    client?: XOR<ClientProfileScalarRelationFilter, ClientProfileWhereInput>
    race?: XOR<RaceScalarRelationFilter, RaceWhereInput>
    personalPetVaccine?: PersonalPetVaccineListRelationFilter
    metting?: MettingListRelationFilter
    foodPets?: FoodPetListRelationFilter
  }, "id">

  export type ClientPetOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    dateOfBirth?: SortOrder
    description?: SortOrderInput | SortOrder
    activity?: SortOrderInput | SortOrder
    attendingVeterinarianId?: SortOrderInput | SortOrder
    clientId?: SortOrder
    raceId?: SortOrder
    _count?: ClientPetCountOrderByAggregateInput
    _avg?: ClientPetAvgOrderByAggregateInput
    _max?: ClientPetMaxOrderByAggregateInput
    _min?: ClientPetMinOrderByAggregateInput
    _sum?: ClientPetSumOrderByAggregateInput
  }

  export type ClientPetScalarWhereWithAggregatesInput = {
    AND?: ClientPetScalarWhereWithAggregatesInput | ClientPetScalarWhereWithAggregatesInput[]
    OR?: ClientPetScalarWhereWithAggregatesInput[]
    NOT?: ClientPetScalarWhereWithAggregatesInput | ClientPetScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ClientPet"> | string
    name?: StringWithAggregatesFilter<"ClientPet"> | string
    dateOfBirth?: DateTimeWithAggregatesFilter<"ClientPet"> | Date | string
    description?: StringNullableWithAggregatesFilter<"ClientPet"> | string | null
    activity?: IntNullableWithAggregatesFilter<"ClientPet"> | number | null
    attendingVeterinarianId?: StringNullableWithAggregatesFilter<"ClientPet"> | string | null
    clientId?: StringWithAggregatesFilter<"ClientPet"> | string
    raceId?: StringWithAggregatesFilter<"ClientPet"> | string
  }

  export type PetWhereInput = {
    AND?: PetWhereInput | PetWhereInput[]
    OR?: PetWhereInput[]
    NOT?: PetWhereInput | PetWhereInput[]
    id?: StringFilter<"Pet"> | string
    createdAt?: DateTimeFilter<"Pet"> | Date | string
    updatedAt?: DateTimeFilter<"Pet"> | Date | string
    name?: StringFilter<"Pet"> | string
    picture?: StringNullableFilter<"Pet"> | string | null
    races?: RaceListRelationFilter
    vaccine?: VaccineListRelationFilter
  }

  export type PetOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    picture?: SortOrderInput | SortOrder
    races?: RaceOrderByRelationAggregateInput
    vaccine?: VaccineOrderByRelationAggregateInput
  }

  export type PetWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PetWhereInput | PetWhereInput[]
    OR?: PetWhereInput[]
    NOT?: PetWhereInput | PetWhereInput[]
    createdAt?: DateTimeFilter<"Pet"> | Date | string
    updatedAt?: DateTimeFilter<"Pet"> | Date | string
    name?: StringFilter<"Pet"> | string
    picture?: StringNullableFilter<"Pet"> | string | null
    races?: RaceListRelationFilter
    vaccine?: VaccineListRelationFilter
  }, "id">

  export type PetOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    picture?: SortOrderInput | SortOrder
    _count?: PetCountOrderByAggregateInput
    _max?: PetMaxOrderByAggregateInput
    _min?: PetMinOrderByAggregateInput
  }

  export type PetScalarWhereWithAggregatesInput = {
    AND?: PetScalarWhereWithAggregatesInput | PetScalarWhereWithAggregatesInput[]
    OR?: PetScalarWhereWithAggregatesInput[]
    NOT?: PetScalarWhereWithAggregatesInput | PetScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Pet"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Pet"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Pet"> | Date | string
    name?: StringWithAggregatesFilter<"Pet"> | string
    picture?: StringNullableWithAggregatesFilter<"Pet"> | string | null
  }

  export type RaceWhereInput = {
    AND?: RaceWhereInput | RaceWhereInput[]
    OR?: RaceWhereInput[]
    NOT?: RaceWhereInput | RaceWhereInput[]
    id?: StringFilter<"Race"> | string
    createdAt?: DateTimeFilter<"Race"> | Date | string
    updatedAt?: DateTimeFilter<"Race"> | Date | string
    name?: StringFilter<"Race"> | string
    picture?: StringNullableFilter<"Race"> | string | null
    petId?: StringFilter<"Race"> | string
    pet?: XOR<PetScalarRelationFilter, PetWhereInput>
    clientPet?: ClientPetListRelationFilter
  }

  export type RaceOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    picture?: SortOrderInput | SortOrder
    petId?: SortOrder
    pet?: PetOrderByWithRelationInput
    clientPet?: ClientPetOrderByRelationAggregateInput
  }

  export type RaceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RaceWhereInput | RaceWhereInput[]
    OR?: RaceWhereInput[]
    NOT?: RaceWhereInput | RaceWhereInput[]
    createdAt?: DateTimeFilter<"Race"> | Date | string
    updatedAt?: DateTimeFilter<"Race"> | Date | string
    name?: StringFilter<"Race"> | string
    picture?: StringNullableFilter<"Race"> | string | null
    petId?: StringFilter<"Race"> | string
    pet?: XOR<PetScalarRelationFilter, PetWhereInput>
    clientPet?: ClientPetListRelationFilter
  }, "id">

  export type RaceOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    picture?: SortOrderInput | SortOrder
    petId?: SortOrder
    _count?: RaceCountOrderByAggregateInput
    _max?: RaceMaxOrderByAggregateInput
    _min?: RaceMinOrderByAggregateInput
  }

  export type RaceScalarWhereWithAggregatesInput = {
    AND?: RaceScalarWhereWithAggregatesInput | RaceScalarWhereWithAggregatesInput[]
    OR?: RaceScalarWhereWithAggregatesInput[]
    NOT?: RaceScalarWhereWithAggregatesInput | RaceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Race"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Race"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Race"> | Date | string
    name?: StringWithAggregatesFilter<"Race"> | string
    picture?: StringNullableWithAggregatesFilter<"Race"> | string | null
    petId?: StringWithAggregatesFilter<"Race"> | string
  }

  export type VaccineWhereInput = {
    AND?: VaccineWhereInput | VaccineWhereInput[]
    OR?: VaccineWhereInput[]
    NOT?: VaccineWhereInput | VaccineWhereInput[]
    id?: StringFilter<"Vaccine"> | string
    createdAt?: DateTimeFilter<"Vaccine"> | Date | string
    updatedAt?: DateTimeFilter<"Vaccine"> | Date | string
    name?: StringFilter<"Vaccine"> | string
    description?: StringNullableFilter<"Vaccine"> | string | null
    recommendedAge?: IntFilter<"Vaccine"> | number
    boosterInterval?: IntFilter<"Vaccine"> | number
    mandatoryCountry?: JsonNullableFilter<"Vaccine">
    recommendedCountry?: JsonNullableFilter<"Vaccine">
    petId?: StringFilter<"Vaccine"> | string
    pet?: XOR<PetScalarRelationFilter, PetWhereInput>
    personalPetVaccine?: PersonalPetVaccineListRelationFilter
  }

  export type VaccineOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    recommendedAge?: SortOrder
    boosterInterval?: SortOrder
    mandatoryCountry?: SortOrderInput | SortOrder
    recommendedCountry?: SortOrderInput | SortOrder
    petId?: SortOrder
    pet?: PetOrderByWithRelationInput
    personalPetVaccine?: PersonalPetVaccineOrderByRelationAggregateInput
  }

  export type VaccineWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VaccineWhereInput | VaccineWhereInput[]
    OR?: VaccineWhereInput[]
    NOT?: VaccineWhereInput | VaccineWhereInput[]
    createdAt?: DateTimeFilter<"Vaccine"> | Date | string
    updatedAt?: DateTimeFilter<"Vaccine"> | Date | string
    name?: StringFilter<"Vaccine"> | string
    description?: StringNullableFilter<"Vaccine"> | string | null
    recommendedAge?: IntFilter<"Vaccine"> | number
    boosterInterval?: IntFilter<"Vaccine"> | number
    mandatoryCountry?: JsonNullableFilter<"Vaccine">
    recommendedCountry?: JsonNullableFilter<"Vaccine">
    petId?: StringFilter<"Vaccine"> | string
    pet?: XOR<PetScalarRelationFilter, PetWhereInput>
    personalPetVaccine?: PersonalPetVaccineListRelationFilter
  }, "id">

  export type VaccineOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    recommendedAge?: SortOrder
    boosterInterval?: SortOrder
    mandatoryCountry?: SortOrderInput | SortOrder
    recommendedCountry?: SortOrderInput | SortOrder
    petId?: SortOrder
    _count?: VaccineCountOrderByAggregateInput
    _avg?: VaccineAvgOrderByAggregateInput
    _max?: VaccineMaxOrderByAggregateInput
    _min?: VaccineMinOrderByAggregateInput
    _sum?: VaccineSumOrderByAggregateInput
  }

  export type VaccineScalarWhereWithAggregatesInput = {
    AND?: VaccineScalarWhereWithAggregatesInput | VaccineScalarWhereWithAggregatesInput[]
    OR?: VaccineScalarWhereWithAggregatesInput[]
    NOT?: VaccineScalarWhereWithAggregatesInput | VaccineScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Vaccine"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Vaccine"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Vaccine"> | Date | string
    name?: StringWithAggregatesFilter<"Vaccine"> | string
    description?: StringNullableWithAggregatesFilter<"Vaccine"> | string | null
    recommendedAge?: IntWithAggregatesFilter<"Vaccine"> | number
    boosterInterval?: IntWithAggregatesFilter<"Vaccine"> | number
    mandatoryCountry?: JsonNullableWithAggregatesFilter<"Vaccine">
    recommendedCountry?: JsonNullableWithAggregatesFilter<"Vaccine">
    petId?: StringWithAggregatesFilter<"Vaccine"> | string
  }

  export type PersonalPetVaccineWhereInput = {
    AND?: PersonalPetVaccineWhereInput | PersonalPetVaccineWhereInput[]
    OR?: PersonalPetVaccineWhereInput[]
    NOT?: PersonalPetVaccineWhereInput | PersonalPetVaccineWhereInput[]
    id?: StringFilter<"PersonalPetVaccine"> | string
    createdAt?: DateTimeFilter<"PersonalPetVaccine"> | Date | string
    updatedAt?: DateTimeFilter<"PersonalPetVaccine"> | Date | string
    clientPetId?: StringFilter<"PersonalPetVaccine"> | string
    vaccineId?: StringFilter<"PersonalPetVaccine"> | string
    mettingId?: StringNullableFilter<"PersonalPetVaccine"> | string | null
    clientPet?: XOR<ClientPetScalarRelationFilter, ClientPetWhereInput>
    vaccine?: XOR<VaccineScalarRelationFilter, VaccineWhereInput>
    metting?: XOR<MettingNullableScalarRelationFilter, MettingWhereInput> | null
  }

  export type PersonalPetVaccineOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clientPetId?: SortOrder
    vaccineId?: SortOrder
    mettingId?: SortOrderInput | SortOrder
    clientPet?: ClientPetOrderByWithRelationInput
    vaccine?: VaccineOrderByWithRelationInput
    metting?: MettingOrderByWithRelationInput
  }

  export type PersonalPetVaccineWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PersonalPetVaccineWhereInput | PersonalPetVaccineWhereInput[]
    OR?: PersonalPetVaccineWhereInput[]
    NOT?: PersonalPetVaccineWhereInput | PersonalPetVaccineWhereInput[]
    createdAt?: DateTimeFilter<"PersonalPetVaccine"> | Date | string
    updatedAt?: DateTimeFilter<"PersonalPetVaccine"> | Date | string
    clientPetId?: StringFilter<"PersonalPetVaccine"> | string
    vaccineId?: StringFilter<"PersonalPetVaccine"> | string
    mettingId?: StringNullableFilter<"PersonalPetVaccine"> | string | null
    clientPet?: XOR<ClientPetScalarRelationFilter, ClientPetWhereInput>
    vaccine?: XOR<VaccineScalarRelationFilter, VaccineWhereInput>
    metting?: XOR<MettingNullableScalarRelationFilter, MettingWhereInput> | null
  }, "id">

  export type PersonalPetVaccineOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clientPetId?: SortOrder
    vaccineId?: SortOrder
    mettingId?: SortOrderInput | SortOrder
    _count?: PersonalPetVaccineCountOrderByAggregateInput
    _max?: PersonalPetVaccineMaxOrderByAggregateInput
    _min?: PersonalPetVaccineMinOrderByAggregateInput
  }

  export type PersonalPetVaccineScalarWhereWithAggregatesInput = {
    AND?: PersonalPetVaccineScalarWhereWithAggregatesInput | PersonalPetVaccineScalarWhereWithAggregatesInput[]
    OR?: PersonalPetVaccineScalarWhereWithAggregatesInput[]
    NOT?: PersonalPetVaccineScalarWhereWithAggregatesInput | PersonalPetVaccineScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PersonalPetVaccine"> | string
    createdAt?: DateTimeWithAggregatesFilter<"PersonalPetVaccine"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PersonalPetVaccine"> | Date | string
    clientPetId?: StringWithAggregatesFilter<"PersonalPetVaccine"> | string
    vaccineId?: StringWithAggregatesFilter<"PersonalPetVaccine"> | string
    mettingId?: StringNullableWithAggregatesFilter<"PersonalPetVaccine"> | string | null
  }

  export type MettingWhereInput = {
    AND?: MettingWhereInput | MettingWhereInput[]
    OR?: MettingWhereInput[]
    NOT?: MettingWhereInput | MettingWhereInput[]
    id?: StringFilter<"Metting"> | string
    createdAt?: DateTimeFilter<"Metting"> | Date | string
    updatedAt?: DateTimeFilter<"Metting"> | Date | string
    date?: DateTimeFilter<"Metting"> | Date | string
    duration?: DecimalFilter<"Metting"> | Decimal | DecimalJsLike | number | string
    description?: StringNullableFilter<"Metting"> | string | null
    petWeight?: IntNullableFilter<"Metting"> | number | null
    petSize?: IntNullableFilter<"Metting"> | number | null
    clientPetId?: StringFilter<"Metting"> | string
    veterinarianId?: StringFilter<"Metting"> | string
    clientPet?: XOR<ClientPetScalarRelationFilter, ClientPetWhereInput>
    veterinarian?: XOR<VeterinarianProfileScalarRelationFilter, VeterinarianProfileWhereInput>
    personalPetVaccine?: PersonalPetVaccineListRelationFilter
  }

  export type MettingOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    date?: SortOrder
    duration?: SortOrder
    description?: SortOrderInput | SortOrder
    petWeight?: SortOrderInput | SortOrder
    petSize?: SortOrderInput | SortOrder
    clientPetId?: SortOrder
    veterinarianId?: SortOrder
    clientPet?: ClientPetOrderByWithRelationInput
    veterinarian?: VeterinarianProfileOrderByWithRelationInput
    personalPetVaccine?: PersonalPetVaccineOrderByRelationAggregateInput
  }

  export type MettingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MettingWhereInput | MettingWhereInput[]
    OR?: MettingWhereInput[]
    NOT?: MettingWhereInput | MettingWhereInput[]
    createdAt?: DateTimeFilter<"Metting"> | Date | string
    updatedAt?: DateTimeFilter<"Metting"> | Date | string
    date?: DateTimeFilter<"Metting"> | Date | string
    duration?: DecimalFilter<"Metting"> | Decimal | DecimalJsLike | number | string
    description?: StringNullableFilter<"Metting"> | string | null
    petWeight?: IntNullableFilter<"Metting"> | number | null
    petSize?: IntNullableFilter<"Metting"> | number | null
    clientPetId?: StringFilter<"Metting"> | string
    veterinarianId?: StringFilter<"Metting"> | string
    clientPet?: XOR<ClientPetScalarRelationFilter, ClientPetWhereInput>
    veterinarian?: XOR<VeterinarianProfileScalarRelationFilter, VeterinarianProfileWhereInput>
    personalPetVaccine?: PersonalPetVaccineListRelationFilter
  }, "id">

  export type MettingOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    date?: SortOrder
    duration?: SortOrder
    description?: SortOrderInput | SortOrder
    petWeight?: SortOrderInput | SortOrder
    petSize?: SortOrderInput | SortOrder
    clientPetId?: SortOrder
    veterinarianId?: SortOrder
    _count?: MettingCountOrderByAggregateInput
    _avg?: MettingAvgOrderByAggregateInput
    _max?: MettingMaxOrderByAggregateInput
    _min?: MettingMinOrderByAggregateInput
    _sum?: MettingSumOrderByAggregateInput
  }

  export type MettingScalarWhereWithAggregatesInput = {
    AND?: MettingScalarWhereWithAggregatesInput | MettingScalarWhereWithAggregatesInput[]
    OR?: MettingScalarWhereWithAggregatesInput[]
    NOT?: MettingScalarWhereWithAggregatesInput | MettingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Metting"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Metting"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Metting"> | Date | string
    date?: DateTimeWithAggregatesFilter<"Metting"> | Date | string
    duration?: DecimalWithAggregatesFilter<"Metting"> | Decimal | DecimalJsLike | number | string
    description?: StringNullableWithAggregatesFilter<"Metting"> | string | null
    petWeight?: IntNullableWithAggregatesFilter<"Metting"> | number | null
    petSize?: IntNullableWithAggregatesFilter<"Metting"> | number | null
    clientPetId?: StringWithAggregatesFilter<"Metting"> | string
    veterinarianId?: StringWithAggregatesFilter<"Metting"> | string
  }

  export type ProductWhereInput = {
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    id?: StringFilter<"Product"> | string
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    name?: StringFilter<"Product"> | string
    description?: StringNullableFilter<"Product"> | string | null
    qrCode?: StringFilter<"Product"> | string
    websiteUrl?: StringNullableFilter<"Product"> | string | null
    picture?: StringNullableFilter<"Product"> | string | null
    brandId?: StringFilter<"Product"> | string
    brand?: XOR<BrandScalarRelationFilter, BrandWhereInput>
    clinicProducts?: ClinicProductListRelationFilter
    Food?: XOR<FoodNullableScalarRelationFilter, FoodWhereInput> | null
  }

  export type ProductOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    qrCode?: SortOrder
    websiteUrl?: SortOrderInput | SortOrder
    picture?: SortOrderInput | SortOrder
    brandId?: SortOrder
    brand?: BrandOrderByWithRelationInput
    clinicProducts?: ClinicProductOrderByRelationAggregateInput
    Food?: FoodOrderByWithRelationInput
  }

  export type ProductWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    name?: StringFilter<"Product"> | string
    description?: StringNullableFilter<"Product"> | string | null
    qrCode?: StringFilter<"Product"> | string
    websiteUrl?: StringNullableFilter<"Product"> | string | null
    picture?: StringNullableFilter<"Product"> | string | null
    brandId?: StringFilter<"Product"> | string
    brand?: XOR<BrandScalarRelationFilter, BrandWhereInput>
    clinicProducts?: ClinicProductListRelationFilter
    Food?: XOR<FoodNullableScalarRelationFilter, FoodWhereInput> | null
  }, "id">

  export type ProductOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    qrCode?: SortOrder
    websiteUrl?: SortOrderInput | SortOrder
    picture?: SortOrderInput | SortOrder
    brandId?: SortOrder
    _count?: ProductCountOrderByAggregateInput
    _max?: ProductMaxOrderByAggregateInput
    _min?: ProductMinOrderByAggregateInput
  }

  export type ProductScalarWhereWithAggregatesInput = {
    AND?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    OR?: ProductScalarWhereWithAggregatesInput[]
    NOT?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Product"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Product"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Product"> | Date | string
    name?: StringWithAggregatesFilter<"Product"> | string
    description?: StringNullableWithAggregatesFilter<"Product"> | string | null
    qrCode?: StringWithAggregatesFilter<"Product"> | string
    websiteUrl?: StringNullableWithAggregatesFilter<"Product"> | string | null
    picture?: StringNullableWithAggregatesFilter<"Product"> | string | null
    brandId?: StringWithAggregatesFilter<"Product"> | string
  }

  export type FoodWhereInput = {
    AND?: FoodWhereInput | FoodWhereInput[]
    OR?: FoodWhereInput[]
    NOT?: FoodWhereInput | FoodWhereInput[]
    id?: StringFilter<"Food"> | string
    createdAt?: DateTimeFilter<"Food"> | Date | string
    updatedAt?: DateTimeFilter<"Food"> | Date | string
    caloriesPer100?: DecimalNullableFilter<"Food"> | Decimal | DecimalJsLike | number | string | null
    proteinPer100?: DecimalNullableFilter<"Food"> | Decimal | DecimalJsLike | number | string | null
    fatPercentage?: DecimalNullableFilter<"Food"> | Decimal | DecimalJsLike | number | string | null
    fiberPercentage?: DecimalNullableFilter<"Food"> | Decimal | DecimalJsLike | number | string | null
    moisturePercentage?: DecimalNullableFilter<"Food"> | Decimal | DecimalJsLike | number | string | null
    type?: EnumFoodTypeFilter<"Food"> | $Enums.FoodType
    productId?: StringFilter<"Food"> | string
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    foodPets?: FoodPetListRelationFilter
  }

  export type FoodOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    caloriesPer100?: SortOrderInput | SortOrder
    proteinPer100?: SortOrderInput | SortOrder
    fatPercentage?: SortOrderInput | SortOrder
    fiberPercentage?: SortOrderInput | SortOrder
    moisturePercentage?: SortOrderInput | SortOrder
    type?: SortOrder
    productId?: SortOrder
    product?: ProductOrderByWithRelationInput
    foodPets?: FoodPetOrderByRelationAggregateInput
  }

  export type FoodWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    productId?: string
    AND?: FoodWhereInput | FoodWhereInput[]
    OR?: FoodWhereInput[]
    NOT?: FoodWhereInput | FoodWhereInput[]
    createdAt?: DateTimeFilter<"Food"> | Date | string
    updatedAt?: DateTimeFilter<"Food"> | Date | string
    caloriesPer100?: DecimalNullableFilter<"Food"> | Decimal | DecimalJsLike | number | string | null
    proteinPer100?: DecimalNullableFilter<"Food"> | Decimal | DecimalJsLike | number | string | null
    fatPercentage?: DecimalNullableFilter<"Food"> | Decimal | DecimalJsLike | number | string | null
    fiberPercentage?: DecimalNullableFilter<"Food"> | Decimal | DecimalJsLike | number | string | null
    moisturePercentage?: DecimalNullableFilter<"Food"> | Decimal | DecimalJsLike | number | string | null
    type?: EnumFoodTypeFilter<"Food"> | $Enums.FoodType
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    foodPets?: FoodPetListRelationFilter
  }, "id" | "productId">

  export type FoodOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    caloriesPer100?: SortOrderInput | SortOrder
    proteinPer100?: SortOrderInput | SortOrder
    fatPercentage?: SortOrderInput | SortOrder
    fiberPercentage?: SortOrderInput | SortOrder
    moisturePercentage?: SortOrderInput | SortOrder
    type?: SortOrder
    productId?: SortOrder
    _count?: FoodCountOrderByAggregateInput
    _avg?: FoodAvgOrderByAggregateInput
    _max?: FoodMaxOrderByAggregateInput
    _min?: FoodMinOrderByAggregateInput
    _sum?: FoodSumOrderByAggregateInput
  }

  export type FoodScalarWhereWithAggregatesInput = {
    AND?: FoodScalarWhereWithAggregatesInput | FoodScalarWhereWithAggregatesInput[]
    OR?: FoodScalarWhereWithAggregatesInput[]
    NOT?: FoodScalarWhereWithAggregatesInput | FoodScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Food"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Food"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Food"> | Date | string
    caloriesPer100?: DecimalNullableWithAggregatesFilter<"Food"> | Decimal | DecimalJsLike | number | string | null
    proteinPer100?: DecimalNullableWithAggregatesFilter<"Food"> | Decimal | DecimalJsLike | number | string | null
    fatPercentage?: DecimalNullableWithAggregatesFilter<"Food"> | Decimal | DecimalJsLike | number | string | null
    fiberPercentage?: DecimalNullableWithAggregatesFilter<"Food"> | Decimal | DecimalJsLike | number | string | null
    moisturePercentage?: DecimalNullableWithAggregatesFilter<"Food"> | Decimal | DecimalJsLike | number | string | null
    type?: EnumFoodTypeWithAggregatesFilter<"Food"> | $Enums.FoodType
    productId?: StringWithAggregatesFilter<"Food"> | string
  }

  export type BrandWhereInput = {
    AND?: BrandWhereInput | BrandWhereInput[]
    OR?: BrandWhereInput[]
    NOT?: BrandWhereInput | BrandWhereInput[]
    id?: StringFilter<"Brand"> | string
    createdAt?: DateTimeFilter<"Brand"> | Date | string
    updatedAt?: DateTimeFilter<"Brand"> | Date | string
    name?: StringFilter<"Brand"> | string
    logo?: StringNullableFilter<"Brand"> | string | null
    product?: ProductListRelationFilter
  }

  export type BrandOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    logo?: SortOrderInput | SortOrder
    product?: ProductOrderByRelationAggregateInput
  }

  export type BrandWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BrandWhereInput | BrandWhereInput[]
    OR?: BrandWhereInput[]
    NOT?: BrandWhereInput | BrandWhereInput[]
    createdAt?: DateTimeFilter<"Brand"> | Date | string
    updatedAt?: DateTimeFilter<"Brand"> | Date | string
    name?: StringFilter<"Brand"> | string
    logo?: StringNullableFilter<"Brand"> | string | null
    product?: ProductListRelationFilter
  }, "id">

  export type BrandOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    logo?: SortOrderInput | SortOrder
    _count?: BrandCountOrderByAggregateInput
    _max?: BrandMaxOrderByAggregateInput
    _min?: BrandMinOrderByAggregateInput
  }

  export type BrandScalarWhereWithAggregatesInput = {
    AND?: BrandScalarWhereWithAggregatesInput | BrandScalarWhereWithAggregatesInput[]
    OR?: BrandScalarWhereWithAggregatesInput[]
    NOT?: BrandScalarWhereWithAggregatesInput | BrandScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Brand"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Brand"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Brand"> | Date | string
    name?: StringWithAggregatesFilter<"Brand"> | string
    logo?: StringNullableWithAggregatesFilter<"Brand"> | string | null
  }

  export type ClinicProductWhereInput = {
    AND?: ClinicProductWhereInput | ClinicProductWhereInput[]
    OR?: ClinicProductWhereInput[]
    NOT?: ClinicProductWhereInput | ClinicProductWhereInput[]
    id?: StringFilter<"ClinicProduct"> | string
    createdAt?: DateTimeFilter<"ClinicProduct"> | Date | string
    updatedAt?: DateTimeFilter<"ClinicProduct"> | Date | string
    stock?: IntFilter<"ClinicProduct"> | number
    minimumRequired?: IntFilter<"ClinicProduct"> | number
    clinicId?: StringFilter<"ClinicProduct"> | string
    productId?: StringFilter<"ClinicProduct"> | string
    clinic?: XOR<ClientProfileScalarRelationFilter, ClientProfileWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }

  export type ClinicProductOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    stock?: SortOrder
    minimumRequired?: SortOrder
    clinicId?: SortOrder
    productId?: SortOrder
    clinic?: ClientProfileOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
  }

  export type ClinicProductWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ClinicProductWhereInput | ClinicProductWhereInput[]
    OR?: ClinicProductWhereInput[]
    NOT?: ClinicProductWhereInput | ClinicProductWhereInput[]
    createdAt?: DateTimeFilter<"ClinicProduct"> | Date | string
    updatedAt?: DateTimeFilter<"ClinicProduct"> | Date | string
    stock?: IntFilter<"ClinicProduct"> | number
    minimumRequired?: IntFilter<"ClinicProduct"> | number
    clinicId?: StringFilter<"ClinicProduct"> | string
    productId?: StringFilter<"ClinicProduct"> | string
    clinic?: XOR<ClientProfileScalarRelationFilter, ClientProfileWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }, "id">

  export type ClinicProductOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    stock?: SortOrder
    minimumRequired?: SortOrder
    clinicId?: SortOrder
    productId?: SortOrder
    _count?: ClinicProductCountOrderByAggregateInput
    _avg?: ClinicProductAvgOrderByAggregateInput
    _max?: ClinicProductMaxOrderByAggregateInput
    _min?: ClinicProductMinOrderByAggregateInput
    _sum?: ClinicProductSumOrderByAggregateInput
  }

  export type ClinicProductScalarWhereWithAggregatesInput = {
    AND?: ClinicProductScalarWhereWithAggregatesInput | ClinicProductScalarWhereWithAggregatesInput[]
    OR?: ClinicProductScalarWhereWithAggregatesInput[]
    NOT?: ClinicProductScalarWhereWithAggregatesInput | ClinicProductScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ClinicProduct"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ClinicProduct"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ClinicProduct"> | Date | string
    stock?: IntWithAggregatesFilter<"ClinicProduct"> | number
    minimumRequired?: IntWithAggregatesFilter<"ClinicProduct"> | number
    clinicId?: StringWithAggregatesFilter<"ClinicProduct"> | string
    productId?: StringWithAggregatesFilter<"ClinicProduct"> | string
  }

  export type FoodPetWhereInput = {
    AND?: FoodPetWhereInput | FoodPetWhereInput[]
    OR?: FoodPetWhereInput[]
    NOT?: FoodPetWhereInput | FoodPetWhereInput[]
    id?: StringFilter<"FoodPet"> | string
    createdAt?: DateTimeFilter<"FoodPet"> | Date | string
    updatedAt?: DateTimeFilter<"FoodPet"> | Date | string
    type?: EnumFoodPetDayFilter<"FoodPet"> | $Enums.FoodPetDay
    dateStart?: DateTimeFilter<"FoodPet"> | Date | string
    dateEnd?: DateTimeNullableFilter<"FoodPet"> | Date | string | null
    quantity?: DecimalFilter<"FoodPet"> | Decimal | DecimalJsLike | number | string
    hours?: DateTimeFilter<"FoodPet"> | Date | string
    foodId?: StringFilter<"FoodPet"> | string
    clientPetId?: StringFilter<"FoodPet"> | string
    food?: XOR<FoodScalarRelationFilter, FoodWhereInput>
    clientPet?: XOR<ClientPetScalarRelationFilter, ClientPetWhereInput>
  }

  export type FoodPetOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    type?: SortOrder
    dateStart?: SortOrder
    dateEnd?: SortOrderInput | SortOrder
    quantity?: SortOrder
    hours?: SortOrder
    foodId?: SortOrder
    clientPetId?: SortOrder
    food?: FoodOrderByWithRelationInput
    clientPet?: ClientPetOrderByWithRelationInput
  }

  export type FoodPetWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FoodPetWhereInput | FoodPetWhereInput[]
    OR?: FoodPetWhereInput[]
    NOT?: FoodPetWhereInput | FoodPetWhereInput[]
    createdAt?: DateTimeFilter<"FoodPet"> | Date | string
    updatedAt?: DateTimeFilter<"FoodPet"> | Date | string
    type?: EnumFoodPetDayFilter<"FoodPet"> | $Enums.FoodPetDay
    dateStart?: DateTimeFilter<"FoodPet"> | Date | string
    dateEnd?: DateTimeNullableFilter<"FoodPet"> | Date | string | null
    quantity?: DecimalFilter<"FoodPet"> | Decimal | DecimalJsLike | number | string
    hours?: DateTimeFilter<"FoodPet"> | Date | string
    foodId?: StringFilter<"FoodPet"> | string
    clientPetId?: StringFilter<"FoodPet"> | string
    food?: XOR<FoodScalarRelationFilter, FoodWhereInput>
    clientPet?: XOR<ClientPetScalarRelationFilter, ClientPetWhereInput>
  }, "id">

  export type FoodPetOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    type?: SortOrder
    dateStart?: SortOrder
    dateEnd?: SortOrderInput | SortOrder
    quantity?: SortOrder
    hours?: SortOrder
    foodId?: SortOrder
    clientPetId?: SortOrder
    _count?: FoodPetCountOrderByAggregateInput
    _avg?: FoodPetAvgOrderByAggregateInput
    _max?: FoodPetMaxOrderByAggregateInput
    _min?: FoodPetMinOrderByAggregateInput
    _sum?: FoodPetSumOrderByAggregateInput
  }

  export type FoodPetScalarWhereWithAggregatesInput = {
    AND?: FoodPetScalarWhereWithAggregatesInput | FoodPetScalarWhereWithAggregatesInput[]
    OR?: FoodPetScalarWhereWithAggregatesInput[]
    NOT?: FoodPetScalarWhereWithAggregatesInput | FoodPetScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FoodPet"> | string
    createdAt?: DateTimeWithAggregatesFilter<"FoodPet"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FoodPet"> | Date | string
    type?: EnumFoodPetDayWithAggregatesFilter<"FoodPet"> | $Enums.FoodPetDay
    dateStart?: DateTimeWithAggregatesFilter<"FoodPet"> | Date | string
    dateEnd?: DateTimeNullableWithAggregatesFilter<"FoodPet"> | Date | string | null
    quantity?: DecimalWithAggregatesFilter<"FoodPet"> | Decimal | DecimalJsLike | number | string
    hours?: DateTimeWithAggregatesFilter<"FoodPet"> | Date | string
    foodId?: StringWithAggregatesFilter<"FoodPet"> | string
    clientPetId?: StringWithAggregatesFilter<"FoodPet"> | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    firstname?: StringFilter<"User"> | string
    lastname?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    picture?: StringNullableFilter<"User"> | string | null
    clientProfile?: XOR<ClientProfileNullableScalarRelationFilter, ClientProfileWhereInput> | null
    veterinarianProfile?: XOR<VeterinarianProfileNullableScalarRelationFilter, VeterinarianProfileWhereInput> | null
    clinicProfile?: XOR<ClinicProfileNullableScalarRelationFilter, ClinicProfileWhereInput> | null
    secretaryProfile?: XOR<SecretaryProfileNullableScalarRelationFilter, SecretaryProfileWhereInput> | null
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    firstname?: SortOrder
    lastname?: SortOrder
    password?: SortOrder
    picture?: SortOrderInput | SortOrder
    clientProfile?: ClientProfileOrderByWithRelationInput
    veterinarianProfile?: VeterinarianProfileOrderByWithRelationInput
    clinicProfile?: ClinicProfileOrderByWithRelationInput
    secretaryProfile?: SecretaryProfileOrderByWithRelationInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    firstname?: StringFilter<"User"> | string
    lastname?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    picture?: StringNullableFilter<"User"> | string | null
    clientProfile?: XOR<ClientProfileNullableScalarRelationFilter, ClientProfileWhereInput> | null
    veterinarianProfile?: XOR<VeterinarianProfileNullableScalarRelationFilter, VeterinarianProfileWhereInput> | null
    clinicProfile?: XOR<ClinicProfileNullableScalarRelationFilter, ClinicProfileWhereInput> | null
    secretaryProfile?: XOR<SecretaryProfileNullableScalarRelationFilter, SecretaryProfileWhereInput> | null
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    firstname?: SortOrder
    lastname?: SortOrder
    password?: SortOrder
    picture?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    firstname?: StringWithAggregatesFilter<"User"> | string
    lastname?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    picture?: StringNullableWithAggregatesFilter<"User"> | string | null
  }

  export type ClientProfileWhereInput = {
    AND?: ClientProfileWhereInput | ClientProfileWhereInput[]
    OR?: ClientProfileWhereInput[]
    NOT?: ClientProfileWhereInput | ClientProfileWhereInput[]
    id?: StringFilter<"ClientProfile"> | string
    dateOfBirth?: DateTimeFilter<"ClientProfile"> | Date | string
    address?: StringNullableFilter<"ClientProfile"> | string | null
    phone?: StringNullableFilter<"ClientProfile"> | string | null
    userId?: StringFilter<"ClientProfile"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    secretaryProfile?: XOR<SecretaryProfileNullableScalarRelationFilter, SecretaryProfileWhereInput> | null
    veterinarianProfile?: XOR<VeterinarianProfileNullableScalarRelationFilter, VeterinarianProfileWhereInput> | null
    clientPet?: ClientPetListRelationFilter
    clinicProducts?: ClinicProductListRelationFilter
  }

  export type ClientProfileOrderByWithRelationInput = {
    id?: SortOrder
    dateOfBirth?: SortOrder
    address?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    userId?: SortOrder
    user?: UserOrderByWithRelationInput
    secretaryProfile?: SecretaryProfileOrderByWithRelationInput
    veterinarianProfile?: VeterinarianProfileOrderByWithRelationInput
    clientPet?: ClientPetOrderByRelationAggregateInput
    clinicProducts?: ClinicProductOrderByRelationAggregateInput
  }

  export type ClientProfileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: ClientProfileWhereInput | ClientProfileWhereInput[]
    OR?: ClientProfileWhereInput[]
    NOT?: ClientProfileWhereInput | ClientProfileWhereInput[]
    dateOfBirth?: DateTimeFilter<"ClientProfile"> | Date | string
    address?: StringNullableFilter<"ClientProfile"> | string | null
    phone?: StringNullableFilter<"ClientProfile"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    secretaryProfile?: XOR<SecretaryProfileNullableScalarRelationFilter, SecretaryProfileWhereInput> | null
    veterinarianProfile?: XOR<VeterinarianProfileNullableScalarRelationFilter, VeterinarianProfileWhereInput> | null
    clientPet?: ClientPetListRelationFilter
    clinicProducts?: ClinicProductListRelationFilter
  }, "id" | "userId">

  export type ClientProfileOrderByWithAggregationInput = {
    id?: SortOrder
    dateOfBirth?: SortOrder
    address?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    userId?: SortOrder
    _count?: ClientProfileCountOrderByAggregateInput
    _max?: ClientProfileMaxOrderByAggregateInput
    _min?: ClientProfileMinOrderByAggregateInput
  }

  export type ClientProfileScalarWhereWithAggregatesInput = {
    AND?: ClientProfileScalarWhereWithAggregatesInput | ClientProfileScalarWhereWithAggregatesInput[]
    OR?: ClientProfileScalarWhereWithAggregatesInput[]
    NOT?: ClientProfileScalarWhereWithAggregatesInput | ClientProfileScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ClientProfile"> | string
    dateOfBirth?: DateTimeWithAggregatesFilter<"ClientProfile"> | Date | string
    address?: StringNullableWithAggregatesFilter<"ClientProfile"> | string | null
    phone?: StringNullableWithAggregatesFilter<"ClientProfile"> | string | null
    userId?: StringWithAggregatesFilter<"ClientProfile"> | string
  }

  export type VeterinarianProfileWhereInput = {
    AND?: VeterinarianProfileWhereInput | VeterinarianProfileWhereInput[]
    OR?: VeterinarianProfileWhereInput[]
    NOT?: VeterinarianProfileWhereInput | VeterinarianProfileWhereInput[]
    id?: StringFilter<"VeterinarianProfile"> | string
    licenseNumber?: StringFilter<"VeterinarianProfile"> | string
    specialty?: StringFilter<"VeterinarianProfile"> | string
    yearsExperience?: IntFilter<"VeterinarianProfile"> | number
    bio?: StringNullableFilter<"VeterinarianProfile"> | string | null
    clinicId?: StringFilter<"VeterinarianProfile"> | string
    userId?: StringFilter<"VeterinarianProfile"> | string
    clinic?: XOR<ClientProfileScalarRelationFilter, ClientProfileWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    clinicProfiles?: ClinicProfileListRelationFilter
    clientPet?: ClientPetListRelationFilter
    metting?: MettingListRelationFilter
  }

  export type VeterinarianProfileOrderByWithRelationInput = {
    id?: SortOrder
    licenseNumber?: SortOrder
    specialty?: SortOrder
    yearsExperience?: SortOrder
    bio?: SortOrderInput | SortOrder
    clinicId?: SortOrder
    userId?: SortOrder
    clinic?: ClientProfileOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    clinicProfiles?: ClinicProfileOrderByRelationAggregateInput
    clientPet?: ClientPetOrderByRelationAggregateInput
    metting?: MettingOrderByRelationAggregateInput
  }

  export type VeterinarianProfileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    licenseNumber?: string
    clinicId?: string
    userId?: string
    AND?: VeterinarianProfileWhereInput | VeterinarianProfileWhereInput[]
    OR?: VeterinarianProfileWhereInput[]
    NOT?: VeterinarianProfileWhereInput | VeterinarianProfileWhereInput[]
    specialty?: StringFilter<"VeterinarianProfile"> | string
    yearsExperience?: IntFilter<"VeterinarianProfile"> | number
    bio?: StringNullableFilter<"VeterinarianProfile"> | string | null
    clinic?: XOR<ClientProfileScalarRelationFilter, ClientProfileWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    clinicProfiles?: ClinicProfileListRelationFilter
    clientPet?: ClientPetListRelationFilter
    metting?: MettingListRelationFilter
  }, "id" | "licenseNumber" | "clinicId" | "userId">

  export type VeterinarianProfileOrderByWithAggregationInput = {
    id?: SortOrder
    licenseNumber?: SortOrder
    specialty?: SortOrder
    yearsExperience?: SortOrder
    bio?: SortOrderInput | SortOrder
    clinicId?: SortOrder
    userId?: SortOrder
    _count?: VeterinarianProfileCountOrderByAggregateInput
    _avg?: VeterinarianProfileAvgOrderByAggregateInput
    _max?: VeterinarianProfileMaxOrderByAggregateInput
    _min?: VeterinarianProfileMinOrderByAggregateInput
    _sum?: VeterinarianProfileSumOrderByAggregateInput
  }

  export type VeterinarianProfileScalarWhereWithAggregatesInput = {
    AND?: VeterinarianProfileScalarWhereWithAggregatesInput | VeterinarianProfileScalarWhereWithAggregatesInput[]
    OR?: VeterinarianProfileScalarWhereWithAggregatesInput[]
    NOT?: VeterinarianProfileScalarWhereWithAggregatesInput | VeterinarianProfileScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"VeterinarianProfile"> | string
    licenseNumber?: StringWithAggregatesFilter<"VeterinarianProfile"> | string
    specialty?: StringWithAggregatesFilter<"VeterinarianProfile"> | string
    yearsExperience?: IntWithAggregatesFilter<"VeterinarianProfile"> | number
    bio?: StringNullableWithAggregatesFilter<"VeterinarianProfile"> | string | null
    clinicId?: StringWithAggregatesFilter<"VeterinarianProfile"> | string
    userId?: StringWithAggregatesFilter<"VeterinarianProfile"> | string
  }

  export type ClinicProfileWhereInput = {
    AND?: ClinicProfileWhereInput | ClinicProfileWhereInput[]
    OR?: ClinicProfileWhereInput[]
    NOT?: ClinicProfileWhereInput | ClinicProfileWhereInput[]
    id?: StringFilter<"ClinicProfile"> | string
    name?: StringFilter<"ClinicProfile"> | string
    address?: StringFilter<"ClinicProfile"> | string
    siret?: StringFilter<"ClinicProfile"> | string
    phone?: StringFilter<"ClinicProfile"> | string
    description?: StringNullableFilter<"ClinicProfile"> | string | null
    website?: StringFilter<"ClinicProfile"> | string
    userId?: StringFilter<"ClinicProfile"> | string
    veterinarianProfileId?: StringNullableFilter<"ClinicProfile"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    veterinarianProfile?: XOR<VeterinarianProfileNullableScalarRelationFilter, VeterinarianProfileWhereInput> | null
  }

  export type ClinicProfileOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    siret?: SortOrder
    phone?: SortOrder
    description?: SortOrderInput | SortOrder
    website?: SortOrder
    userId?: SortOrder
    veterinarianProfileId?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    veterinarianProfile?: VeterinarianProfileOrderByWithRelationInput
  }

  export type ClinicProfileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    siret?: string
    userId?: string
    AND?: ClinicProfileWhereInput | ClinicProfileWhereInput[]
    OR?: ClinicProfileWhereInput[]
    NOT?: ClinicProfileWhereInput | ClinicProfileWhereInput[]
    name?: StringFilter<"ClinicProfile"> | string
    address?: StringFilter<"ClinicProfile"> | string
    phone?: StringFilter<"ClinicProfile"> | string
    description?: StringNullableFilter<"ClinicProfile"> | string | null
    website?: StringFilter<"ClinicProfile"> | string
    veterinarianProfileId?: StringNullableFilter<"ClinicProfile"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    veterinarianProfile?: XOR<VeterinarianProfileNullableScalarRelationFilter, VeterinarianProfileWhereInput> | null
  }, "id" | "siret" | "userId">

  export type ClinicProfileOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    siret?: SortOrder
    phone?: SortOrder
    description?: SortOrderInput | SortOrder
    website?: SortOrder
    userId?: SortOrder
    veterinarianProfileId?: SortOrderInput | SortOrder
    _count?: ClinicProfileCountOrderByAggregateInput
    _max?: ClinicProfileMaxOrderByAggregateInput
    _min?: ClinicProfileMinOrderByAggregateInput
  }

  export type ClinicProfileScalarWhereWithAggregatesInput = {
    AND?: ClinicProfileScalarWhereWithAggregatesInput | ClinicProfileScalarWhereWithAggregatesInput[]
    OR?: ClinicProfileScalarWhereWithAggregatesInput[]
    NOT?: ClinicProfileScalarWhereWithAggregatesInput | ClinicProfileScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ClinicProfile"> | string
    name?: StringWithAggregatesFilter<"ClinicProfile"> | string
    address?: StringWithAggregatesFilter<"ClinicProfile"> | string
    siret?: StringWithAggregatesFilter<"ClinicProfile"> | string
    phone?: StringWithAggregatesFilter<"ClinicProfile"> | string
    description?: StringNullableWithAggregatesFilter<"ClinicProfile"> | string | null
    website?: StringWithAggregatesFilter<"ClinicProfile"> | string
    userId?: StringWithAggregatesFilter<"ClinicProfile"> | string
    veterinarianProfileId?: StringNullableWithAggregatesFilter<"ClinicProfile"> | string | null
  }

  export type SecretaryProfileWhereInput = {
    AND?: SecretaryProfileWhereInput | SecretaryProfileWhereInput[]
    OR?: SecretaryProfileWhereInput[]
    NOT?: SecretaryProfileWhereInput | SecretaryProfileWhereInput[]
    id?: StringFilter<"SecretaryProfile"> | string
    userId?: StringFilter<"SecretaryProfile"> | string
    clinicId?: StringFilter<"SecretaryProfile"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    clinic?: XOR<ClientProfileScalarRelationFilter, ClientProfileWhereInput>
  }

  export type SecretaryProfileOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    clinicId?: SortOrder
    user?: UserOrderByWithRelationInput
    clinic?: ClientProfileOrderByWithRelationInput
  }

  export type SecretaryProfileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    clinicId?: string
    AND?: SecretaryProfileWhereInput | SecretaryProfileWhereInput[]
    OR?: SecretaryProfileWhereInput[]
    NOT?: SecretaryProfileWhereInput | SecretaryProfileWhereInput[]
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    clinic?: XOR<ClientProfileScalarRelationFilter, ClientProfileWhereInput>
  }, "id" | "userId" | "clinicId">

  export type SecretaryProfileOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    clinicId?: SortOrder
    _count?: SecretaryProfileCountOrderByAggregateInput
    _max?: SecretaryProfileMaxOrderByAggregateInput
    _min?: SecretaryProfileMinOrderByAggregateInput
  }

  export type SecretaryProfileScalarWhereWithAggregatesInput = {
    AND?: SecretaryProfileScalarWhereWithAggregatesInput | SecretaryProfileScalarWhereWithAggregatesInput[]
    OR?: SecretaryProfileScalarWhereWithAggregatesInput[]
    NOT?: SecretaryProfileScalarWhereWithAggregatesInput | SecretaryProfileScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SecretaryProfile"> | string
    userId?: StringWithAggregatesFilter<"SecretaryProfile"> | string
    clinicId?: StringWithAggregatesFilter<"SecretaryProfile"> | string
  }

  export type ClientPetCreateInput = {
    id?: string
    name: string
    dateOfBirth: Date | string
    description?: string | null
    activity?: number | null
    attendingVeterinarian?: VeterinarianProfileCreateNestedOneWithoutClientPetInput
    client: ClientProfileCreateNestedOneWithoutClientPetInput
    race: RaceCreateNestedOneWithoutClientPetInput
    personalPetVaccine?: PersonalPetVaccineCreateNestedManyWithoutClientPetInput
    metting?: MettingCreateNestedManyWithoutClientPetInput
    foodPets?: FoodPetCreateNestedManyWithoutClientPetInput
  }

  export type ClientPetUncheckedCreateInput = {
    id?: string
    name: string
    dateOfBirth: Date | string
    description?: string | null
    activity?: number | null
    attendingVeterinarianId?: string | null
    clientId: string
    raceId: string
    personalPetVaccine?: PersonalPetVaccineUncheckedCreateNestedManyWithoutClientPetInput
    metting?: MettingUncheckedCreateNestedManyWithoutClientPetInput
    foodPets?: FoodPetUncheckedCreateNestedManyWithoutClientPetInput
  }

  export type ClientPetUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    activity?: NullableIntFieldUpdateOperationsInput | number | null
    attendingVeterinarian?: VeterinarianProfileUpdateOneWithoutClientPetNestedInput
    client?: ClientProfileUpdateOneRequiredWithoutClientPetNestedInput
    race?: RaceUpdateOneRequiredWithoutClientPetNestedInput
    personalPetVaccine?: PersonalPetVaccineUpdateManyWithoutClientPetNestedInput
    metting?: MettingUpdateManyWithoutClientPetNestedInput
    foodPets?: FoodPetUpdateManyWithoutClientPetNestedInput
  }

  export type ClientPetUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    activity?: NullableIntFieldUpdateOperationsInput | number | null
    attendingVeterinarianId?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    raceId?: StringFieldUpdateOperationsInput | string
    personalPetVaccine?: PersonalPetVaccineUncheckedUpdateManyWithoutClientPetNestedInput
    metting?: MettingUncheckedUpdateManyWithoutClientPetNestedInput
    foodPets?: FoodPetUncheckedUpdateManyWithoutClientPetNestedInput
  }

  export type ClientPetCreateManyInput = {
    id?: string
    name: string
    dateOfBirth: Date | string
    description?: string | null
    activity?: number | null
    attendingVeterinarianId?: string | null
    clientId: string
    raceId: string
  }

  export type ClientPetUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    activity?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ClientPetUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    activity?: NullableIntFieldUpdateOperationsInput | number | null
    attendingVeterinarianId?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    raceId?: StringFieldUpdateOperationsInput | string
  }

  export type PetCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    picture?: string | null
    races?: RaceCreateNestedManyWithoutPetInput
    vaccine?: VaccineCreateNestedManyWithoutPetInput
  }

  export type PetUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    picture?: string | null
    races?: RaceUncheckedCreateNestedManyWithoutPetInput
    vaccine?: VaccineUncheckedCreateNestedManyWithoutPetInput
  }

  export type PetUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    races?: RaceUpdateManyWithoutPetNestedInput
    vaccine?: VaccineUpdateManyWithoutPetNestedInput
  }

  export type PetUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    races?: RaceUncheckedUpdateManyWithoutPetNestedInput
    vaccine?: VaccineUncheckedUpdateManyWithoutPetNestedInput
  }

  export type PetCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    picture?: string | null
  }

  export type PetUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    picture?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PetUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    picture?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RaceCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    picture?: string | null
    pet: PetCreateNestedOneWithoutRacesInput
    clientPet?: ClientPetCreateNestedManyWithoutRaceInput
  }

  export type RaceUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    picture?: string | null
    petId: string
    clientPet?: ClientPetUncheckedCreateNestedManyWithoutRaceInput
  }

  export type RaceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    pet?: PetUpdateOneRequiredWithoutRacesNestedInput
    clientPet?: ClientPetUpdateManyWithoutRaceNestedInput
  }

  export type RaceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    petId?: StringFieldUpdateOperationsInput | string
    clientPet?: ClientPetUncheckedUpdateManyWithoutRaceNestedInput
  }

  export type RaceCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    picture?: string | null
    petId: string
  }

  export type RaceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    picture?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RaceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    petId?: StringFieldUpdateOperationsInput | string
  }

  export type VaccineCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    description?: string | null
    recommendedAge: number
    boosterInterval: number
    mandatoryCountry?: NullableJsonNullValueInput | InputJsonValue
    recommendedCountry?: NullableJsonNullValueInput | InputJsonValue
    pet: PetCreateNestedOneWithoutVaccineInput
    personalPetVaccine?: PersonalPetVaccineCreateNestedManyWithoutVaccineInput
  }

  export type VaccineUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    description?: string | null
    recommendedAge: number
    boosterInterval: number
    mandatoryCountry?: NullableJsonNullValueInput | InputJsonValue
    recommendedCountry?: NullableJsonNullValueInput | InputJsonValue
    petId: string
    personalPetVaccine?: PersonalPetVaccineUncheckedCreateNestedManyWithoutVaccineInput
  }

  export type VaccineUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    recommendedAge?: IntFieldUpdateOperationsInput | number
    boosterInterval?: IntFieldUpdateOperationsInput | number
    mandatoryCountry?: NullableJsonNullValueInput | InputJsonValue
    recommendedCountry?: NullableJsonNullValueInput | InputJsonValue
    pet?: PetUpdateOneRequiredWithoutVaccineNestedInput
    personalPetVaccine?: PersonalPetVaccineUpdateManyWithoutVaccineNestedInput
  }

  export type VaccineUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    recommendedAge?: IntFieldUpdateOperationsInput | number
    boosterInterval?: IntFieldUpdateOperationsInput | number
    mandatoryCountry?: NullableJsonNullValueInput | InputJsonValue
    recommendedCountry?: NullableJsonNullValueInput | InputJsonValue
    petId?: StringFieldUpdateOperationsInput | string
    personalPetVaccine?: PersonalPetVaccineUncheckedUpdateManyWithoutVaccineNestedInput
  }

  export type VaccineCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    description?: string | null
    recommendedAge: number
    boosterInterval: number
    mandatoryCountry?: NullableJsonNullValueInput | InputJsonValue
    recommendedCountry?: NullableJsonNullValueInput | InputJsonValue
    petId: string
  }

  export type VaccineUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    recommendedAge?: IntFieldUpdateOperationsInput | number
    boosterInterval?: IntFieldUpdateOperationsInput | number
    mandatoryCountry?: NullableJsonNullValueInput | InputJsonValue
    recommendedCountry?: NullableJsonNullValueInput | InputJsonValue
  }

  export type VaccineUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    recommendedAge?: IntFieldUpdateOperationsInput | number
    boosterInterval?: IntFieldUpdateOperationsInput | number
    mandatoryCountry?: NullableJsonNullValueInput | InputJsonValue
    recommendedCountry?: NullableJsonNullValueInput | InputJsonValue
    petId?: StringFieldUpdateOperationsInput | string
  }

  export type PersonalPetVaccineCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    clientPet: ClientPetCreateNestedOneWithoutPersonalPetVaccineInput
    vaccine: VaccineCreateNestedOneWithoutPersonalPetVaccineInput
    metting?: MettingCreateNestedOneWithoutPersonalPetVaccineInput
  }

  export type PersonalPetVaccineUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    clientPetId: string
    vaccineId: string
    mettingId?: string | null
  }

  export type PersonalPetVaccineUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientPet?: ClientPetUpdateOneRequiredWithoutPersonalPetVaccineNestedInput
    vaccine?: VaccineUpdateOneRequiredWithoutPersonalPetVaccineNestedInput
    metting?: MettingUpdateOneWithoutPersonalPetVaccineNestedInput
  }

  export type PersonalPetVaccineUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientPetId?: StringFieldUpdateOperationsInput | string
    vaccineId?: StringFieldUpdateOperationsInput | string
    mettingId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PersonalPetVaccineCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    clientPetId: string
    vaccineId: string
    mettingId?: string | null
  }

  export type PersonalPetVaccineUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PersonalPetVaccineUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientPetId?: StringFieldUpdateOperationsInput | string
    vaccineId?: StringFieldUpdateOperationsInput | string
    mettingId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MettingCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    date: Date | string
    duration: Decimal | DecimalJsLike | number | string
    description?: string | null
    petWeight?: number | null
    petSize?: number | null
    clientPet: ClientPetCreateNestedOneWithoutMettingInput
    veterinarian: VeterinarianProfileCreateNestedOneWithoutMettingInput
    personalPetVaccine?: PersonalPetVaccineCreateNestedManyWithoutMettingInput
  }

  export type MettingUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    date: Date | string
    duration: Decimal | DecimalJsLike | number | string
    description?: string | null
    petWeight?: number | null
    petSize?: number | null
    clientPetId: string
    veterinarianId: string
    personalPetVaccine?: PersonalPetVaccineUncheckedCreateNestedManyWithoutMettingInput
  }

  export type MettingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    petWeight?: NullableIntFieldUpdateOperationsInput | number | null
    petSize?: NullableIntFieldUpdateOperationsInput | number | null
    clientPet?: ClientPetUpdateOneRequiredWithoutMettingNestedInput
    veterinarian?: VeterinarianProfileUpdateOneRequiredWithoutMettingNestedInput
    personalPetVaccine?: PersonalPetVaccineUpdateManyWithoutMettingNestedInput
  }

  export type MettingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    petWeight?: NullableIntFieldUpdateOperationsInput | number | null
    petSize?: NullableIntFieldUpdateOperationsInput | number | null
    clientPetId?: StringFieldUpdateOperationsInput | string
    veterinarianId?: StringFieldUpdateOperationsInput | string
    personalPetVaccine?: PersonalPetVaccineUncheckedUpdateManyWithoutMettingNestedInput
  }

  export type MettingCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    date: Date | string
    duration: Decimal | DecimalJsLike | number | string
    description?: string | null
    petWeight?: number | null
    petSize?: number | null
    clientPetId: string
    veterinarianId: string
  }

  export type MettingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    petWeight?: NullableIntFieldUpdateOperationsInput | number | null
    petSize?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type MettingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    petWeight?: NullableIntFieldUpdateOperationsInput | number | null
    petSize?: NullableIntFieldUpdateOperationsInput | number | null
    clientPetId?: StringFieldUpdateOperationsInput | string
    veterinarianId?: StringFieldUpdateOperationsInput | string
  }

  export type ProductCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    description?: string | null
    qrCode: string
    websiteUrl?: string | null
    picture?: string | null
    brand: BrandCreateNestedOneWithoutProductInput
    clinicProducts?: ClinicProductCreateNestedManyWithoutProductInput
    Food?: FoodCreateNestedOneWithoutProductInput
  }

  export type ProductUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    description?: string | null
    qrCode: string
    websiteUrl?: string | null
    picture?: string | null
    brandId: string
    clinicProducts?: ClinicProductUncheckedCreateNestedManyWithoutProductInput
    Food?: FoodUncheckedCreateNestedOneWithoutProductInput
  }

  export type ProductUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    qrCode?: StringFieldUpdateOperationsInput | string
    websiteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    brand?: BrandUpdateOneRequiredWithoutProductNestedInput
    clinicProducts?: ClinicProductUpdateManyWithoutProductNestedInput
    Food?: FoodUpdateOneWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    qrCode?: StringFieldUpdateOperationsInput | string
    websiteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    brandId?: StringFieldUpdateOperationsInput | string
    clinicProducts?: ClinicProductUncheckedUpdateManyWithoutProductNestedInput
    Food?: FoodUncheckedUpdateOneWithoutProductNestedInput
  }

  export type ProductCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    description?: string | null
    qrCode: string
    websiteUrl?: string | null
    picture?: string | null
    brandId: string
  }

  export type ProductUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    qrCode?: StringFieldUpdateOperationsInput | string
    websiteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    qrCode?: StringFieldUpdateOperationsInput | string
    websiteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    brandId?: StringFieldUpdateOperationsInput | string
  }

  export type FoodCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    caloriesPer100?: Decimal | DecimalJsLike | number | string | null
    proteinPer100?: Decimal | DecimalJsLike | number | string | null
    fatPercentage?: Decimal | DecimalJsLike | number | string | null
    fiberPercentage?: Decimal | DecimalJsLike | number | string | null
    moisturePercentage?: Decimal | DecimalJsLike | number | string | null
    type: $Enums.FoodType
    product: ProductCreateNestedOneWithoutFoodInput
    foodPets?: FoodPetCreateNestedManyWithoutFoodInput
  }

  export type FoodUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    caloriesPer100?: Decimal | DecimalJsLike | number | string | null
    proteinPer100?: Decimal | DecimalJsLike | number | string | null
    fatPercentage?: Decimal | DecimalJsLike | number | string | null
    fiberPercentage?: Decimal | DecimalJsLike | number | string | null
    moisturePercentage?: Decimal | DecimalJsLike | number | string | null
    type: $Enums.FoodType
    productId: string
    foodPets?: FoodPetUncheckedCreateNestedManyWithoutFoodInput
  }

  export type FoodUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    caloriesPer100?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    proteinPer100?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fatPercentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fiberPercentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    moisturePercentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    type?: EnumFoodTypeFieldUpdateOperationsInput | $Enums.FoodType
    product?: ProductUpdateOneRequiredWithoutFoodNestedInput
    foodPets?: FoodPetUpdateManyWithoutFoodNestedInput
  }

  export type FoodUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    caloriesPer100?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    proteinPer100?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fatPercentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fiberPercentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    moisturePercentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    type?: EnumFoodTypeFieldUpdateOperationsInput | $Enums.FoodType
    productId?: StringFieldUpdateOperationsInput | string
    foodPets?: FoodPetUncheckedUpdateManyWithoutFoodNestedInput
  }

  export type FoodCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    caloriesPer100?: Decimal | DecimalJsLike | number | string | null
    proteinPer100?: Decimal | DecimalJsLike | number | string | null
    fatPercentage?: Decimal | DecimalJsLike | number | string | null
    fiberPercentage?: Decimal | DecimalJsLike | number | string | null
    moisturePercentage?: Decimal | DecimalJsLike | number | string | null
    type: $Enums.FoodType
    productId: string
  }

  export type FoodUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    caloriesPer100?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    proteinPer100?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fatPercentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fiberPercentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    moisturePercentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    type?: EnumFoodTypeFieldUpdateOperationsInput | $Enums.FoodType
  }

  export type FoodUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    caloriesPer100?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    proteinPer100?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fatPercentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fiberPercentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    moisturePercentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    type?: EnumFoodTypeFieldUpdateOperationsInput | $Enums.FoodType
    productId?: StringFieldUpdateOperationsInput | string
  }

  export type BrandCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    logo?: string | null
    product?: ProductCreateNestedManyWithoutBrandInput
  }

  export type BrandUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    logo?: string | null
    product?: ProductUncheckedCreateNestedManyWithoutBrandInput
  }

  export type BrandUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    product?: ProductUpdateManyWithoutBrandNestedInput
  }

  export type BrandUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    product?: ProductUncheckedUpdateManyWithoutBrandNestedInput
  }

  export type BrandCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    logo?: string | null
  }

  export type BrandUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BrandUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ClinicProductCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    stock?: number
    minimumRequired: number
    clinic: ClientProfileCreateNestedOneWithoutClinicProductsInput
    product: ProductCreateNestedOneWithoutClinicProductsInput
  }

  export type ClinicProductUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    stock?: number
    minimumRequired: number
    clinicId: string
    productId: string
  }

  export type ClinicProductUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stock?: IntFieldUpdateOperationsInput | number
    minimumRequired?: IntFieldUpdateOperationsInput | number
    clinic?: ClientProfileUpdateOneRequiredWithoutClinicProductsNestedInput
    product?: ProductUpdateOneRequiredWithoutClinicProductsNestedInput
  }

  export type ClinicProductUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stock?: IntFieldUpdateOperationsInput | number
    minimumRequired?: IntFieldUpdateOperationsInput | number
    clinicId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
  }

  export type ClinicProductCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    stock?: number
    minimumRequired: number
    clinicId: string
    productId: string
  }

  export type ClinicProductUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stock?: IntFieldUpdateOperationsInput | number
    minimumRequired?: IntFieldUpdateOperationsInput | number
  }

  export type ClinicProductUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stock?: IntFieldUpdateOperationsInput | number
    minimumRequired?: IntFieldUpdateOperationsInput | number
    clinicId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
  }

  export type FoodPetCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    type: $Enums.FoodPetDay
    dateStart: Date | string
    dateEnd?: Date | string | null
    quantity: Decimal | DecimalJsLike | number | string
    hours: Date | string
    food: FoodCreateNestedOneWithoutFoodPetsInput
    clientPet: ClientPetCreateNestedOneWithoutFoodPetsInput
  }

  export type FoodPetUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    type: $Enums.FoodPetDay
    dateStart: Date | string
    dateEnd?: Date | string | null
    quantity: Decimal | DecimalJsLike | number | string
    hours: Date | string
    foodId: string
    clientPetId: string
  }

  export type FoodPetUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumFoodPetDayFieldUpdateOperationsInput | $Enums.FoodPetDay
    dateStart?: DateTimeFieldUpdateOperationsInput | Date | string
    dateEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    hours?: DateTimeFieldUpdateOperationsInput | Date | string
    food?: FoodUpdateOneRequiredWithoutFoodPetsNestedInput
    clientPet?: ClientPetUpdateOneRequiredWithoutFoodPetsNestedInput
  }

  export type FoodPetUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumFoodPetDayFieldUpdateOperationsInput | $Enums.FoodPetDay
    dateStart?: DateTimeFieldUpdateOperationsInput | Date | string
    dateEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    hours?: DateTimeFieldUpdateOperationsInput | Date | string
    foodId?: StringFieldUpdateOperationsInput | string
    clientPetId?: StringFieldUpdateOperationsInput | string
  }

  export type FoodPetCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    type: $Enums.FoodPetDay
    dateStart: Date | string
    dateEnd?: Date | string | null
    quantity: Decimal | DecimalJsLike | number | string
    hours: Date | string
    foodId: string
    clientPetId: string
  }

  export type FoodPetUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumFoodPetDayFieldUpdateOperationsInput | $Enums.FoodPetDay
    dateStart?: DateTimeFieldUpdateOperationsInput | Date | string
    dateEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    hours?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FoodPetUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumFoodPetDayFieldUpdateOperationsInput | $Enums.FoodPetDay
    dateStart?: DateTimeFieldUpdateOperationsInput | Date | string
    dateEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    hours?: DateTimeFieldUpdateOperationsInput | Date | string
    foodId?: StringFieldUpdateOperationsInput | string
    clientPetId?: StringFieldUpdateOperationsInput | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    firstname: string
    lastname: string
    password: string
    picture?: string | null
    clientProfile?: ClientProfileCreateNestedOneWithoutUserInput
    veterinarianProfile?: VeterinarianProfileCreateNestedOneWithoutUserInput
    clinicProfile?: ClinicProfileCreateNestedOneWithoutUserInput
    secretaryProfile?: SecretaryProfileCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    firstname: string
    lastname: string
    password: string
    picture?: string | null
    clientProfile?: ClientProfileUncheckedCreateNestedOneWithoutUserInput
    veterinarianProfile?: VeterinarianProfileUncheckedCreateNestedOneWithoutUserInput
    clinicProfile?: ClinicProfileUncheckedCreateNestedOneWithoutUserInput
    secretaryProfile?: SecretaryProfileUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    clientProfile?: ClientProfileUpdateOneWithoutUserNestedInput
    veterinarianProfile?: VeterinarianProfileUpdateOneWithoutUserNestedInput
    clinicProfile?: ClinicProfileUpdateOneWithoutUserNestedInput
    secretaryProfile?: SecretaryProfileUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    clientProfile?: ClientProfileUncheckedUpdateOneWithoutUserNestedInput
    veterinarianProfile?: VeterinarianProfileUncheckedUpdateOneWithoutUserNestedInput
    clinicProfile?: ClinicProfileUncheckedUpdateOneWithoutUserNestedInput
    secretaryProfile?: SecretaryProfileUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    firstname: string
    lastname: string
    password: string
    picture?: string | null
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    picture?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    picture?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ClientProfileCreateInput = {
    id?: string
    dateOfBirth: Date | string
    address?: string | null
    phone?: string | null
    user: UserCreateNestedOneWithoutClientProfileInput
    secretaryProfile?: SecretaryProfileCreateNestedOneWithoutClinicInput
    veterinarianProfile?: VeterinarianProfileCreateNestedOneWithoutClinicInput
    clientPet?: ClientPetCreateNestedManyWithoutClientInput
    clinicProducts?: ClinicProductCreateNestedManyWithoutClinicInput
  }

  export type ClientProfileUncheckedCreateInput = {
    id?: string
    dateOfBirth: Date | string
    address?: string | null
    phone?: string | null
    userId: string
    secretaryProfile?: SecretaryProfileUncheckedCreateNestedOneWithoutClinicInput
    veterinarianProfile?: VeterinarianProfileUncheckedCreateNestedOneWithoutClinicInput
    clientPet?: ClientPetUncheckedCreateNestedManyWithoutClientInput
    clinicProducts?: ClinicProductUncheckedCreateNestedManyWithoutClinicInput
  }

  export type ClientProfileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutClientProfileNestedInput
    secretaryProfile?: SecretaryProfileUpdateOneWithoutClinicNestedInput
    veterinarianProfile?: VeterinarianProfileUpdateOneWithoutClinicNestedInput
    clientPet?: ClientPetUpdateManyWithoutClientNestedInput
    clinicProducts?: ClinicProductUpdateManyWithoutClinicNestedInput
  }

  export type ClientProfileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    secretaryProfile?: SecretaryProfileUncheckedUpdateOneWithoutClinicNestedInput
    veterinarianProfile?: VeterinarianProfileUncheckedUpdateOneWithoutClinicNestedInput
    clientPet?: ClientPetUncheckedUpdateManyWithoutClientNestedInput
    clinicProducts?: ClinicProductUncheckedUpdateManyWithoutClinicNestedInput
  }

  export type ClientProfileCreateManyInput = {
    id?: string
    dateOfBirth: Date | string
    address?: string | null
    phone?: string | null
    userId: string
  }

  export type ClientProfileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ClientProfileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type VeterinarianProfileCreateInput = {
    id?: string
    licenseNumber: string
    specialty: string
    yearsExperience: number
    bio?: string | null
    clinic: ClientProfileCreateNestedOneWithoutVeterinarianProfileInput
    user: UserCreateNestedOneWithoutVeterinarianProfileInput
    clinicProfiles?: ClinicProfileCreateNestedManyWithoutVeterinarianProfileInput
    clientPet?: ClientPetCreateNestedManyWithoutAttendingVeterinarianInput
    metting?: MettingCreateNestedManyWithoutVeterinarianInput
  }

  export type VeterinarianProfileUncheckedCreateInput = {
    id?: string
    licenseNumber: string
    specialty: string
    yearsExperience: number
    bio?: string | null
    clinicId: string
    userId: string
    clinicProfiles?: ClinicProfileUncheckedCreateNestedManyWithoutVeterinarianProfileInput
    clientPet?: ClientPetUncheckedCreateNestedManyWithoutAttendingVeterinarianInput
    metting?: MettingUncheckedCreateNestedManyWithoutVeterinarianInput
  }

  export type VeterinarianProfileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    licenseNumber?: StringFieldUpdateOperationsInput | string
    specialty?: StringFieldUpdateOperationsInput | string
    yearsExperience?: IntFieldUpdateOperationsInput | number
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    clinic?: ClientProfileUpdateOneRequiredWithoutVeterinarianProfileNestedInput
    user?: UserUpdateOneRequiredWithoutVeterinarianProfileNestedInput
    clinicProfiles?: ClinicProfileUpdateManyWithoutVeterinarianProfileNestedInput
    clientPet?: ClientPetUpdateManyWithoutAttendingVeterinarianNestedInput
    metting?: MettingUpdateManyWithoutVeterinarianNestedInput
  }

  export type VeterinarianProfileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    licenseNumber?: StringFieldUpdateOperationsInput | string
    specialty?: StringFieldUpdateOperationsInput | string
    yearsExperience?: IntFieldUpdateOperationsInput | number
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    clinicId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    clinicProfiles?: ClinicProfileUncheckedUpdateManyWithoutVeterinarianProfileNestedInput
    clientPet?: ClientPetUncheckedUpdateManyWithoutAttendingVeterinarianNestedInput
    metting?: MettingUncheckedUpdateManyWithoutVeterinarianNestedInput
  }

  export type VeterinarianProfileCreateManyInput = {
    id?: string
    licenseNumber: string
    specialty: string
    yearsExperience: number
    bio?: string | null
    clinicId: string
    userId: string
  }

  export type VeterinarianProfileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    licenseNumber?: StringFieldUpdateOperationsInput | string
    specialty?: StringFieldUpdateOperationsInput | string
    yearsExperience?: IntFieldUpdateOperationsInput | number
    bio?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VeterinarianProfileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    licenseNumber?: StringFieldUpdateOperationsInput | string
    specialty?: StringFieldUpdateOperationsInput | string
    yearsExperience?: IntFieldUpdateOperationsInput | number
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    clinicId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type ClinicProfileCreateInput = {
    id?: string
    name: string
    address: string
    siret: string
    phone: string
    description?: string | null
    website: string
    user: UserCreateNestedOneWithoutClinicProfileInput
    veterinarianProfile?: VeterinarianProfileCreateNestedOneWithoutClinicProfilesInput
  }

  export type ClinicProfileUncheckedCreateInput = {
    id?: string
    name: string
    address: string
    siret: string
    phone: string
    description?: string | null
    website: string
    userId: string
    veterinarianProfileId?: string | null
  }

  export type ClinicProfileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    siret?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutClinicProfileNestedInput
    veterinarianProfile?: VeterinarianProfileUpdateOneWithoutClinicProfilesNestedInput
  }

  export type ClinicProfileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    siret?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    veterinarianProfileId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ClinicProfileCreateManyInput = {
    id?: string
    name: string
    address: string
    siret: string
    phone: string
    description?: string | null
    website: string
    userId: string
    veterinarianProfileId?: string | null
  }

  export type ClinicProfileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    siret?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: StringFieldUpdateOperationsInput | string
  }

  export type ClinicProfileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    siret?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    veterinarianProfileId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SecretaryProfileCreateInput = {
    id?: string
    user: UserCreateNestedOneWithoutSecretaryProfileInput
    clinic: ClientProfileCreateNestedOneWithoutSecretaryProfileInput
  }

  export type SecretaryProfileUncheckedCreateInput = {
    id?: string
    userId: string
    clinicId: string
  }

  export type SecretaryProfileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutSecretaryProfileNestedInput
    clinic?: ClientProfileUpdateOneRequiredWithoutSecretaryProfileNestedInput
  }

  export type SecretaryProfileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    clinicId?: StringFieldUpdateOperationsInput | string
  }

  export type SecretaryProfileCreateManyInput = {
    id?: string
    userId: string
    clinicId: string
  }

  export type SecretaryProfileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type SecretaryProfileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    clinicId?: StringFieldUpdateOperationsInput | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type VeterinarianProfileNullableScalarRelationFilter = {
    is?: VeterinarianProfileWhereInput | null
    isNot?: VeterinarianProfileWhereInput | null
  }

  export type ClientProfileScalarRelationFilter = {
    is?: ClientProfileWhereInput
    isNot?: ClientProfileWhereInput
  }

  export type RaceScalarRelationFilter = {
    is?: RaceWhereInput
    isNot?: RaceWhereInput
  }

  export type PersonalPetVaccineListRelationFilter = {
    every?: PersonalPetVaccineWhereInput
    some?: PersonalPetVaccineWhereInput
    none?: PersonalPetVaccineWhereInput
  }

  export type MettingListRelationFilter = {
    every?: MettingWhereInput
    some?: MettingWhereInput
    none?: MettingWhereInput
  }

  export type FoodPetListRelationFilter = {
    every?: FoodPetWhereInput
    some?: FoodPetWhereInput
    none?: FoodPetWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type PersonalPetVaccineOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MettingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FoodPetOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClientPetCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    dateOfBirth?: SortOrder
    description?: SortOrder
    activity?: SortOrder
    attendingVeterinarianId?: SortOrder
    clientId?: SortOrder
    raceId?: SortOrder
  }

  export type ClientPetAvgOrderByAggregateInput = {
    activity?: SortOrder
  }

  export type ClientPetMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    dateOfBirth?: SortOrder
    description?: SortOrder
    activity?: SortOrder
    attendingVeterinarianId?: SortOrder
    clientId?: SortOrder
    raceId?: SortOrder
  }

  export type ClientPetMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    dateOfBirth?: SortOrder
    description?: SortOrder
    activity?: SortOrder
    attendingVeterinarianId?: SortOrder
    clientId?: SortOrder
    raceId?: SortOrder
  }

  export type ClientPetSumOrderByAggregateInput = {
    activity?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type RaceListRelationFilter = {
    every?: RaceWhereInput
    some?: RaceWhereInput
    none?: RaceWhereInput
  }

  export type VaccineListRelationFilter = {
    every?: VaccineWhereInput
    some?: VaccineWhereInput
    none?: VaccineWhereInput
  }

  export type RaceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VaccineOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PetCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    picture?: SortOrder
  }

  export type PetMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    picture?: SortOrder
  }

  export type PetMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    picture?: SortOrder
  }

  export type PetScalarRelationFilter = {
    is?: PetWhereInput
    isNot?: PetWhereInput
  }

  export type ClientPetListRelationFilter = {
    every?: ClientPetWhereInput
    some?: ClientPetWhereInput
    none?: ClientPetWhereInput
  }

  export type ClientPetOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RaceCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    picture?: SortOrder
    petId?: SortOrder
  }

  export type RaceMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    picture?: SortOrder
    petId?: SortOrder
  }

  export type RaceMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    picture?: SortOrder
    petId?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type VaccineCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    description?: SortOrder
    recommendedAge?: SortOrder
    boosterInterval?: SortOrder
    mandatoryCountry?: SortOrder
    recommendedCountry?: SortOrder
    petId?: SortOrder
  }

  export type VaccineAvgOrderByAggregateInput = {
    recommendedAge?: SortOrder
    boosterInterval?: SortOrder
  }

  export type VaccineMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    description?: SortOrder
    recommendedAge?: SortOrder
    boosterInterval?: SortOrder
    petId?: SortOrder
  }

  export type VaccineMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    description?: SortOrder
    recommendedAge?: SortOrder
    boosterInterval?: SortOrder
    petId?: SortOrder
  }

  export type VaccineSumOrderByAggregateInput = {
    recommendedAge?: SortOrder
    boosterInterval?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type ClientPetScalarRelationFilter = {
    is?: ClientPetWhereInput
    isNot?: ClientPetWhereInput
  }

  export type VaccineScalarRelationFilter = {
    is?: VaccineWhereInput
    isNot?: VaccineWhereInput
  }

  export type MettingNullableScalarRelationFilter = {
    is?: MettingWhereInput | null
    isNot?: MettingWhereInput | null
  }

  export type PersonalPetVaccineCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clientPetId?: SortOrder
    vaccineId?: SortOrder
    mettingId?: SortOrder
  }

  export type PersonalPetVaccineMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clientPetId?: SortOrder
    vaccineId?: SortOrder
    mettingId?: SortOrder
  }

  export type PersonalPetVaccineMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clientPetId?: SortOrder
    vaccineId?: SortOrder
    mettingId?: SortOrder
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type VeterinarianProfileScalarRelationFilter = {
    is?: VeterinarianProfileWhereInput
    isNot?: VeterinarianProfileWhereInput
  }

  export type MettingCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    date?: SortOrder
    duration?: SortOrder
    description?: SortOrder
    petWeight?: SortOrder
    petSize?: SortOrder
    clientPetId?: SortOrder
    veterinarianId?: SortOrder
  }

  export type MettingAvgOrderByAggregateInput = {
    duration?: SortOrder
    petWeight?: SortOrder
    petSize?: SortOrder
  }

  export type MettingMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    date?: SortOrder
    duration?: SortOrder
    description?: SortOrder
    petWeight?: SortOrder
    petSize?: SortOrder
    clientPetId?: SortOrder
    veterinarianId?: SortOrder
  }

  export type MettingMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    date?: SortOrder
    duration?: SortOrder
    description?: SortOrder
    petWeight?: SortOrder
    petSize?: SortOrder
    clientPetId?: SortOrder
    veterinarianId?: SortOrder
  }

  export type MettingSumOrderByAggregateInput = {
    duration?: SortOrder
    petWeight?: SortOrder
    petSize?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type BrandScalarRelationFilter = {
    is?: BrandWhereInput
    isNot?: BrandWhereInput
  }

  export type ClinicProductListRelationFilter = {
    every?: ClinicProductWhereInput
    some?: ClinicProductWhereInput
    none?: ClinicProductWhereInput
  }

  export type FoodNullableScalarRelationFilter = {
    is?: FoodWhereInput | null
    isNot?: FoodWhereInput | null
  }

  export type ClinicProductOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    description?: SortOrder
    qrCode?: SortOrder
    websiteUrl?: SortOrder
    picture?: SortOrder
    brandId?: SortOrder
  }

  export type ProductMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    description?: SortOrder
    qrCode?: SortOrder
    websiteUrl?: SortOrder
    picture?: SortOrder
    brandId?: SortOrder
  }

  export type ProductMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    description?: SortOrder
    qrCode?: SortOrder
    websiteUrl?: SortOrder
    picture?: SortOrder
    brandId?: SortOrder
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type EnumFoodTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.FoodType | EnumFoodTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FoodType[] | ListEnumFoodTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FoodType[] | ListEnumFoodTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFoodTypeFilter<$PrismaModel> | $Enums.FoodType
  }

  export type ProductScalarRelationFilter = {
    is?: ProductWhereInput
    isNot?: ProductWhereInput
  }

  export type FoodCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    caloriesPer100?: SortOrder
    proteinPer100?: SortOrder
    fatPercentage?: SortOrder
    fiberPercentage?: SortOrder
    moisturePercentage?: SortOrder
    type?: SortOrder
    productId?: SortOrder
  }

  export type FoodAvgOrderByAggregateInput = {
    caloriesPer100?: SortOrder
    proteinPer100?: SortOrder
    fatPercentage?: SortOrder
    fiberPercentage?: SortOrder
    moisturePercentage?: SortOrder
  }

  export type FoodMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    caloriesPer100?: SortOrder
    proteinPer100?: SortOrder
    fatPercentage?: SortOrder
    fiberPercentage?: SortOrder
    moisturePercentage?: SortOrder
    type?: SortOrder
    productId?: SortOrder
  }

  export type FoodMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    caloriesPer100?: SortOrder
    proteinPer100?: SortOrder
    fatPercentage?: SortOrder
    fiberPercentage?: SortOrder
    moisturePercentage?: SortOrder
    type?: SortOrder
    productId?: SortOrder
  }

  export type FoodSumOrderByAggregateInput = {
    caloriesPer100?: SortOrder
    proteinPer100?: SortOrder
    fatPercentage?: SortOrder
    fiberPercentage?: SortOrder
    moisturePercentage?: SortOrder
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type EnumFoodTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FoodType | EnumFoodTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FoodType[] | ListEnumFoodTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FoodType[] | ListEnumFoodTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFoodTypeWithAggregatesFilter<$PrismaModel> | $Enums.FoodType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFoodTypeFilter<$PrismaModel>
    _max?: NestedEnumFoodTypeFilter<$PrismaModel>
  }

  export type ProductListRelationFilter = {
    every?: ProductWhereInput
    some?: ProductWhereInput
    none?: ProductWhereInput
  }

  export type ProductOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BrandCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    logo?: SortOrder
  }

  export type BrandMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    logo?: SortOrder
  }

  export type BrandMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    logo?: SortOrder
  }

  export type ClinicProductCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    stock?: SortOrder
    minimumRequired?: SortOrder
    clinicId?: SortOrder
    productId?: SortOrder
  }

  export type ClinicProductAvgOrderByAggregateInput = {
    stock?: SortOrder
    minimumRequired?: SortOrder
  }

  export type ClinicProductMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    stock?: SortOrder
    minimumRequired?: SortOrder
    clinicId?: SortOrder
    productId?: SortOrder
  }

  export type ClinicProductMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    stock?: SortOrder
    minimumRequired?: SortOrder
    clinicId?: SortOrder
    productId?: SortOrder
  }

  export type ClinicProductSumOrderByAggregateInput = {
    stock?: SortOrder
    minimumRequired?: SortOrder
  }

  export type EnumFoodPetDayFilter<$PrismaModel = never> = {
    equals?: $Enums.FoodPetDay | EnumFoodPetDayFieldRefInput<$PrismaModel>
    in?: $Enums.FoodPetDay[] | ListEnumFoodPetDayFieldRefInput<$PrismaModel>
    notIn?: $Enums.FoodPetDay[] | ListEnumFoodPetDayFieldRefInput<$PrismaModel>
    not?: NestedEnumFoodPetDayFilter<$PrismaModel> | $Enums.FoodPetDay
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type FoodScalarRelationFilter = {
    is?: FoodWhereInput
    isNot?: FoodWhereInput
  }

  export type FoodPetCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    type?: SortOrder
    dateStart?: SortOrder
    dateEnd?: SortOrder
    quantity?: SortOrder
    hours?: SortOrder
    foodId?: SortOrder
    clientPetId?: SortOrder
  }

  export type FoodPetAvgOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type FoodPetMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    type?: SortOrder
    dateStart?: SortOrder
    dateEnd?: SortOrder
    quantity?: SortOrder
    hours?: SortOrder
    foodId?: SortOrder
    clientPetId?: SortOrder
  }

  export type FoodPetMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    type?: SortOrder
    dateStart?: SortOrder
    dateEnd?: SortOrder
    quantity?: SortOrder
    hours?: SortOrder
    foodId?: SortOrder
    clientPetId?: SortOrder
  }

  export type FoodPetSumOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type EnumFoodPetDayWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FoodPetDay | EnumFoodPetDayFieldRefInput<$PrismaModel>
    in?: $Enums.FoodPetDay[] | ListEnumFoodPetDayFieldRefInput<$PrismaModel>
    notIn?: $Enums.FoodPetDay[] | ListEnumFoodPetDayFieldRefInput<$PrismaModel>
    not?: NestedEnumFoodPetDayWithAggregatesFilter<$PrismaModel> | $Enums.FoodPetDay
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFoodPetDayFilter<$PrismaModel>
    _max?: NestedEnumFoodPetDayFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type ClientProfileNullableScalarRelationFilter = {
    is?: ClientProfileWhereInput | null
    isNot?: ClientProfileWhereInput | null
  }

  export type ClinicProfileNullableScalarRelationFilter = {
    is?: ClinicProfileWhereInput | null
    isNot?: ClinicProfileWhereInput | null
  }

  export type SecretaryProfileNullableScalarRelationFilter = {
    is?: SecretaryProfileWhereInput | null
    isNot?: SecretaryProfileWhereInput | null
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    firstname?: SortOrder
    lastname?: SortOrder
    password?: SortOrder
    picture?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    firstname?: SortOrder
    lastname?: SortOrder
    password?: SortOrder
    picture?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    firstname?: SortOrder
    lastname?: SortOrder
    password?: SortOrder
    picture?: SortOrder
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type ClientProfileCountOrderByAggregateInput = {
    id?: SortOrder
    dateOfBirth?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    userId?: SortOrder
  }

  export type ClientProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    dateOfBirth?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    userId?: SortOrder
  }

  export type ClientProfileMinOrderByAggregateInput = {
    id?: SortOrder
    dateOfBirth?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    userId?: SortOrder
  }

  export type ClinicProfileListRelationFilter = {
    every?: ClinicProfileWhereInput
    some?: ClinicProfileWhereInput
    none?: ClinicProfileWhereInput
  }

  export type ClinicProfileOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VeterinarianProfileCountOrderByAggregateInput = {
    id?: SortOrder
    licenseNumber?: SortOrder
    specialty?: SortOrder
    yearsExperience?: SortOrder
    bio?: SortOrder
    clinicId?: SortOrder
    userId?: SortOrder
  }

  export type VeterinarianProfileAvgOrderByAggregateInput = {
    yearsExperience?: SortOrder
  }

  export type VeterinarianProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    licenseNumber?: SortOrder
    specialty?: SortOrder
    yearsExperience?: SortOrder
    bio?: SortOrder
    clinicId?: SortOrder
    userId?: SortOrder
  }

  export type VeterinarianProfileMinOrderByAggregateInput = {
    id?: SortOrder
    licenseNumber?: SortOrder
    specialty?: SortOrder
    yearsExperience?: SortOrder
    bio?: SortOrder
    clinicId?: SortOrder
    userId?: SortOrder
  }

  export type VeterinarianProfileSumOrderByAggregateInput = {
    yearsExperience?: SortOrder
  }

  export type ClinicProfileCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    siret?: SortOrder
    phone?: SortOrder
    description?: SortOrder
    website?: SortOrder
    userId?: SortOrder
    veterinarianProfileId?: SortOrder
  }

  export type ClinicProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    siret?: SortOrder
    phone?: SortOrder
    description?: SortOrder
    website?: SortOrder
    userId?: SortOrder
    veterinarianProfileId?: SortOrder
  }

  export type ClinicProfileMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    siret?: SortOrder
    phone?: SortOrder
    description?: SortOrder
    website?: SortOrder
    userId?: SortOrder
    veterinarianProfileId?: SortOrder
  }

  export type SecretaryProfileCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    clinicId?: SortOrder
  }

  export type SecretaryProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    clinicId?: SortOrder
  }

  export type SecretaryProfileMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    clinicId?: SortOrder
  }

  export type VeterinarianProfileCreateNestedOneWithoutClientPetInput = {
    create?: XOR<VeterinarianProfileCreateWithoutClientPetInput, VeterinarianProfileUncheckedCreateWithoutClientPetInput>
    connectOrCreate?: VeterinarianProfileCreateOrConnectWithoutClientPetInput
    connect?: VeterinarianProfileWhereUniqueInput
  }

  export type ClientProfileCreateNestedOneWithoutClientPetInput = {
    create?: XOR<ClientProfileCreateWithoutClientPetInput, ClientProfileUncheckedCreateWithoutClientPetInput>
    connectOrCreate?: ClientProfileCreateOrConnectWithoutClientPetInput
    connect?: ClientProfileWhereUniqueInput
  }

  export type RaceCreateNestedOneWithoutClientPetInput = {
    create?: XOR<RaceCreateWithoutClientPetInput, RaceUncheckedCreateWithoutClientPetInput>
    connectOrCreate?: RaceCreateOrConnectWithoutClientPetInput
    connect?: RaceWhereUniqueInput
  }

  export type PersonalPetVaccineCreateNestedManyWithoutClientPetInput = {
    create?: XOR<PersonalPetVaccineCreateWithoutClientPetInput, PersonalPetVaccineUncheckedCreateWithoutClientPetInput> | PersonalPetVaccineCreateWithoutClientPetInput[] | PersonalPetVaccineUncheckedCreateWithoutClientPetInput[]
    connectOrCreate?: PersonalPetVaccineCreateOrConnectWithoutClientPetInput | PersonalPetVaccineCreateOrConnectWithoutClientPetInput[]
    createMany?: PersonalPetVaccineCreateManyClientPetInputEnvelope
    connect?: PersonalPetVaccineWhereUniqueInput | PersonalPetVaccineWhereUniqueInput[]
  }

  export type MettingCreateNestedManyWithoutClientPetInput = {
    create?: XOR<MettingCreateWithoutClientPetInput, MettingUncheckedCreateWithoutClientPetInput> | MettingCreateWithoutClientPetInput[] | MettingUncheckedCreateWithoutClientPetInput[]
    connectOrCreate?: MettingCreateOrConnectWithoutClientPetInput | MettingCreateOrConnectWithoutClientPetInput[]
    createMany?: MettingCreateManyClientPetInputEnvelope
    connect?: MettingWhereUniqueInput | MettingWhereUniqueInput[]
  }

  export type FoodPetCreateNestedManyWithoutClientPetInput = {
    create?: XOR<FoodPetCreateWithoutClientPetInput, FoodPetUncheckedCreateWithoutClientPetInput> | FoodPetCreateWithoutClientPetInput[] | FoodPetUncheckedCreateWithoutClientPetInput[]
    connectOrCreate?: FoodPetCreateOrConnectWithoutClientPetInput | FoodPetCreateOrConnectWithoutClientPetInput[]
    createMany?: FoodPetCreateManyClientPetInputEnvelope
    connect?: FoodPetWhereUniqueInput | FoodPetWhereUniqueInput[]
  }

  export type PersonalPetVaccineUncheckedCreateNestedManyWithoutClientPetInput = {
    create?: XOR<PersonalPetVaccineCreateWithoutClientPetInput, PersonalPetVaccineUncheckedCreateWithoutClientPetInput> | PersonalPetVaccineCreateWithoutClientPetInput[] | PersonalPetVaccineUncheckedCreateWithoutClientPetInput[]
    connectOrCreate?: PersonalPetVaccineCreateOrConnectWithoutClientPetInput | PersonalPetVaccineCreateOrConnectWithoutClientPetInput[]
    createMany?: PersonalPetVaccineCreateManyClientPetInputEnvelope
    connect?: PersonalPetVaccineWhereUniqueInput | PersonalPetVaccineWhereUniqueInput[]
  }

  export type MettingUncheckedCreateNestedManyWithoutClientPetInput = {
    create?: XOR<MettingCreateWithoutClientPetInput, MettingUncheckedCreateWithoutClientPetInput> | MettingCreateWithoutClientPetInput[] | MettingUncheckedCreateWithoutClientPetInput[]
    connectOrCreate?: MettingCreateOrConnectWithoutClientPetInput | MettingCreateOrConnectWithoutClientPetInput[]
    createMany?: MettingCreateManyClientPetInputEnvelope
    connect?: MettingWhereUniqueInput | MettingWhereUniqueInput[]
  }

  export type FoodPetUncheckedCreateNestedManyWithoutClientPetInput = {
    create?: XOR<FoodPetCreateWithoutClientPetInput, FoodPetUncheckedCreateWithoutClientPetInput> | FoodPetCreateWithoutClientPetInput[] | FoodPetUncheckedCreateWithoutClientPetInput[]
    connectOrCreate?: FoodPetCreateOrConnectWithoutClientPetInput | FoodPetCreateOrConnectWithoutClientPetInput[]
    createMany?: FoodPetCreateManyClientPetInputEnvelope
    connect?: FoodPetWhereUniqueInput | FoodPetWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type VeterinarianProfileUpdateOneWithoutClientPetNestedInput = {
    create?: XOR<VeterinarianProfileCreateWithoutClientPetInput, VeterinarianProfileUncheckedCreateWithoutClientPetInput>
    connectOrCreate?: VeterinarianProfileCreateOrConnectWithoutClientPetInput
    upsert?: VeterinarianProfileUpsertWithoutClientPetInput
    disconnect?: VeterinarianProfileWhereInput | boolean
    delete?: VeterinarianProfileWhereInput | boolean
    connect?: VeterinarianProfileWhereUniqueInput
    update?: XOR<XOR<VeterinarianProfileUpdateToOneWithWhereWithoutClientPetInput, VeterinarianProfileUpdateWithoutClientPetInput>, VeterinarianProfileUncheckedUpdateWithoutClientPetInput>
  }

  export type ClientProfileUpdateOneRequiredWithoutClientPetNestedInput = {
    create?: XOR<ClientProfileCreateWithoutClientPetInput, ClientProfileUncheckedCreateWithoutClientPetInput>
    connectOrCreate?: ClientProfileCreateOrConnectWithoutClientPetInput
    upsert?: ClientProfileUpsertWithoutClientPetInput
    connect?: ClientProfileWhereUniqueInput
    update?: XOR<XOR<ClientProfileUpdateToOneWithWhereWithoutClientPetInput, ClientProfileUpdateWithoutClientPetInput>, ClientProfileUncheckedUpdateWithoutClientPetInput>
  }

  export type RaceUpdateOneRequiredWithoutClientPetNestedInput = {
    create?: XOR<RaceCreateWithoutClientPetInput, RaceUncheckedCreateWithoutClientPetInput>
    connectOrCreate?: RaceCreateOrConnectWithoutClientPetInput
    upsert?: RaceUpsertWithoutClientPetInput
    connect?: RaceWhereUniqueInput
    update?: XOR<XOR<RaceUpdateToOneWithWhereWithoutClientPetInput, RaceUpdateWithoutClientPetInput>, RaceUncheckedUpdateWithoutClientPetInput>
  }

  export type PersonalPetVaccineUpdateManyWithoutClientPetNestedInput = {
    create?: XOR<PersonalPetVaccineCreateWithoutClientPetInput, PersonalPetVaccineUncheckedCreateWithoutClientPetInput> | PersonalPetVaccineCreateWithoutClientPetInput[] | PersonalPetVaccineUncheckedCreateWithoutClientPetInput[]
    connectOrCreate?: PersonalPetVaccineCreateOrConnectWithoutClientPetInput | PersonalPetVaccineCreateOrConnectWithoutClientPetInput[]
    upsert?: PersonalPetVaccineUpsertWithWhereUniqueWithoutClientPetInput | PersonalPetVaccineUpsertWithWhereUniqueWithoutClientPetInput[]
    createMany?: PersonalPetVaccineCreateManyClientPetInputEnvelope
    set?: PersonalPetVaccineWhereUniqueInput | PersonalPetVaccineWhereUniqueInput[]
    disconnect?: PersonalPetVaccineWhereUniqueInput | PersonalPetVaccineWhereUniqueInput[]
    delete?: PersonalPetVaccineWhereUniqueInput | PersonalPetVaccineWhereUniqueInput[]
    connect?: PersonalPetVaccineWhereUniqueInput | PersonalPetVaccineWhereUniqueInput[]
    update?: PersonalPetVaccineUpdateWithWhereUniqueWithoutClientPetInput | PersonalPetVaccineUpdateWithWhereUniqueWithoutClientPetInput[]
    updateMany?: PersonalPetVaccineUpdateManyWithWhereWithoutClientPetInput | PersonalPetVaccineUpdateManyWithWhereWithoutClientPetInput[]
    deleteMany?: PersonalPetVaccineScalarWhereInput | PersonalPetVaccineScalarWhereInput[]
  }

  export type MettingUpdateManyWithoutClientPetNestedInput = {
    create?: XOR<MettingCreateWithoutClientPetInput, MettingUncheckedCreateWithoutClientPetInput> | MettingCreateWithoutClientPetInput[] | MettingUncheckedCreateWithoutClientPetInput[]
    connectOrCreate?: MettingCreateOrConnectWithoutClientPetInput | MettingCreateOrConnectWithoutClientPetInput[]
    upsert?: MettingUpsertWithWhereUniqueWithoutClientPetInput | MettingUpsertWithWhereUniqueWithoutClientPetInput[]
    createMany?: MettingCreateManyClientPetInputEnvelope
    set?: MettingWhereUniqueInput | MettingWhereUniqueInput[]
    disconnect?: MettingWhereUniqueInput | MettingWhereUniqueInput[]
    delete?: MettingWhereUniqueInput | MettingWhereUniqueInput[]
    connect?: MettingWhereUniqueInput | MettingWhereUniqueInput[]
    update?: MettingUpdateWithWhereUniqueWithoutClientPetInput | MettingUpdateWithWhereUniqueWithoutClientPetInput[]
    updateMany?: MettingUpdateManyWithWhereWithoutClientPetInput | MettingUpdateManyWithWhereWithoutClientPetInput[]
    deleteMany?: MettingScalarWhereInput | MettingScalarWhereInput[]
  }

  export type FoodPetUpdateManyWithoutClientPetNestedInput = {
    create?: XOR<FoodPetCreateWithoutClientPetInput, FoodPetUncheckedCreateWithoutClientPetInput> | FoodPetCreateWithoutClientPetInput[] | FoodPetUncheckedCreateWithoutClientPetInput[]
    connectOrCreate?: FoodPetCreateOrConnectWithoutClientPetInput | FoodPetCreateOrConnectWithoutClientPetInput[]
    upsert?: FoodPetUpsertWithWhereUniqueWithoutClientPetInput | FoodPetUpsertWithWhereUniqueWithoutClientPetInput[]
    createMany?: FoodPetCreateManyClientPetInputEnvelope
    set?: FoodPetWhereUniqueInput | FoodPetWhereUniqueInput[]
    disconnect?: FoodPetWhereUniqueInput | FoodPetWhereUniqueInput[]
    delete?: FoodPetWhereUniqueInput | FoodPetWhereUniqueInput[]
    connect?: FoodPetWhereUniqueInput | FoodPetWhereUniqueInput[]
    update?: FoodPetUpdateWithWhereUniqueWithoutClientPetInput | FoodPetUpdateWithWhereUniqueWithoutClientPetInput[]
    updateMany?: FoodPetUpdateManyWithWhereWithoutClientPetInput | FoodPetUpdateManyWithWhereWithoutClientPetInput[]
    deleteMany?: FoodPetScalarWhereInput | FoodPetScalarWhereInput[]
  }

  export type PersonalPetVaccineUncheckedUpdateManyWithoutClientPetNestedInput = {
    create?: XOR<PersonalPetVaccineCreateWithoutClientPetInput, PersonalPetVaccineUncheckedCreateWithoutClientPetInput> | PersonalPetVaccineCreateWithoutClientPetInput[] | PersonalPetVaccineUncheckedCreateWithoutClientPetInput[]
    connectOrCreate?: PersonalPetVaccineCreateOrConnectWithoutClientPetInput | PersonalPetVaccineCreateOrConnectWithoutClientPetInput[]
    upsert?: PersonalPetVaccineUpsertWithWhereUniqueWithoutClientPetInput | PersonalPetVaccineUpsertWithWhereUniqueWithoutClientPetInput[]
    createMany?: PersonalPetVaccineCreateManyClientPetInputEnvelope
    set?: PersonalPetVaccineWhereUniqueInput | PersonalPetVaccineWhereUniqueInput[]
    disconnect?: PersonalPetVaccineWhereUniqueInput | PersonalPetVaccineWhereUniqueInput[]
    delete?: PersonalPetVaccineWhereUniqueInput | PersonalPetVaccineWhereUniqueInput[]
    connect?: PersonalPetVaccineWhereUniqueInput | PersonalPetVaccineWhereUniqueInput[]
    update?: PersonalPetVaccineUpdateWithWhereUniqueWithoutClientPetInput | PersonalPetVaccineUpdateWithWhereUniqueWithoutClientPetInput[]
    updateMany?: PersonalPetVaccineUpdateManyWithWhereWithoutClientPetInput | PersonalPetVaccineUpdateManyWithWhereWithoutClientPetInput[]
    deleteMany?: PersonalPetVaccineScalarWhereInput | PersonalPetVaccineScalarWhereInput[]
  }

  export type MettingUncheckedUpdateManyWithoutClientPetNestedInput = {
    create?: XOR<MettingCreateWithoutClientPetInput, MettingUncheckedCreateWithoutClientPetInput> | MettingCreateWithoutClientPetInput[] | MettingUncheckedCreateWithoutClientPetInput[]
    connectOrCreate?: MettingCreateOrConnectWithoutClientPetInput | MettingCreateOrConnectWithoutClientPetInput[]
    upsert?: MettingUpsertWithWhereUniqueWithoutClientPetInput | MettingUpsertWithWhereUniqueWithoutClientPetInput[]
    createMany?: MettingCreateManyClientPetInputEnvelope
    set?: MettingWhereUniqueInput | MettingWhereUniqueInput[]
    disconnect?: MettingWhereUniqueInput | MettingWhereUniqueInput[]
    delete?: MettingWhereUniqueInput | MettingWhereUniqueInput[]
    connect?: MettingWhereUniqueInput | MettingWhereUniqueInput[]
    update?: MettingUpdateWithWhereUniqueWithoutClientPetInput | MettingUpdateWithWhereUniqueWithoutClientPetInput[]
    updateMany?: MettingUpdateManyWithWhereWithoutClientPetInput | MettingUpdateManyWithWhereWithoutClientPetInput[]
    deleteMany?: MettingScalarWhereInput | MettingScalarWhereInput[]
  }

  export type FoodPetUncheckedUpdateManyWithoutClientPetNestedInput = {
    create?: XOR<FoodPetCreateWithoutClientPetInput, FoodPetUncheckedCreateWithoutClientPetInput> | FoodPetCreateWithoutClientPetInput[] | FoodPetUncheckedCreateWithoutClientPetInput[]
    connectOrCreate?: FoodPetCreateOrConnectWithoutClientPetInput | FoodPetCreateOrConnectWithoutClientPetInput[]
    upsert?: FoodPetUpsertWithWhereUniqueWithoutClientPetInput | FoodPetUpsertWithWhereUniqueWithoutClientPetInput[]
    createMany?: FoodPetCreateManyClientPetInputEnvelope
    set?: FoodPetWhereUniqueInput | FoodPetWhereUniqueInput[]
    disconnect?: FoodPetWhereUniqueInput | FoodPetWhereUniqueInput[]
    delete?: FoodPetWhereUniqueInput | FoodPetWhereUniqueInput[]
    connect?: FoodPetWhereUniqueInput | FoodPetWhereUniqueInput[]
    update?: FoodPetUpdateWithWhereUniqueWithoutClientPetInput | FoodPetUpdateWithWhereUniqueWithoutClientPetInput[]
    updateMany?: FoodPetUpdateManyWithWhereWithoutClientPetInput | FoodPetUpdateManyWithWhereWithoutClientPetInput[]
    deleteMany?: FoodPetScalarWhereInput | FoodPetScalarWhereInput[]
  }

  export type RaceCreateNestedManyWithoutPetInput = {
    create?: XOR<RaceCreateWithoutPetInput, RaceUncheckedCreateWithoutPetInput> | RaceCreateWithoutPetInput[] | RaceUncheckedCreateWithoutPetInput[]
    connectOrCreate?: RaceCreateOrConnectWithoutPetInput | RaceCreateOrConnectWithoutPetInput[]
    createMany?: RaceCreateManyPetInputEnvelope
    connect?: RaceWhereUniqueInput | RaceWhereUniqueInput[]
  }

  export type VaccineCreateNestedManyWithoutPetInput = {
    create?: XOR<VaccineCreateWithoutPetInput, VaccineUncheckedCreateWithoutPetInput> | VaccineCreateWithoutPetInput[] | VaccineUncheckedCreateWithoutPetInput[]
    connectOrCreate?: VaccineCreateOrConnectWithoutPetInput | VaccineCreateOrConnectWithoutPetInput[]
    createMany?: VaccineCreateManyPetInputEnvelope
    connect?: VaccineWhereUniqueInput | VaccineWhereUniqueInput[]
  }

  export type RaceUncheckedCreateNestedManyWithoutPetInput = {
    create?: XOR<RaceCreateWithoutPetInput, RaceUncheckedCreateWithoutPetInput> | RaceCreateWithoutPetInput[] | RaceUncheckedCreateWithoutPetInput[]
    connectOrCreate?: RaceCreateOrConnectWithoutPetInput | RaceCreateOrConnectWithoutPetInput[]
    createMany?: RaceCreateManyPetInputEnvelope
    connect?: RaceWhereUniqueInput | RaceWhereUniqueInput[]
  }

  export type VaccineUncheckedCreateNestedManyWithoutPetInput = {
    create?: XOR<VaccineCreateWithoutPetInput, VaccineUncheckedCreateWithoutPetInput> | VaccineCreateWithoutPetInput[] | VaccineUncheckedCreateWithoutPetInput[]
    connectOrCreate?: VaccineCreateOrConnectWithoutPetInput | VaccineCreateOrConnectWithoutPetInput[]
    createMany?: VaccineCreateManyPetInputEnvelope
    connect?: VaccineWhereUniqueInput | VaccineWhereUniqueInput[]
  }

  export type RaceUpdateManyWithoutPetNestedInput = {
    create?: XOR<RaceCreateWithoutPetInput, RaceUncheckedCreateWithoutPetInput> | RaceCreateWithoutPetInput[] | RaceUncheckedCreateWithoutPetInput[]
    connectOrCreate?: RaceCreateOrConnectWithoutPetInput | RaceCreateOrConnectWithoutPetInput[]
    upsert?: RaceUpsertWithWhereUniqueWithoutPetInput | RaceUpsertWithWhereUniqueWithoutPetInput[]
    createMany?: RaceCreateManyPetInputEnvelope
    set?: RaceWhereUniqueInput | RaceWhereUniqueInput[]
    disconnect?: RaceWhereUniqueInput | RaceWhereUniqueInput[]
    delete?: RaceWhereUniqueInput | RaceWhereUniqueInput[]
    connect?: RaceWhereUniqueInput | RaceWhereUniqueInput[]
    update?: RaceUpdateWithWhereUniqueWithoutPetInput | RaceUpdateWithWhereUniqueWithoutPetInput[]
    updateMany?: RaceUpdateManyWithWhereWithoutPetInput | RaceUpdateManyWithWhereWithoutPetInput[]
    deleteMany?: RaceScalarWhereInput | RaceScalarWhereInput[]
  }

  export type VaccineUpdateManyWithoutPetNestedInput = {
    create?: XOR<VaccineCreateWithoutPetInput, VaccineUncheckedCreateWithoutPetInput> | VaccineCreateWithoutPetInput[] | VaccineUncheckedCreateWithoutPetInput[]
    connectOrCreate?: VaccineCreateOrConnectWithoutPetInput | VaccineCreateOrConnectWithoutPetInput[]
    upsert?: VaccineUpsertWithWhereUniqueWithoutPetInput | VaccineUpsertWithWhereUniqueWithoutPetInput[]
    createMany?: VaccineCreateManyPetInputEnvelope
    set?: VaccineWhereUniqueInput | VaccineWhereUniqueInput[]
    disconnect?: VaccineWhereUniqueInput | VaccineWhereUniqueInput[]
    delete?: VaccineWhereUniqueInput | VaccineWhereUniqueInput[]
    connect?: VaccineWhereUniqueInput | VaccineWhereUniqueInput[]
    update?: VaccineUpdateWithWhereUniqueWithoutPetInput | VaccineUpdateWithWhereUniqueWithoutPetInput[]
    updateMany?: VaccineUpdateManyWithWhereWithoutPetInput | VaccineUpdateManyWithWhereWithoutPetInput[]
    deleteMany?: VaccineScalarWhereInput | VaccineScalarWhereInput[]
  }

  export type RaceUncheckedUpdateManyWithoutPetNestedInput = {
    create?: XOR<RaceCreateWithoutPetInput, RaceUncheckedCreateWithoutPetInput> | RaceCreateWithoutPetInput[] | RaceUncheckedCreateWithoutPetInput[]
    connectOrCreate?: RaceCreateOrConnectWithoutPetInput | RaceCreateOrConnectWithoutPetInput[]
    upsert?: RaceUpsertWithWhereUniqueWithoutPetInput | RaceUpsertWithWhereUniqueWithoutPetInput[]
    createMany?: RaceCreateManyPetInputEnvelope
    set?: RaceWhereUniqueInput | RaceWhereUniqueInput[]
    disconnect?: RaceWhereUniqueInput | RaceWhereUniqueInput[]
    delete?: RaceWhereUniqueInput | RaceWhereUniqueInput[]
    connect?: RaceWhereUniqueInput | RaceWhereUniqueInput[]
    update?: RaceUpdateWithWhereUniqueWithoutPetInput | RaceUpdateWithWhereUniqueWithoutPetInput[]
    updateMany?: RaceUpdateManyWithWhereWithoutPetInput | RaceUpdateManyWithWhereWithoutPetInput[]
    deleteMany?: RaceScalarWhereInput | RaceScalarWhereInput[]
  }

  export type VaccineUncheckedUpdateManyWithoutPetNestedInput = {
    create?: XOR<VaccineCreateWithoutPetInput, VaccineUncheckedCreateWithoutPetInput> | VaccineCreateWithoutPetInput[] | VaccineUncheckedCreateWithoutPetInput[]
    connectOrCreate?: VaccineCreateOrConnectWithoutPetInput | VaccineCreateOrConnectWithoutPetInput[]
    upsert?: VaccineUpsertWithWhereUniqueWithoutPetInput | VaccineUpsertWithWhereUniqueWithoutPetInput[]
    createMany?: VaccineCreateManyPetInputEnvelope
    set?: VaccineWhereUniqueInput | VaccineWhereUniqueInput[]
    disconnect?: VaccineWhereUniqueInput | VaccineWhereUniqueInput[]
    delete?: VaccineWhereUniqueInput | VaccineWhereUniqueInput[]
    connect?: VaccineWhereUniqueInput | VaccineWhereUniqueInput[]
    update?: VaccineUpdateWithWhereUniqueWithoutPetInput | VaccineUpdateWithWhereUniqueWithoutPetInput[]
    updateMany?: VaccineUpdateManyWithWhereWithoutPetInput | VaccineUpdateManyWithWhereWithoutPetInput[]
    deleteMany?: VaccineScalarWhereInput | VaccineScalarWhereInput[]
  }

  export type PetCreateNestedOneWithoutRacesInput = {
    create?: XOR<PetCreateWithoutRacesInput, PetUncheckedCreateWithoutRacesInput>
    connectOrCreate?: PetCreateOrConnectWithoutRacesInput
    connect?: PetWhereUniqueInput
  }

  export type ClientPetCreateNestedManyWithoutRaceInput = {
    create?: XOR<ClientPetCreateWithoutRaceInput, ClientPetUncheckedCreateWithoutRaceInput> | ClientPetCreateWithoutRaceInput[] | ClientPetUncheckedCreateWithoutRaceInput[]
    connectOrCreate?: ClientPetCreateOrConnectWithoutRaceInput | ClientPetCreateOrConnectWithoutRaceInput[]
    createMany?: ClientPetCreateManyRaceInputEnvelope
    connect?: ClientPetWhereUniqueInput | ClientPetWhereUniqueInput[]
  }

  export type ClientPetUncheckedCreateNestedManyWithoutRaceInput = {
    create?: XOR<ClientPetCreateWithoutRaceInput, ClientPetUncheckedCreateWithoutRaceInput> | ClientPetCreateWithoutRaceInput[] | ClientPetUncheckedCreateWithoutRaceInput[]
    connectOrCreate?: ClientPetCreateOrConnectWithoutRaceInput | ClientPetCreateOrConnectWithoutRaceInput[]
    createMany?: ClientPetCreateManyRaceInputEnvelope
    connect?: ClientPetWhereUniqueInput | ClientPetWhereUniqueInput[]
  }

  export type PetUpdateOneRequiredWithoutRacesNestedInput = {
    create?: XOR<PetCreateWithoutRacesInput, PetUncheckedCreateWithoutRacesInput>
    connectOrCreate?: PetCreateOrConnectWithoutRacesInput
    upsert?: PetUpsertWithoutRacesInput
    connect?: PetWhereUniqueInput
    update?: XOR<XOR<PetUpdateToOneWithWhereWithoutRacesInput, PetUpdateWithoutRacesInput>, PetUncheckedUpdateWithoutRacesInput>
  }

  export type ClientPetUpdateManyWithoutRaceNestedInput = {
    create?: XOR<ClientPetCreateWithoutRaceInput, ClientPetUncheckedCreateWithoutRaceInput> | ClientPetCreateWithoutRaceInput[] | ClientPetUncheckedCreateWithoutRaceInput[]
    connectOrCreate?: ClientPetCreateOrConnectWithoutRaceInput | ClientPetCreateOrConnectWithoutRaceInput[]
    upsert?: ClientPetUpsertWithWhereUniqueWithoutRaceInput | ClientPetUpsertWithWhereUniqueWithoutRaceInput[]
    createMany?: ClientPetCreateManyRaceInputEnvelope
    set?: ClientPetWhereUniqueInput | ClientPetWhereUniqueInput[]
    disconnect?: ClientPetWhereUniqueInput | ClientPetWhereUniqueInput[]
    delete?: ClientPetWhereUniqueInput | ClientPetWhereUniqueInput[]
    connect?: ClientPetWhereUniqueInput | ClientPetWhereUniqueInput[]
    update?: ClientPetUpdateWithWhereUniqueWithoutRaceInput | ClientPetUpdateWithWhereUniqueWithoutRaceInput[]
    updateMany?: ClientPetUpdateManyWithWhereWithoutRaceInput | ClientPetUpdateManyWithWhereWithoutRaceInput[]
    deleteMany?: ClientPetScalarWhereInput | ClientPetScalarWhereInput[]
  }

  export type ClientPetUncheckedUpdateManyWithoutRaceNestedInput = {
    create?: XOR<ClientPetCreateWithoutRaceInput, ClientPetUncheckedCreateWithoutRaceInput> | ClientPetCreateWithoutRaceInput[] | ClientPetUncheckedCreateWithoutRaceInput[]
    connectOrCreate?: ClientPetCreateOrConnectWithoutRaceInput | ClientPetCreateOrConnectWithoutRaceInput[]
    upsert?: ClientPetUpsertWithWhereUniqueWithoutRaceInput | ClientPetUpsertWithWhereUniqueWithoutRaceInput[]
    createMany?: ClientPetCreateManyRaceInputEnvelope
    set?: ClientPetWhereUniqueInput | ClientPetWhereUniqueInput[]
    disconnect?: ClientPetWhereUniqueInput | ClientPetWhereUniqueInput[]
    delete?: ClientPetWhereUniqueInput | ClientPetWhereUniqueInput[]
    connect?: ClientPetWhereUniqueInput | ClientPetWhereUniqueInput[]
    update?: ClientPetUpdateWithWhereUniqueWithoutRaceInput | ClientPetUpdateWithWhereUniqueWithoutRaceInput[]
    updateMany?: ClientPetUpdateManyWithWhereWithoutRaceInput | ClientPetUpdateManyWithWhereWithoutRaceInput[]
    deleteMany?: ClientPetScalarWhereInput | ClientPetScalarWhereInput[]
  }

  export type PetCreateNestedOneWithoutVaccineInput = {
    create?: XOR<PetCreateWithoutVaccineInput, PetUncheckedCreateWithoutVaccineInput>
    connectOrCreate?: PetCreateOrConnectWithoutVaccineInput
    connect?: PetWhereUniqueInput
  }

  export type PersonalPetVaccineCreateNestedManyWithoutVaccineInput = {
    create?: XOR<PersonalPetVaccineCreateWithoutVaccineInput, PersonalPetVaccineUncheckedCreateWithoutVaccineInput> | PersonalPetVaccineCreateWithoutVaccineInput[] | PersonalPetVaccineUncheckedCreateWithoutVaccineInput[]
    connectOrCreate?: PersonalPetVaccineCreateOrConnectWithoutVaccineInput | PersonalPetVaccineCreateOrConnectWithoutVaccineInput[]
    createMany?: PersonalPetVaccineCreateManyVaccineInputEnvelope
    connect?: PersonalPetVaccineWhereUniqueInput | PersonalPetVaccineWhereUniqueInput[]
  }

  export type PersonalPetVaccineUncheckedCreateNestedManyWithoutVaccineInput = {
    create?: XOR<PersonalPetVaccineCreateWithoutVaccineInput, PersonalPetVaccineUncheckedCreateWithoutVaccineInput> | PersonalPetVaccineCreateWithoutVaccineInput[] | PersonalPetVaccineUncheckedCreateWithoutVaccineInput[]
    connectOrCreate?: PersonalPetVaccineCreateOrConnectWithoutVaccineInput | PersonalPetVaccineCreateOrConnectWithoutVaccineInput[]
    createMany?: PersonalPetVaccineCreateManyVaccineInputEnvelope
    connect?: PersonalPetVaccineWhereUniqueInput | PersonalPetVaccineWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type PetUpdateOneRequiredWithoutVaccineNestedInput = {
    create?: XOR<PetCreateWithoutVaccineInput, PetUncheckedCreateWithoutVaccineInput>
    connectOrCreate?: PetCreateOrConnectWithoutVaccineInput
    upsert?: PetUpsertWithoutVaccineInput
    connect?: PetWhereUniqueInput
    update?: XOR<XOR<PetUpdateToOneWithWhereWithoutVaccineInput, PetUpdateWithoutVaccineInput>, PetUncheckedUpdateWithoutVaccineInput>
  }

  export type PersonalPetVaccineUpdateManyWithoutVaccineNestedInput = {
    create?: XOR<PersonalPetVaccineCreateWithoutVaccineInput, PersonalPetVaccineUncheckedCreateWithoutVaccineInput> | PersonalPetVaccineCreateWithoutVaccineInput[] | PersonalPetVaccineUncheckedCreateWithoutVaccineInput[]
    connectOrCreate?: PersonalPetVaccineCreateOrConnectWithoutVaccineInput | PersonalPetVaccineCreateOrConnectWithoutVaccineInput[]
    upsert?: PersonalPetVaccineUpsertWithWhereUniqueWithoutVaccineInput | PersonalPetVaccineUpsertWithWhereUniqueWithoutVaccineInput[]
    createMany?: PersonalPetVaccineCreateManyVaccineInputEnvelope
    set?: PersonalPetVaccineWhereUniqueInput | PersonalPetVaccineWhereUniqueInput[]
    disconnect?: PersonalPetVaccineWhereUniqueInput | PersonalPetVaccineWhereUniqueInput[]
    delete?: PersonalPetVaccineWhereUniqueInput | PersonalPetVaccineWhereUniqueInput[]
    connect?: PersonalPetVaccineWhereUniqueInput | PersonalPetVaccineWhereUniqueInput[]
    update?: PersonalPetVaccineUpdateWithWhereUniqueWithoutVaccineInput | PersonalPetVaccineUpdateWithWhereUniqueWithoutVaccineInput[]
    updateMany?: PersonalPetVaccineUpdateManyWithWhereWithoutVaccineInput | PersonalPetVaccineUpdateManyWithWhereWithoutVaccineInput[]
    deleteMany?: PersonalPetVaccineScalarWhereInput | PersonalPetVaccineScalarWhereInput[]
  }

  export type PersonalPetVaccineUncheckedUpdateManyWithoutVaccineNestedInput = {
    create?: XOR<PersonalPetVaccineCreateWithoutVaccineInput, PersonalPetVaccineUncheckedCreateWithoutVaccineInput> | PersonalPetVaccineCreateWithoutVaccineInput[] | PersonalPetVaccineUncheckedCreateWithoutVaccineInput[]
    connectOrCreate?: PersonalPetVaccineCreateOrConnectWithoutVaccineInput | PersonalPetVaccineCreateOrConnectWithoutVaccineInput[]
    upsert?: PersonalPetVaccineUpsertWithWhereUniqueWithoutVaccineInput | PersonalPetVaccineUpsertWithWhereUniqueWithoutVaccineInput[]
    createMany?: PersonalPetVaccineCreateManyVaccineInputEnvelope
    set?: PersonalPetVaccineWhereUniqueInput | PersonalPetVaccineWhereUniqueInput[]
    disconnect?: PersonalPetVaccineWhereUniqueInput | PersonalPetVaccineWhereUniqueInput[]
    delete?: PersonalPetVaccineWhereUniqueInput | PersonalPetVaccineWhereUniqueInput[]
    connect?: PersonalPetVaccineWhereUniqueInput | PersonalPetVaccineWhereUniqueInput[]
    update?: PersonalPetVaccineUpdateWithWhereUniqueWithoutVaccineInput | PersonalPetVaccineUpdateWithWhereUniqueWithoutVaccineInput[]
    updateMany?: PersonalPetVaccineUpdateManyWithWhereWithoutVaccineInput | PersonalPetVaccineUpdateManyWithWhereWithoutVaccineInput[]
    deleteMany?: PersonalPetVaccineScalarWhereInput | PersonalPetVaccineScalarWhereInput[]
  }

  export type ClientPetCreateNestedOneWithoutPersonalPetVaccineInput = {
    create?: XOR<ClientPetCreateWithoutPersonalPetVaccineInput, ClientPetUncheckedCreateWithoutPersonalPetVaccineInput>
    connectOrCreate?: ClientPetCreateOrConnectWithoutPersonalPetVaccineInput
    connect?: ClientPetWhereUniqueInput
  }

  export type VaccineCreateNestedOneWithoutPersonalPetVaccineInput = {
    create?: XOR<VaccineCreateWithoutPersonalPetVaccineInput, VaccineUncheckedCreateWithoutPersonalPetVaccineInput>
    connectOrCreate?: VaccineCreateOrConnectWithoutPersonalPetVaccineInput
    connect?: VaccineWhereUniqueInput
  }

  export type MettingCreateNestedOneWithoutPersonalPetVaccineInput = {
    create?: XOR<MettingCreateWithoutPersonalPetVaccineInput, MettingUncheckedCreateWithoutPersonalPetVaccineInput>
    connectOrCreate?: MettingCreateOrConnectWithoutPersonalPetVaccineInput
    connect?: MettingWhereUniqueInput
  }

  export type ClientPetUpdateOneRequiredWithoutPersonalPetVaccineNestedInput = {
    create?: XOR<ClientPetCreateWithoutPersonalPetVaccineInput, ClientPetUncheckedCreateWithoutPersonalPetVaccineInput>
    connectOrCreate?: ClientPetCreateOrConnectWithoutPersonalPetVaccineInput
    upsert?: ClientPetUpsertWithoutPersonalPetVaccineInput
    connect?: ClientPetWhereUniqueInput
    update?: XOR<XOR<ClientPetUpdateToOneWithWhereWithoutPersonalPetVaccineInput, ClientPetUpdateWithoutPersonalPetVaccineInput>, ClientPetUncheckedUpdateWithoutPersonalPetVaccineInput>
  }

  export type VaccineUpdateOneRequiredWithoutPersonalPetVaccineNestedInput = {
    create?: XOR<VaccineCreateWithoutPersonalPetVaccineInput, VaccineUncheckedCreateWithoutPersonalPetVaccineInput>
    connectOrCreate?: VaccineCreateOrConnectWithoutPersonalPetVaccineInput
    upsert?: VaccineUpsertWithoutPersonalPetVaccineInput
    connect?: VaccineWhereUniqueInput
    update?: XOR<XOR<VaccineUpdateToOneWithWhereWithoutPersonalPetVaccineInput, VaccineUpdateWithoutPersonalPetVaccineInput>, VaccineUncheckedUpdateWithoutPersonalPetVaccineInput>
  }

  export type MettingUpdateOneWithoutPersonalPetVaccineNestedInput = {
    create?: XOR<MettingCreateWithoutPersonalPetVaccineInput, MettingUncheckedCreateWithoutPersonalPetVaccineInput>
    connectOrCreate?: MettingCreateOrConnectWithoutPersonalPetVaccineInput
    upsert?: MettingUpsertWithoutPersonalPetVaccineInput
    disconnect?: MettingWhereInput | boolean
    delete?: MettingWhereInput | boolean
    connect?: MettingWhereUniqueInput
    update?: XOR<XOR<MettingUpdateToOneWithWhereWithoutPersonalPetVaccineInput, MettingUpdateWithoutPersonalPetVaccineInput>, MettingUncheckedUpdateWithoutPersonalPetVaccineInput>
  }

  export type ClientPetCreateNestedOneWithoutMettingInput = {
    create?: XOR<ClientPetCreateWithoutMettingInput, ClientPetUncheckedCreateWithoutMettingInput>
    connectOrCreate?: ClientPetCreateOrConnectWithoutMettingInput
    connect?: ClientPetWhereUniqueInput
  }

  export type VeterinarianProfileCreateNestedOneWithoutMettingInput = {
    create?: XOR<VeterinarianProfileCreateWithoutMettingInput, VeterinarianProfileUncheckedCreateWithoutMettingInput>
    connectOrCreate?: VeterinarianProfileCreateOrConnectWithoutMettingInput
    connect?: VeterinarianProfileWhereUniqueInput
  }

  export type PersonalPetVaccineCreateNestedManyWithoutMettingInput = {
    create?: XOR<PersonalPetVaccineCreateWithoutMettingInput, PersonalPetVaccineUncheckedCreateWithoutMettingInput> | PersonalPetVaccineCreateWithoutMettingInput[] | PersonalPetVaccineUncheckedCreateWithoutMettingInput[]
    connectOrCreate?: PersonalPetVaccineCreateOrConnectWithoutMettingInput | PersonalPetVaccineCreateOrConnectWithoutMettingInput[]
    createMany?: PersonalPetVaccineCreateManyMettingInputEnvelope
    connect?: PersonalPetVaccineWhereUniqueInput | PersonalPetVaccineWhereUniqueInput[]
  }

  export type PersonalPetVaccineUncheckedCreateNestedManyWithoutMettingInput = {
    create?: XOR<PersonalPetVaccineCreateWithoutMettingInput, PersonalPetVaccineUncheckedCreateWithoutMettingInput> | PersonalPetVaccineCreateWithoutMettingInput[] | PersonalPetVaccineUncheckedCreateWithoutMettingInput[]
    connectOrCreate?: PersonalPetVaccineCreateOrConnectWithoutMettingInput | PersonalPetVaccineCreateOrConnectWithoutMettingInput[]
    createMany?: PersonalPetVaccineCreateManyMettingInputEnvelope
    connect?: PersonalPetVaccineWhereUniqueInput | PersonalPetVaccineWhereUniqueInput[]
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type ClientPetUpdateOneRequiredWithoutMettingNestedInput = {
    create?: XOR<ClientPetCreateWithoutMettingInput, ClientPetUncheckedCreateWithoutMettingInput>
    connectOrCreate?: ClientPetCreateOrConnectWithoutMettingInput
    upsert?: ClientPetUpsertWithoutMettingInput
    connect?: ClientPetWhereUniqueInput
    update?: XOR<XOR<ClientPetUpdateToOneWithWhereWithoutMettingInput, ClientPetUpdateWithoutMettingInput>, ClientPetUncheckedUpdateWithoutMettingInput>
  }

  export type VeterinarianProfileUpdateOneRequiredWithoutMettingNestedInput = {
    create?: XOR<VeterinarianProfileCreateWithoutMettingInput, VeterinarianProfileUncheckedCreateWithoutMettingInput>
    connectOrCreate?: VeterinarianProfileCreateOrConnectWithoutMettingInput
    upsert?: VeterinarianProfileUpsertWithoutMettingInput
    connect?: VeterinarianProfileWhereUniqueInput
    update?: XOR<XOR<VeterinarianProfileUpdateToOneWithWhereWithoutMettingInput, VeterinarianProfileUpdateWithoutMettingInput>, VeterinarianProfileUncheckedUpdateWithoutMettingInput>
  }

  export type PersonalPetVaccineUpdateManyWithoutMettingNestedInput = {
    create?: XOR<PersonalPetVaccineCreateWithoutMettingInput, PersonalPetVaccineUncheckedCreateWithoutMettingInput> | PersonalPetVaccineCreateWithoutMettingInput[] | PersonalPetVaccineUncheckedCreateWithoutMettingInput[]
    connectOrCreate?: PersonalPetVaccineCreateOrConnectWithoutMettingInput | PersonalPetVaccineCreateOrConnectWithoutMettingInput[]
    upsert?: PersonalPetVaccineUpsertWithWhereUniqueWithoutMettingInput | PersonalPetVaccineUpsertWithWhereUniqueWithoutMettingInput[]
    createMany?: PersonalPetVaccineCreateManyMettingInputEnvelope
    set?: PersonalPetVaccineWhereUniqueInput | PersonalPetVaccineWhereUniqueInput[]
    disconnect?: PersonalPetVaccineWhereUniqueInput | PersonalPetVaccineWhereUniqueInput[]
    delete?: PersonalPetVaccineWhereUniqueInput | PersonalPetVaccineWhereUniqueInput[]
    connect?: PersonalPetVaccineWhereUniqueInput | PersonalPetVaccineWhereUniqueInput[]
    update?: PersonalPetVaccineUpdateWithWhereUniqueWithoutMettingInput | PersonalPetVaccineUpdateWithWhereUniqueWithoutMettingInput[]
    updateMany?: PersonalPetVaccineUpdateManyWithWhereWithoutMettingInput | PersonalPetVaccineUpdateManyWithWhereWithoutMettingInput[]
    deleteMany?: PersonalPetVaccineScalarWhereInput | PersonalPetVaccineScalarWhereInput[]
  }

  export type PersonalPetVaccineUncheckedUpdateManyWithoutMettingNestedInput = {
    create?: XOR<PersonalPetVaccineCreateWithoutMettingInput, PersonalPetVaccineUncheckedCreateWithoutMettingInput> | PersonalPetVaccineCreateWithoutMettingInput[] | PersonalPetVaccineUncheckedCreateWithoutMettingInput[]
    connectOrCreate?: PersonalPetVaccineCreateOrConnectWithoutMettingInput | PersonalPetVaccineCreateOrConnectWithoutMettingInput[]
    upsert?: PersonalPetVaccineUpsertWithWhereUniqueWithoutMettingInput | PersonalPetVaccineUpsertWithWhereUniqueWithoutMettingInput[]
    createMany?: PersonalPetVaccineCreateManyMettingInputEnvelope
    set?: PersonalPetVaccineWhereUniqueInput | PersonalPetVaccineWhereUniqueInput[]
    disconnect?: PersonalPetVaccineWhereUniqueInput | PersonalPetVaccineWhereUniqueInput[]
    delete?: PersonalPetVaccineWhereUniqueInput | PersonalPetVaccineWhereUniqueInput[]
    connect?: PersonalPetVaccineWhereUniqueInput | PersonalPetVaccineWhereUniqueInput[]
    update?: PersonalPetVaccineUpdateWithWhereUniqueWithoutMettingInput | PersonalPetVaccineUpdateWithWhereUniqueWithoutMettingInput[]
    updateMany?: PersonalPetVaccineUpdateManyWithWhereWithoutMettingInput | PersonalPetVaccineUpdateManyWithWhereWithoutMettingInput[]
    deleteMany?: PersonalPetVaccineScalarWhereInput | PersonalPetVaccineScalarWhereInput[]
  }

  export type BrandCreateNestedOneWithoutProductInput = {
    create?: XOR<BrandCreateWithoutProductInput, BrandUncheckedCreateWithoutProductInput>
    connectOrCreate?: BrandCreateOrConnectWithoutProductInput
    connect?: BrandWhereUniqueInput
  }

  export type ClinicProductCreateNestedManyWithoutProductInput = {
    create?: XOR<ClinicProductCreateWithoutProductInput, ClinicProductUncheckedCreateWithoutProductInput> | ClinicProductCreateWithoutProductInput[] | ClinicProductUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ClinicProductCreateOrConnectWithoutProductInput | ClinicProductCreateOrConnectWithoutProductInput[]
    createMany?: ClinicProductCreateManyProductInputEnvelope
    connect?: ClinicProductWhereUniqueInput | ClinicProductWhereUniqueInput[]
  }

  export type FoodCreateNestedOneWithoutProductInput = {
    create?: XOR<FoodCreateWithoutProductInput, FoodUncheckedCreateWithoutProductInput>
    connectOrCreate?: FoodCreateOrConnectWithoutProductInput
    connect?: FoodWhereUniqueInput
  }

  export type ClinicProductUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<ClinicProductCreateWithoutProductInput, ClinicProductUncheckedCreateWithoutProductInput> | ClinicProductCreateWithoutProductInput[] | ClinicProductUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ClinicProductCreateOrConnectWithoutProductInput | ClinicProductCreateOrConnectWithoutProductInput[]
    createMany?: ClinicProductCreateManyProductInputEnvelope
    connect?: ClinicProductWhereUniqueInput | ClinicProductWhereUniqueInput[]
  }

  export type FoodUncheckedCreateNestedOneWithoutProductInput = {
    create?: XOR<FoodCreateWithoutProductInput, FoodUncheckedCreateWithoutProductInput>
    connectOrCreate?: FoodCreateOrConnectWithoutProductInput
    connect?: FoodWhereUniqueInput
  }

  export type BrandUpdateOneRequiredWithoutProductNestedInput = {
    create?: XOR<BrandCreateWithoutProductInput, BrandUncheckedCreateWithoutProductInput>
    connectOrCreate?: BrandCreateOrConnectWithoutProductInput
    upsert?: BrandUpsertWithoutProductInput
    connect?: BrandWhereUniqueInput
    update?: XOR<XOR<BrandUpdateToOneWithWhereWithoutProductInput, BrandUpdateWithoutProductInput>, BrandUncheckedUpdateWithoutProductInput>
  }

  export type ClinicProductUpdateManyWithoutProductNestedInput = {
    create?: XOR<ClinicProductCreateWithoutProductInput, ClinicProductUncheckedCreateWithoutProductInput> | ClinicProductCreateWithoutProductInput[] | ClinicProductUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ClinicProductCreateOrConnectWithoutProductInput | ClinicProductCreateOrConnectWithoutProductInput[]
    upsert?: ClinicProductUpsertWithWhereUniqueWithoutProductInput | ClinicProductUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ClinicProductCreateManyProductInputEnvelope
    set?: ClinicProductWhereUniqueInput | ClinicProductWhereUniqueInput[]
    disconnect?: ClinicProductWhereUniqueInput | ClinicProductWhereUniqueInput[]
    delete?: ClinicProductWhereUniqueInput | ClinicProductWhereUniqueInput[]
    connect?: ClinicProductWhereUniqueInput | ClinicProductWhereUniqueInput[]
    update?: ClinicProductUpdateWithWhereUniqueWithoutProductInput | ClinicProductUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ClinicProductUpdateManyWithWhereWithoutProductInput | ClinicProductUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ClinicProductScalarWhereInput | ClinicProductScalarWhereInput[]
  }

  export type FoodUpdateOneWithoutProductNestedInput = {
    create?: XOR<FoodCreateWithoutProductInput, FoodUncheckedCreateWithoutProductInput>
    connectOrCreate?: FoodCreateOrConnectWithoutProductInput
    upsert?: FoodUpsertWithoutProductInput
    disconnect?: FoodWhereInput | boolean
    delete?: FoodWhereInput | boolean
    connect?: FoodWhereUniqueInput
    update?: XOR<XOR<FoodUpdateToOneWithWhereWithoutProductInput, FoodUpdateWithoutProductInput>, FoodUncheckedUpdateWithoutProductInput>
  }

  export type ClinicProductUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<ClinicProductCreateWithoutProductInput, ClinicProductUncheckedCreateWithoutProductInput> | ClinicProductCreateWithoutProductInput[] | ClinicProductUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ClinicProductCreateOrConnectWithoutProductInput | ClinicProductCreateOrConnectWithoutProductInput[]
    upsert?: ClinicProductUpsertWithWhereUniqueWithoutProductInput | ClinicProductUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ClinicProductCreateManyProductInputEnvelope
    set?: ClinicProductWhereUniqueInput | ClinicProductWhereUniqueInput[]
    disconnect?: ClinicProductWhereUniqueInput | ClinicProductWhereUniqueInput[]
    delete?: ClinicProductWhereUniqueInput | ClinicProductWhereUniqueInput[]
    connect?: ClinicProductWhereUniqueInput | ClinicProductWhereUniqueInput[]
    update?: ClinicProductUpdateWithWhereUniqueWithoutProductInput | ClinicProductUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ClinicProductUpdateManyWithWhereWithoutProductInput | ClinicProductUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ClinicProductScalarWhereInput | ClinicProductScalarWhereInput[]
  }

  export type FoodUncheckedUpdateOneWithoutProductNestedInput = {
    create?: XOR<FoodCreateWithoutProductInput, FoodUncheckedCreateWithoutProductInput>
    connectOrCreate?: FoodCreateOrConnectWithoutProductInput
    upsert?: FoodUpsertWithoutProductInput
    disconnect?: FoodWhereInput | boolean
    delete?: FoodWhereInput | boolean
    connect?: FoodWhereUniqueInput
    update?: XOR<XOR<FoodUpdateToOneWithWhereWithoutProductInput, FoodUpdateWithoutProductInput>, FoodUncheckedUpdateWithoutProductInput>
  }

  export type ProductCreateNestedOneWithoutFoodInput = {
    create?: XOR<ProductCreateWithoutFoodInput, ProductUncheckedCreateWithoutFoodInput>
    connectOrCreate?: ProductCreateOrConnectWithoutFoodInput
    connect?: ProductWhereUniqueInput
  }

  export type FoodPetCreateNestedManyWithoutFoodInput = {
    create?: XOR<FoodPetCreateWithoutFoodInput, FoodPetUncheckedCreateWithoutFoodInput> | FoodPetCreateWithoutFoodInput[] | FoodPetUncheckedCreateWithoutFoodInput[]
    connectOrCreate?: FoodPetCreateOrConnectWithoutFoodInput | FoodPetCreateOrConnectWithoutFoodInput[]
    createMany?: FoodPetCreateManyFoodInputEnvelope
    connect?: FoodPetWhereUniqueInput | FoodPetWhereUniqueInput[]
  }

  export type FoodPetUncheckedCreateNestedManyWithoutFoodInput = {
    create?: XOR<FoodPetCreateWithoutFoodInput, FoodPetUncheckedCreateWithoutFoodInput> | FoodPetCreateWithoutFoodInput[] | FoodPetUncheckedCreateWithoutFoodInput[]
    connectOrCreate?: FoodPetCreateOrConnectWithoutFoodInput | FoodPetCreateOrConnectWithoutFoodInput[]
    createMany?: FoodPetCreateManyFoodInputEnvelope
    connect?: FoodPetWhereUniqueInput | FoodPetWhereUniqueInput[]
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type EnumFoodTypeFieldUpdateOperationsInput = {
    set?: $Enums.FoodType
  }

  export type ProductUpdateOneRequiredWithoutFoodNestedInput = {
    create?: XOR<ProductCreateWithoutFoodInput, ProductUncheckedCreateWithoutFoodInput>
    connectOrCreate?: ProductCreateOrConnectWithoutFoodInput
    upsert?: ProductUpsertWithoutFoodInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutFoodInput, ProductUpdateWithoutFoodInput>, ProductUncheckedUpdateWithoutFoodInput>
  }

  export type FoodPetUpdateManyWithoutFoodNestedInput = {
    create?: XOR<FoodPetCreateWithoutFoodInput, FoodPetUncheckedCreateWithoutFoodInput> | FoodPetCreateWithoutFoodInput[] | FoodPetUncheckedCreateWithoutFoodInput[]
    connectOrCreate?: FoodPetCreateOrConnectWithoutFoodInput | FoodPetCreateOrConnectWithoutFoodInput[]
    upsert?: FoodPetUpsertWithWhereUniqueWithoutFoodInput | FoodPetUpsertWithWhereUniqueWithoutFoodInput[]
    createMany?: FoodPetCreateManyFoodInputEnvelope
    set?: FoodPetWhereUniqueInput | FoodPetWhereUniqueInput[]
    disconnect?: FoodPetWhereUniqueInput | FoodPetWhereUniqueInput[]
    delete?: FoodPetWhereUniqueInput | FoodPetWhereUniqueInput[]
    connect?: FoodPetWhereUniqueInput | FoodPetWhereUniqueInput[]
    update?: FoodPetUpdateWithWhereUniqueWithoutFoodInput | FoodPetUpdateWithWhereUniqueWithoutFoodInput[]
    updateMany?: FoodPetUpdateManyWithWhereWithoutFoodInput | FoodPetUpdateManyWithWhereWithoutFoodInput[]
    deleteMany?: FoodPetScalarWhereInput | FoodPetScalarWhereInput[]
  }

  export type FoodPetUncheckedUpdateManyWithoutFoodNestedInput = {
    create?: XOR<FoodPetCreateWithoutFoodInput, FoodPetUncheckedCreateWithoutFoodInput> | FoodPetCreateWithoutFoodInput[] | FoodPetUncheckedCreateWithoutFoodInput[]
    connectOrCreate?: FoodPetCreateOrConnectWithoutFoodInput | FoodPetCreateOrConnectWithoutFoodInput[]
    upsert?: FoodPetUpsertWithWhereUniqueWithoutFoodInput | FoodPetUpsertWithWhereUniqueWithoutFoodInput[]
    createMany?: FoodPetCreateManyFoodInputEnvelope
    set?: FoodPetWhereUniqueInput | FoodPetWhereUniqueInput[]
    disconnect?: FoodPetWhereUniqueInput | FoodPetWhereUniqueInput[]
    delete?: FoodPetWhereUniqueInput | FoodPetWhereUniqueInput[]
    connect?: FoodPetWhereUniqueInput | FoodPetWhereUniqueInput[]
    update?: FoodPetUpdateWithWhereUniqueWithoutFoodInput | FoodPetUpdateWithWhereUniqueWithoutFoodInput[]
    updateMany?: FoodPetUpdateManyWithWhereWithoutFoodInput | FoodPetUpdateManyWithWhereWithoutFoodInput[]
    deleteMany?: FoodPetScalarWhereInput | FoodPetScalarWhereInput[]
  }

  export type ProductCreateNestedManyWithoutBrandInput = {
    create?: XOR<ProductCreateWithoutBrandInput, ProductUncheckedCreateWithoutBrandInput> | ProductCreateWithoutBrandInput[] | ProductUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutBrandInput | ProductCreateOrConnectWithoutBrandInput[]
    createMany?: ProductCreateManyBrandInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type ProductUncheckedCreateNestedManyWithoutBrandInput = {
    create?: XOR<ProductCreateWithoutBrandInput, ProductUncheckedCreateWithoutBrandInput> | ProductCreateWithoutBrandInput[] | ProductUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutBrandInput | ProductCreateOrConnectWithoutBrandInput[]
    createMany?: ProductCreateManyBrandInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type ProductUpdateManyWithoutBrandNestedInput = {
    create?: XOR<ProductCreateWithoutBrandInput, ProductUncheckedCreateWithoutBrandInput> | ProductCreateWithoutBrandInput[] | ProductUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutBrandInput | ProductCreateOrConnectWithoutBrandInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutBrandInput | ProductUpsertWithWhereUniqueWithoutBrandInput[]
    createMany?: ProductCreateManyBrandInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutBrandInput | ProductUpdateWithWhereUniqueWithoutBrandInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutBrandInput | ProductUpdateManyWithWhereWithoutBrandInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type ProductUncheckedUpdateManyWithoutBrandNestedInput = {
    create?: XOR<ProductCreateWithoutBrandInput, ProductUncheckedCreateWithoutBrandInput> | ProductCreateWithoutBrandInput[] | ProductUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutBrandInput | ProductCreateOrConnectWithoutBrandInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutBrandInput | ProductUpsertWithWhereUniqueWithoutBrandInput[]
    createMany?: ProductCreateManyBrandInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutBrandInput | ProductUpdateWithWhereUniqueWithoutBrandInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutBrandInput | ProductUpdateManyWithWhereWithoutBrandInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type ClientProfileCreateNestedOneWithoutClinicProductsInput = {
    create?: XOR<ClientProfileCreateWithoutClinicProductsInput, ClientProfileUncheckedCreateWithoutClinicProductsInput>
    connectOrCreate?: ClientProfileCreateOrConnectWithoutClinicProductsInput
    connect?: ClientProfileWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutClinicProductsInput = {
    create?: XOR<ProductCreateWithoutClinicProductsInput, ProductUncheckedCreateWithoutClinicProductsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutClinicProductsInput
    connect?: ProductWhereUniqueInput
  }

  export type ClientProfileUpdateOneRequiredWithoutClinicProductsNestedInput = {
    create?: XOR<ClientProfileCreateWithoutClinicProductsInput, ClientProfileUncheckedCreateWithoutClinicProductsInput>
    connectOrCreate?: ClientProfileCreateOrConnectWithoutClinicProductsInput
    upsert?: ClientProfileUpsertWithoutClinicProductsInput
    connect?: ClientProfileWhereUniqueInput
    update?: XOR<XOR<ClientProfileUpdateToOneWithWhereWithoutClinicProductsInput, ClientProfileUpdateWithoutClinicProductsInput>, ClientProfileUncheckedUpdateWithoutClinicProductsInput>
  }

  export type ProductUpdateOneRequiredWithoutClinicProductsNestedInput = {
    create?: XOR<ProductCreateWithoutClinicProductsInput, ProductUncheckedCreateWithoutClinicProductsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutClinicProductsInput
    upsert?: ProductUpsertWithoutClinicProductsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutClinicProductsInput, ProductUpdateWithoutClinicProductsInput>, ProductUncheckedUpdateWithoutClinicProductsInput>
  }

  export type FoodCreateNestedOneWithoutFoodPetsInput = {
    create?: XOR<FoodCreateWithoutFoodPetsInput, FoodUncheckedCreateWithoutFoodPetsInput>
    connectOrCreate?: FoodCreateOrConnectWithoutFoodPetsInput
    connect?: FoodWhereUniqueInput
  }

  export type ClientPetCreateNestedOneWithoutFoodPetsInput = {
    create?: XOR<ClientPetCreateWithoutFoodPetsInput, ClientPetUncheckedCreateWithoutFoodPetsInput>
    connectOrCreate?: ClientPetCreateOrConnectWithoutFoodPetsInput
    connect?: ClientPetWhereUniqueInput
  }

  export type EnumFoodPetDayFieldUpdateOperationsInput = {
    set?: $Enums.FoodPetDay
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type FoodUpdateOneRequiredWithoutFoodPetsNestedInput = {
    create?: XOR<FoodCreateWithoutFoodPetsInput, FoodUncheckedCreateWithoutFoodPetsInput>
    connectOrCreate?: FoodCreateOrConnectWithoutFoodPetsInput
    upsert?: FoodUpsertWithoutFoodPetsInput
    connect?: FoodWhereUniqueInput
    update?: XOR<XOR<FoodUpdateToOneWithWhereWithoutFoodPetsInput, FoodUpdateWithoutFoodPetsInput>, FoodUncheckedUpdateWithoutFoodPetsInput>
  }

  export type ClientPetUpdateOneRequiredWithoutFoodPetsNestedInput = {
    create?: XOR<ClientPetCreateWithoutFoodPetsInput, ClientPetUncheckedCreateWithoutFoodPetsInput>
    connectOrCreate?: ClientPetCreateOrConnectWithoutFoodPetsInput
    upsert?: ClientPetUpsertWithoutFoodPetsInput
    connect?: ClientPetWhereUniqueInput
    update?: XOR<XOR<ClientPetUpdateToOneWithWhereWithoutFoodPetsInput, ClientPetUpdateWithoutFoodPetsInput>, ClientPetUncheckedUpdateWithoutFoodPetsInput>
  }

  export type ClientProfileCreateNestedOneWithoutUserInput = {
    create?: XOR<ClientProfileCreateWithoutUserInput, ClientProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: ClientProfileCreateOrConnectWithoutUserInput
    connect?: ClientProfileWhereUniqueInput
  }

  export type VeterinarianProfileCreateNestedOneWithoutUserInput = {
    create?: XOR<VeterinarianProfileCreateWithoutUserInput, VeterinarianProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: VeterinarianProfileCreateOrConnectWithoutUserInput
    connect?: VeterinarianProfileWhereUniqueInput
  }

  export type ClinicProfileCreateNestedOneWithoutUserInput = {
    create?: XOR<ClinicProfileCreateWithoutUserInput, ClinicProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: ClinicProfileCreateOrConnectWithoutUserInput
    connect?: ClinicProfileWhereUniqueInput
  }

  export type SecretaryProfileCreateNestedOneWithoutUserInput = {
    create?: XOR<SecretaryProfileCreateWithoutUserInput, SecretaryProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: SecretaryProfileCreateOrConnectWithoutUserInput
    connect?: SecretaryProfileWhereUniqueInput
  }

  export type ClientProfileUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<ClientProfileCreateWithoutUserInput, ClientProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: ClientProfileCreateOrConnectWithoutUserInput
    connect?: ClientProfileWhereUniqueInput
  }

  export type VeterinarianProfileUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<VeterinarianProfileCreateWithoutUserInput, VeterinarianProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: VeterinarianProfileCreateOrConnectWithoutUserInput
    connect?: VeterinarianProfileWhereUniqueInput
  }

  export type ClinicProfileUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<ClinicProfileCreateWithoutUserInput, ClinicProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: ClinicProfileCreateOrConnectWithoutUserInput
    connect?: ClinicProfileWhereUniqueInput
  }

  export type SecretaryProfileUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<SecretaryProfileCreateWithoutUserInput, SecretaryProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: SecretaryProfileCreateOrConnectWithoutUserInput
    connect?: SecretaryProfileWhereUniqueInput
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type ClientProfileUpdateOneWithoutUserNestedInput = {
    create?: XOR<ClientProfileCreateWithoutUserInput, ClientProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: ClientProfileCreateOrConnectWithoutUserInput
    upsert?: ClientProfileUpsertWithoutUserInput
    disconnect?: ClientProfileWhereInput | boolean
    delete?: ClientProfileWhereInput | boolean
    connect?: ClientProfileWhereUniqueInput
    update?: XOR<XOR<ClientProfileUpdateToOneWithWhereWithoutUserInput, ClientProfileUpdateWithoutUserInput>, ClientProfileUncheckedUpdateWithoutUserInput>
  }

  export type VeterinarianProfileUpdateOneWithoutUserNestedInput = {
    create?: XOR<VeterinarianProfileCreateWithoutUserInput, VeterinarianProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: VeterinarianProfileCreateOrConnectWithoutUserInput
    upsert?: VeterinarianProfileUpsertWithoutUserInput
    disconnect?: VeterinarianProfileWhereInput | boolean
    delete?: VeterinarianProfileWhereInput | boolean
    connect?: VeterinarianProfileWhereUniqueInput
    update?: XOR<XOR<VeterinarianProfileUpdateToOneWithWhereWithoutUserInput, VeterinarianProfileUpdateWithoutUserInput>, VeterinarianProfileUncheckedUpdateWithoutUserInput>
  }

  export type ClinicProfileUpdateOneWithoutUserNestedInput = {
    create?: XOR<ClinicProfileCreateWithoutUserInput, ClinicProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: ClinicProfileCreateOrConnectWithoutUserInput
    upsert?: ClinicProfileUpsertWithoutUserInput
    disconnect?: ClinicProfileWhereInput | boolean
    delete?: ClinicProfileWhereInput | boolean
    connect?: ClinicProfileWhereUniqueInput
    update?: XOR<XOR<ClinicProfileUpdateToOneWithWhereWithoutUserInput, ClinicProfileUpdateWithoutUserInput>, ClinicProfileUncheckedUpdateWithoutUserInput>
  }

  export type SecretaryProfileUpdateOneWithoutUserNestedInput = {
    create?: XOR<SecretaryProfileCreateWithoutUserInput, SecretaryProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: SecretaryProfileCreateOrConnectWithoutUserInput
    upsert?: SecretaryProfileUpsertWithoutUserInput
    disconnect?: SecretaryProfileWhereInput | boolean
    delete?: SecretaryProfileWhereInput | boolean
    connect?: SecretaryProfileWhereUniqueInput
    update?: XOR<XOR<SecretaryProfileUpdateToOneWithWhereWithoutUserInput, SecretaryProfileUpdateWithoutUserInput>, SecretaryProfileUncheckedUpdateWithoutUserInput>
  }

  export type ClientProfileUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<ClientProfileCreateWithoutUserInput, ClientProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: ClientProfileCreateOrConnectWithoutUserInput
    upsert?: ClientProfileUpsertWithoutUserInput
    disconnect?: ClientProfileWhereInput | boolean
    delete?: ClientProfileWhereInput | boolean
    connect?: ClientProfileWhereUniqueInput
    update?: XOR<XOR<ClientProfileUpdateToOneWithWhereWithoutUserInput, ClientProfileUpdateWithoutUserInput>, ClientProfileUncheckedUpdateWithoutUserInput>
  }

  export type VeterinarianProfileUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<VeterinarianProfileCreateWithoutUserInput, VeterinarianProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: VeterinarianProfileCreateOrConnectWithoutUserInput
    upsert?: VeterinarianProfileUpsertWithoutUserInput
    disconnect?: VeterinarianProfileWhereInput | boolean
    delete?: VeterinarianProfileWhereInput | boolean
    connect?: VeterinarianProfileWhereUniqueInput
    update?: XOR<XOR<VeterinarianProfileUpdateToOneWithWhereWithoutUserInput, VeterinarianProfileUpdateWithoutUserInput>, VeterinarianProfileUncheckedUpdateWithoutUserInput>
  }

  export type ClinicProfileUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<ClinicProfileCreateWithoutUserInput, ClinicProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: ClinicProfileCreateOrConnectWithoutUserInput
    upsert?: ClinicProfileUpsertWithoutUserInput
    disconnect?: ClinicProfileWhereInput | boolean
    delete?: ClinicProfileWhereInput | boolean
    connect?: ClinicProfileWhereUniqueInput
    update?: XOR<XOR<ClinicProfileUpdateToOneWithWhereWithoutUserInput, ClinicProfileUpdateWithoutUserInput>, ClinicProfileUncheckedUpdateWithoutUserInput>
  }

  export type SecretaryProfileUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<SecretaryProfileCreateWithoutUserInput, SecretaryProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: SecretaryProfileCreateOrConnectWithoutUserInput
    upsert?: SecretaryProfileUpsertWithoutUserInput
    disconnect?: SecretaryProfileWhereInput | boolean
    delete?: SecretaryProfileWhereInput | boolean
    connect?: SecretaryProfileWhereUniqueInput
    update?: XOR<XOR<SecretaryProfileUpdateToOneWithWhereWithoutUserInput, SecretaryProfileUpdateWithoutUserInput>, SecretaryProfileUncheckedUpdateWithoutUserInput>
  }

  export type UserCreateNestedOneWithoutClientProfileInput = {
    create?: XOR<UserCreateWithoutClientProfileInput, UserUncheckedCreateWithoutClientProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutClientProfileInput
    connect?: UserWhereUniqueInput
  }

  export type SecretaryProfileCreateNestedOneWithoutClinicInput = {
    create?: XOR<SecretaryProfileCreateWithoutClinicInput, SecretaryProfileUncheckedCreateWithoutClinicInput>
    connectOrCreate?: SecretaryProfileCreateOrConnectWithoutClinicInput
    connect?: SecretaryProfileWhereUniqueInput
  }

  export type VeterinarianProfileCreateNestedOneWithoutClinicInput = {
    create?: XOR<VeterinarianProfileCreateWithoutClinicInput, VeterinarianProfileUncheckedCreateWithoutClinicInput>
    connectOrCreate?: VeterinarianProfileCreateOrConnectWithoutClinicInput
    connect?: VeterinarianProfileWhereUniqueInput
  }

  export type ClientPetCreateNestedManyWithoutClientInput = {
    create?: XOR<ClientPetCreateWithoutClientInput, ClientPetUncheckedCreateWithoutClientInput> | ClientPetCreateWithoutClientInput[] | ClientPetUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ClientPetCreateOrConnectWithoutClientInput | ClientPetCreateOrConnectWithoutClientInput[]
    createMany?: ClientPetCreateManyClientInputEnvelope
    connect?: ClientPetWhereUniqueInput | ClientPetWhereUniqueInput[]
  }

  export type ClinicProductCreateNestedManyWithoutClinicInput = {
    create?: XOR<ClinicProductCreateWithoutClinicInput, ClinicProductUncheckedCreateWithoutClinicInput> | ClinicProductCreateWithoutClinicInput[] | ClinicProductUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: ClinicProductCreateOrConnectWithoutClinicInput | ClinicProductCreateOrConnectWithoutClinicInput[]
    createMany?: ClinicProductCreateManyClinicInputEnvelope
    connect?: ClinicProductWhereUniqueInput | ClinicProductWhereUniqueInput[]
  }

  export type SecretaryProfileUncheckedCreateNestedOneWithoutClinicInput = {
    create?: XOR<SecretaryProfileCreateWithoutClinicInput, SecretaryProfileUncheckedCreateWithoutClinicInput>
    connectOrCreate?: SecretaryProfileCreateOrConnectWithoutClinicInput
    connect?: SecretaryProfileWhereUniqueInput
  }

  export type VeterinarianProfileUncheckedCreateNestedOneWithoutClinicInput = {
    create?: XOR<VeterinarianProfileCreateWithoutClinicInput, VeterinarianProfileUncheckedCreateWithoutClinicInput>
    connectOrCreate?: VeterinarianProfileCreateOrConnectWithoutClinicInput
    connect?: VeterinarianProfileWhereUniqueInput
  }

  export type ClientPetUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<ClientPetCreateWithoutClientInput, ClientPetUncheckedCreateWithoutClientInput> | ClientPetCreateWithoutClientInput[] | ClientPetUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ClientPetCreateOrConnectWithoutClientInput | ClientPetCreateOrConnectWithoutClientInput[]
    createMany?: ClientPetCreateManyClientInputEnvelope
    connect?: ClientPetWhereUniqueInput | ClientPetWhereUniqueInput[]
  }

  export type ClinicProductUncheckedCreateNestedManyWithoutClinicInput = {
    create?: XOR<ClinicProductCreateWithoutClinicInput, ClinicProductUncheckedCreateWithoutClinicInput> | ClinicProductCreateWithoutClinicInput[] | ClinicProductUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: ClinicProductCreateOrConnectWithoutClinicInput | ClinicProductCreateOrConnectWithoutClinicInput[]
    createMany?: ClinicProductCreateManyClinicInputEnvelope
    connect?: ClinicProductWhereUniqueInput | ClinicProductWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutClientProfileNestedInput = {
    create?: XOR<UserCreateWithoutClientProfileInput, UserUncheckedCreateWithoutClientProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutClientProfileInput
    upsert?: UserUpsertWithoutClientProfileInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutClientProfileInput, UserUpdateWithoutClientProfileInput>, UserUncheckedUpdateWithoutClientProfileInput>
  }

  export type SecretaryProfileUpdateOneWithoutClinicNestedInput = {
    create?: XOR<SecretaryProfileCreateWithoutClinicInput, SecretaryProfileUncheckedCreateWithoutClinicInput>
    connectOrCreate?: SecretaryProfileCreateOrConnectWithoutClinicInput
    upsert?: SecretaryProfileUpsertWithoutClinicInput
    disconnect?: SecretaryProfileWhereInput | boolean
    delete?: SecretaryProfileWhereInput | boolean
    connect?: SecretaryProfileWhereUniqueInput
    update?: XOR<XOR<SecretaryProfileUpdateToOneWithWhereWithoutClinicInput, SecretaryProfileUpdateWithoutClinicInput>, SecretaryProfileUncheckedUpdateWithoutClinicInput>
  }

  export type VeterinarianProfileUpdateOneWithoutClinicNestedInput = {
    create?: XOR<VeterinarianProfileCreateWithoutClinicInput, VeterinarianProfileUncheckedCreateWithoutClinicInput>
    connectOrCreate?: VeterinarianProfileCreateOrConnectWithoutClinicInput
    upsert?: VeterinarianProfileUpsertWithoutClinicInput
    disconnect?: VeterinarianProfileWhereInput | boolean
    delete?: VeterinarianProfileWhereInput | boolean
    connect?: VeterinarianProfileWhereUniqueInput
    update?: XOR<XOR<VeterinarianProfileUpdateToOneWithWhereWithoutClinicInput, VeterinarianProfileUpdateWithoutClinicInput>, VeterinarianProfileUncheckedUpdateWithoutClinicInput>
  }

  export type ClientPetUpdateManyWithoutClientNestedInput = {
    create?: XOR<ClientPetCreateWithoutClientInput, ClientPetUncheckedCreateWithoutClientInput> | ClientPetCreateWithoutClientInput[] | ClientPetUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ClientPetCreateOrConnectWithoutClientInput | ClientPetCreateOrConnectWithoutClientInput[]
    upsert?: ClientPetUpsertWithWhereUniqueWithoutClientInput | ClientPetUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: ClientPetCreateManyClientInputEnvelope
    set?: ClientPetWhereUniqueInput | ClientPetWhereUniqueInput[]
    disconnect?: ClientPetWhereUniqueInput | ClientPetWhereUniqueInput[]
    delete?: ClientPetWhereUniqueInput | ClientPetWhereUniqueInput[]
    connect?: ClientPetWhereUniqueInput | ClientPetWhereUniqueInput[]
    update?: ClientPetUpdateWithWhereUniqueWithoutClientInput | ClientPetUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: ClientPetUpdateManyWithWhereWithoutClientInput | ClientPetUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: ClientPetScalarWhereInput | ClientPetScalarWhereInput[]
  }

  export type ClinicProductUpdateManyWithoutClinicNestedInput = {
    create?: XOR<ClinicProductCreateWithoutClinicInput, ClinicProductUncheckedCreateWithoutClinicInput> | ClinicProductCreateWithoutClinicInput[] | ClinicProductUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: ClinicProductCreateOrConnectWithoutClinicInput | ClinicProductCreateOrConnectWithoutClinicInput[]
    upsert?: ClinicProductUpsertWithWhereUniqueWithoutClinicInput | ClinicProductUpsertWithWhereUniqueWithoutClinicInput[]
    createMany?: ClinicProductCreateManyClinicInputEnvelope
    set?: ClinicProductWhereUniqueInput | ClinicProductWhereUniqueInput[]
    disconnect?: ClinicProductWhereUniqueInput | ClinicProductWhereUniqueInput[]
    delete?: ClinicProductWhereUniqueInput | ClinicProductWhereUniqueInput[]
    connect?: ClinicProductWhereUniqueInput | ClinicProductWhereUniqueInput[]
    update?: ClinicProductUpdateWithWhereUniqueWithoutClinicInput | ClinicProductUpdateWithWhereUniqueWithoutClinicInput[]
    updateMany?: ClinicProductUpdateManyWithWhereWithoutClinicInput | ClinicProductUpdateManyWithWhereWithoutClinicInput[]
    deleteMany?: ClinicProductScalarWhereInput | ClinicProductScalarWhereInput[]
  }

  export type SecretaryProfileUncheckedUpdateOneWithoutClinicNestedInput = {
    create?: XOR<SecretaryProfileCreateWithoutClinicInput, SecretaryProfileUncheckedCreateWithoutClinicInput>
    connectOrCreate?: SecretaryProfileCreateOrConnectWithoutClinicInput
    upsert?: SecretaryProfileUpsertWithoutClinicInput
    disconnect?: SecretaryProfileWhereInput | boolean
    delete?: SecretaryProfileWhereInput | boolean
    connect?: SecretaryProfileWhereUniqueInput
    update?: XOR<XOR<SecretaryProfileUpdateToOneWithWhereWithoutClinicInput, SecretaryProfileUpdateWithoutClinicInput>, SecretaryProfileUncheckedUpdateWithoutClinicInput>
  }

  export type VeterinarianProfileUncheckedUpdateOneWithoutClinicNestedInput = {
    create?: XOR<VeterinarianProfileCreateWithoutClinicInput, VeterinarianProfileUncheckedCreateWithoutClinicInput>
    connectOrCreate?: VeterinarianProfileCreateOrConnectWithoutClinicInput
    upsert?: VeterinarianProfileUpsertWithoutClinicInput
    disconnect?: VeterinarianProfileWhereInput | boolean
    delete?: VeterinarianProfileWhereInput | boolean
    connect?: VeterinarianProfileWhereUniqueInput
    update?: XOR<XOR<VeterinarianProfileUpdateToOneWithWhereWithoutClinicInput, VeterinarianProfileUpdateWithoutClinicInput>, VeterinarianProfileUncheckedUpdateWithoutClinicInput>
  }

  export type ClientPetUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<ClientPetCreateWithoutClientInput, ClientPetUncheckedCreateWithoutClientInput> | ClientPetCreateWithoutClientInput[] | ClientPetUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ClientPetCreateOrConnectWithoutClientInput | ClientPetCreateOrConnectWithoutClientInput[]
    upsert?: ClientPetUpsertWithWhereUniqueWithoutClientInput | ClientPetUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: ClientPetCreateManyClientInputEnvelope
    set?: ClientPetWhereUniqueInput | ClientPetWhereUniqueInput[]
    disconnect?: ClientPetWhereUniqueInput | ClientPetWhereUniqueInput[]
    delete?: ClientPetWhereUniqueInput | ClientPetWhereUniqueInput[]
    connect?: ClientPetWhereUniqueInput | ClientPetWhereUniqueInput[]
    update?: ClientPetUpdateWithWhereUniqueWithoutClientInput | ClientPetUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: ClientPetUpdateManyWithWhereWithoutClientInput | ClientPetUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: ClientPetScalarWhereInput | ClientPetScalarWhereInput[]
  }

  export type ClinicProductUncheckedUpdateManyWithoutClinicNestedInput = {
    create?: XOR<ClinicProductCreateWithoutClinicInput, ClinicProductUncheckedCreateWithoutClinicInput> | ClinicProductCreateWithoutClinicInput[] | ClinicProductUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: ClinicProductCreateOrConnectWithoutClinicInput | ClinicProductCreateOrConnectWithoutClinicInput[]
    upsert?: ClinicProductUpsertWithWhereUniqueWithoutClinicInput | ClinicProductUpsertWithWhereUniqueWithoutClinicInput[]
    createMany?: ClinicProductCreateManyClinicInputEnvelope
    set?: ClinicProductWhereUniqueInput | ClinicProductWhereUniqueInput[]
    disconnect?: ClinicProductWhereUniqueInput | ClinicProductWhereUniqueInput[]
    delete?: ClinicProductWhereUniqueInput | ClinicProductWhereUniqueInput[]
    connect?: ClinicProductWhereUniqueInput | ClinicProductWhereUniqueInput[]
    update?: ClinicProductUpdateWithWhereUniqueWithoutClinicInput | ClinicProductUpdateWithWhereUniqueWithoutClinicInput[]
    updateMany?: ClinicProductUpdateManyWithWhereWithoutClinicInput | ClinicProductUpdateManyWithWhereWithoutClinicInput[]
    deleteMany?: ClinicProductScalarWhereInput | ClinicProductScalarWhereInput[]
  }

  export type ClientProfileCreateNestedOneWithoutVeterinarianProfileInput = {
    create?: XOR<ClientProfileCreateWithoutVeterinarianProfileInput, ClientProfileUncheckedCreateWithoutVeterinarianProfileInput>
    connectOrCreate?: ClientProfileCreateOrConnectWithoutVeterinarianProfileInput
    connect?: ClientProfileWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutVeterinarianProfileInput = {
    create?: XOR<UserCreateWithoutVeterinarianProfileInput, UserUncheckedCreateWithoutVeterinarianProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutVeterinarianProfileInput
    connect?: UserWhereUniqueInput
  }

  export type ClinicProfileCreateNestedManyWithoutVeterinarianProfileInput = {
    create?: XOR<ClinicProfileCreateWithoutVeterinarianProfileInput, ClinicProfileUncheckedCreateWithoutVeterinarianProfileInput> | ClinicProfileCreateWithoutVeterinarianProfileInput[] | ClinicProfileUncheckedCreateWithoutVeterinarianProfileInput[]
    connectOrCreate?: ClinicProfileCreateOrConnectWithoutVeterinarianProfileInput | ClinicProfileCreateOrConnectWithoutVeterinarianProfileInput[]
    createMany?: ClinicProfileCreateManyVeterinarianProfileInputEnvelope
    connect?: ClinicProfileWhereUniqueInput | ClinicProfileWhereUniqueInput[]
  }

  export type ClientPetCreateNestedManyWithoutAttendingVeterinarianInput = {
    create?: XOR<ClientPetCreateWithoutAttendingVeterinarianInput, ClientPetUncheckedCreateWithoutAttendingVeterinarianInput> | ClientPetCreateWithoutAttendingVeterinarianInput[] | ClientPetUncheckedCreateWithoutAttendingVeterinarianInput[]
    connectOrCreate?: ClientPetCreateOrConnectWithoutAttendingVeterinarianInput | ClientPetCreateOrConnectWithoutAttendingVeterinarianInput[]
    createMany?: ClientPetCreateManyAttendingVeterinarianInputEnvelope
    connect?: ClientPetWhereUniqueInput | ClientPetWhereUniqueInput[]
  }

  export type MettingCreateNestedManyWithoutVeterinarianInput = {
    create?: XOR<MettingCreateWithoutVeterinarianInput, MettingUncheckedCreateWithoutVeterinarianInput> | MettingCreateWithoutVeterinarianInput[] | MettingUncheckedCreateWithoutVeterinarianInput[]
    connectOrCreate?: MettingCreateOrConnectWithoutVeterinarianInput | MettingCreateOrConnectWithoutVeterinarianInput[]
    createMany?: MettingCreateManyVeterinarianInputEnvelope
    connect?: MettingWhereUniqueInput | MettingWhereUniqueInput[]
  }

  export type ClinicProfileUncheckedCreateNestedManyWithoutVeterinarianProfileInput = {
    create?: XOR<ClinicProfileCreateWithoutVeterinarianProfileInput, ClinicProfileUncheckedCreateWithoutVeterinarianProfileInput> | ClinicProfileCreateWithoutVeterinarianProfileInput[] | ClinicProfileUncheckedCreateWithoutVeterinarianProfileInput[]
    connectOrCreate?: ClinicProfileCreateOrConnectWithoutVeterinarianProfileInput | ClinicProfileCreateOrConnectWithoutVeterinarianProfileInput[]
    createMany?: ClinicProfileCreateManyVeterinarianProfileInputEnvelope
    connect?: ClinicProfileWhereUniqueInput | ClinicProfileWhereUniqueInput[]
  }

  export type ClientPetUncheckedCreateNestedManyWithoutAttendingVeterinarianInput = {
    create?: XOR<ClientPetCreateWithoutAttendingVeterinarianInput, ClientPetUncheckedCreateWithoutAttendingVeterinarianInput> | ClientPetCreateWithoutAttendingVeterinarianInput[] | ClientPetUncheckedCreateWithoutAttendingVeterinarianInput[]
    connectOrCreate?: ClientPetCreateOrConnectWithoutAttendingVeterinarianInput | ClientPetCreateOrConnectWithoutAttendingVeterinarianInput[]
    createMany?: ClientPetCreateManyAttendingVeterinarianInputEnvelope
    connect?: ClientPetWhereUniqueInput | ClientPetWhereUniqueInput[]
  }

  export type MettingUncheckedCreateNestedManyWithoutVeterinarianInput = {
    create?: XOR<MettingCreateWithoutVeterinarianInput, MettingUncheckedCreateWithoutVeterinarianInput> | MettingCreateWithoutVeterinarianInput[] | MettingUncheckedCreateWithoutVeterinarianInput[]
    connectOrCreate?: MettingCreateOrConnectWithoutVeterinarianInput | MettingCreateOrConnectWithoutVeterinarianInput[]
    createMany?: MettingCreateManyVeterinarianInputEnvelope
    connect?: MettingWhereUniqueInput | MettingWhereUniqueInput[]
  }

  export type ClientProfileUpdateOneRequiredWithoutVeterinarianProfileNestedInput = {
    create?: XOR<ClientProfileCreateWithoutVeterinarianProfileInput, ClientProfileUncheckedCreateWithoutVeterinarianProfileInput>
    connectOrCreate?: ClientProfileCreateOrConnectWithoutVeterinarianProfileInput
    upsert?: ClientProfileUpsertWithoutVeterinarianProfileInput
    connect?: ClientProfileWhereUniqueInput
    update?: XOR<XOR<ClientProfileUpdateToOneWithWhereWithoutVeterinarianProfileInput, ClientProfileUpdateWithoutVeterinarianProfileInput>, ClientProfileUncheckedUpdateWithoutVeterinarianProfileInput>
  }

  export type UserUpdateOneRequiredWithoutVeterinarianProfileNestedInput = {
    create?: XOR<UserCreateWithoutVeterinarianProfileInput, UserUncheckedCreateWithoutVeterinarianProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutVeterinarianProfileInput
    upsert?: UserUpsertWithoutVeterinarianProfileInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutVeterinarianProfileInput, UserUpdateWithoutVeterinarianProfileInput>, UserUncheckedUpdateWithoutVeterinarianProfileInput>
  }

  export type ClinicProfileUpdateManyWithoutVeterinarianProfileNestedInput = {
    create?: XOR<ClinicProfileCreateWithoutVeterinarianProfileInput, ClinicProfileUncheckedCreateWithoutVeterinarianProfileInput> | ClinicProfileCreateWithoutVeterinarianProfileInput[] | ClinicProfileUncheckedCreateWithoutVeterinarianProfileInput[]
    connectOrCreate?: ClinicProfileCreateOrConnectWithoutVeterinarianProfileInput | ClinicProfileCreateOrConnectWithoutVeterinarianProfileInput[]
    upsert?: ClinicProfileUpsertWithWhereUniqueWithoutVeterinarianProfileInput | ClinicProfileUpsertWithWhereUniqueWithoutVeterinarianProfileInput[]
    createMany?: ClinicProfileCreateManyVeterinarianProfileInputEnvelope
    set?: ClinicProfileWhereUniqueInput | ClinicProfileWhereUniqueInput[]
    disconnect?: ClinicProfileWhereUniqueInput | ClinicProfileWhereUniqueInput[]
    delete?: ClinicProfileWhereUniqueInput | ClinicProfileWhereUniqueInput[]
    connect?: ClinicProfileWhereUniqueInput | ClinicProfileWhereUniqueInput[]
    update?: ClinicProfileUpdateWithWhereUniqueWithoutVeterinarianProfileInput | ClinicProfileUpdateWithWhereUniqueWithoutVeterinarianProfileInput[]
    updateMany?: ClinicProfileUpdateManyWithWhereWithoutVeterinarianProfileInput | ClinicProfileUpdateManyWithWhereWithoutVeterinarianProfileInput[]
    deleteMany?: ClinicProfileScalarWhereInput | ClinicProfileScalarWhereInput[]
  }

  export type ClientPetUpdateManyWithoutAttendingVeterinarianNestedInput = {
    create?: XOR<ClientPetCreateWithoutAttendingVeterinarianInput, ClientPetUncheckedCreateWithoutAttendingVeterinarianInput> | ClientPetCreateWithoutAttendingVeterinarianInput[] | ClientPetUncheckedCreateWithoutAttendingVeterinarianInput[]
    connectOrCreate?: ClientPetCreateOrConnectWithoutAttendingVeterinarianInput | ClientPetCreateOrConnectWithoutAttendingVeterinarianInput[]
    upsert?: ClientPetUpsertWithWhereUniqueWithoutAttendingVeterinarianInput | ClientPetUpsertWithWhereUniqueWithoutAttendingVeterinarianInput[]
    createMany?: ClientPetCreateManyAttendingVeterinarianInputEnvelope
    set?: ClientPetWhereUniqueInput | ClientPetWhereUniqueInput[]
    disconnect?: ClientPetWhereUniqueInput | ClientPetWhereUniqueInput[]
    delete?: ClientPetWhereUniqueInput | ClientPetWhereUniqueInput[]
    connect?: ClientPetWhereUniqueInput | ClientPetWhereUniqueInput[]
    update?: ClientPetUpdateWithWhereUniqueWithoutAttendingVeterinarianInput | ClientPetUpdateWithWhereUniqueWithoutAttendingVeterinarianInput[]
    updateMany?: ClientPetUpdateManyWithWhereWithoutAttendingVeterinarianInput | ClientPetUpdateManyWithWhereWithoutAttendingVeterinarianInput[]
    deleteMany?: ClientPetScalarWhereInput | ClientPetScalarWhereInput[]
  }

  export type MettingUpdateManyWithoutVeterinarianNestedInput = {
    create?: XOR<MettingCreateWithoutVeterinarianInput, MettingUncheckedCreateWithoutVeterinarianInput> | MettingCreateWithoutVeterinarianInput[] | MettingUncheckedCreateWithoutVeterinarianInput[]
    connectOrCreate?: MettingCreateOrConnectWithoutVeterinarianInput | MettingCreateOrConnectWithoutVeterinarianInput[]
    upsert?: MettingUpsertWithWhereUniqueWithoutVeterinarianInput | MettingUpsertWithWhereUniqueWithoutVeterinarianInput[]
    createMany?: MettingCreateManyVeterinarianInputEnvelope
    set?: MettingWhereUniqueInput | MettingWhereUniqueInput[]
    disconnect?: MettingWhereUniqueInput | MettingWhereUniqueInput[]
    delete?: MettingWhereUniqueInput | MettingWhereUniqueInput[]
    connect?: MettingWhereUniqueInput | MettingWhereUniqueInput[]
    update?: MettingUpdateWithWhereUniqueWithoutVeterinarianInput | MettingUpdateWithWhereUniqueWithoutVeterinarianInput[]
    updateMany?: MettingUpdateManyWithWhereWithoutVeterinarianInput | MettingUpdateManyWithWhereWithoutVeterinarianInput[]
    deleteMany?: MettingScalarWhereInput | MettingScalarWhereInput[]
  }

  export type ClinicProfileUncheckedUpdateManyWithoutVeterinarianProfileNestedInput = {
    create?: XOR<ClinicProfileCreateWithoutVeterinarianProfileInput, ClinicProfileUncheckedCreateWithoutVeterinarianProfileInput> | ClinicProfileCreateWithoutVeterinarianProfileInput[] | ClinicProfileUncheckedCreateWithoutVeterinarianProfileInput[]
    connectOrCreate?: ClinicProfileCreateOrConnectWithoutVeterinarianProfileInput | ClinicProfileCreateOrConnectWithoutVeterinarianProfileInput[]
    upsert?: ClinicProfileUpsertWithWhereUniqueWithoutVeterinarianProfileInput | ClinicProfileUpsertWithWhereUniqueWithoutVeterinarianProfileInput[]
    createMany?: ClinicProfileCreateManyVeterinarianProfileInputEnvelope
    set?: ClinicProfileWhereUniqueInput | ClinicProfileWhereUniqueInput[]
    disconnect?: ClinicProfileWhereUniqueInput | ClinicProfileWhereUniqueInput[]
    delete?: ClinicProfileWhereUniqueInput | ClinicProfileWhereUniqueInput[]
    connect?: ClinicProfileWhereUniqueInput | ClinicProfileWhereUniqueInput[]
    update?: ClinicProfileUpdateWithWhereUniqueWithoutVeterinarianProfileInput | ClinicProfileUpdateWithWhereUniqueWithoutVeterinarianProfileInput[]
    updateMany?: ClinicProfileUpdateManyWithWhereWithoutVeterinarianProfileInput | ClinicProfileUpdateManyWithWhereWithoutVeterinarianProfileInput[]
    deleteMany?: ClinicProfileScalarWhereInput | ClinicProfileScalarWhereInput[]
  }

  export type ClientPetUncheckedUpdateManyWithoutAttendingVeterinarianNestedInput = {
    create?: XOR<ClientPetCreateWithoutAttendingVeterinarianInput, ClientPetUncheckedCreateWithoutAttendingVeterinarianInput> | ClientPetCreateWithoutAttendingVeterinarianInput[] | ClientPetUncheckedCreateWithoutAttendingVeterinarianInput[]
    connectOrCreate?: ClientPetCreateOrConnectWithoutAttendingVeterinarianInput | ClientPetCreateOrConnectWithoutAttendingVeterinarianInput[]
    upsert?: ClientPetUpsertWithWhereUniqueWithoutAttendingVeterinarianInput | ClientPetUpsertWithWhereUniqueWithoutAttendingVeterinarianInput[]
    createMany?: ClientPetCreateManyAttendingVeterinarianInputEnvelope
    set?: ClientPetWhereUniqueInput | ClientPetWhereUniqueInput[]
    disconnect?: ClientPetWhereUniqueInput | ClientPetWhereUniqueInput[]
    delete?: ClientPetWhereUniqueInput | ClientPetWhereUniqueInput[]
    connect?: ClientPetWhereUniqueInput | ClientPetWhereUniqueInput[]
    update?: ClientPetUpdateWithWhereUniqueWithoutAttendingVeterinarianInput | ClientPetUpdateWithWhereUniqueWithoutAttendingVeterinarianInput[]
    updateMany?: ClientPetUpdateManyWithWhereWithoutAttendingVeterinarianInput | ClientPetUpdateManyWithWhereWithoutAttendingVeterinarianInput[]
    deleteMany?: ClientPetScalarWhereInput | ClientPetScalarWhereInput[]
  }

  export type MettingUncheckedUpdateManyWithoutVeterinarianNestedInput = {
    create?: XOR<MettingCreateWithoutVeterinarianInput, MettingUncheckedCreateWithoutVeterinarianInput> | MettingCreateWithoutVeterinarianInput[] | MettingUncheckedCreateWithoutVeterinarianInput[]
    connectOrCreate?: MettingCreateOrConnectWithoutVeterinarianInput | MettingCreateOrConnectWithoutVeterinarianInput[]
    upsert?: MettingUpsertWithWhereUniqueWithoutVeterinarianInput | MettingUpsertWithWhereUniqueWithoutVeterinarianInput[]
    createMany?: MettingCreateManyVeterinarianInputEnvelope
    set?: MettingWhereUniqueInput | MettingWhereUniqueInput[]
    disconnect?: MettingWhereUniqueInput | MettingWhereUniqueInput[]
    delete?: MettingWhereUniqueInput | MettingWhereUniqueInput[]
    connect?: MettingWhereUniqueInput | MettingWhereUniqueInput[]
    update?: MettingUpdateWithWhereUniqueWithoutVeterinarianInput | MettingUpdateWithWhereUniqueWithoutVeterinarianInput[]
    updateMany?: MettingUpdateManyWithWhereWithoutVeterinarianInput | MettingUpdateManyWithWhereWithoutVeterinarianInput[]
    deleteMany?: MettingScalarWhereInput | MettingScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutClinicProfileInput = {
    create?: XOR<UserCreateWithoutClinicProfileInput, UserUncheckedCreateWithoutClinicProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutClinicProfileInput
    connect?: UserWhereUniqueInput
  }

  export type VeterinarianProfileCreateNestedOneWithoutClinicProfilesInput = {
    create?: XOR<VeterinarianProfileCreateWithoutClinicProfilesInput, VeterinarianProfileUncheckedCreateWithoutClinicProfilesInput>
    connectOrCreate?: VeterinarianProfileCreateOrConnectWithoutClinicProfilesInput
    connect?: VeterinarianProfileWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutClinicProfileNestedInput = {
    create?: XOR<UserCreateWithoutClinicProfileInput, UserUncheckedCreateWithoutClinicProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutClinicProfileInput
    upsert?: UserUpsertWithoutClinicProfileInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutClinicProfileInput, UserUpdateWithoutClinicProfileInput>, UserUncheckedUpdateWithoutClinicProfileInput>
  }

  export type VeterinarianProfileUpdateOneWithoutClinicProfilesNestedInput = {
    create?: XOR<VeterinarianProfileCreateWithoutClinicProfilesInput, VeterinarianProfileUncheckedCreateWithoutClinicProfilesInput>
    connectOrCreate?: VeterinarianProfileCreateOrConnectWithoutClinicProfilesInput
    upsert?: VeterinarianProfileUpsertWithoutClinicProfilesInput
    disconnect?: VeterinarianProfileWhereInput | boolean
    delete?: VeterinarianProfileWhereInput | boolean
    connect?: VeterinarianProfileWhereUniqueInput
    update?: XOR<XOR<VeterinarianProfileUpdateToOneWithWhereWithoutClinicProfilesInput, VeterinarianProfileUpdateWithoutClinicProfilesInput>, VeterinarianProfileUncheckedUpdateWithoutClinicProfilesInput>
  }

  export type UserCreateNestedOneWithoutSecretaryProfileInput = {
    create?: XOR<UserCreateWithoutSecretaryProfileInput, UserUncheckedCreateWithoutSecretaryProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutSecretaryProfileInput
    connect?: UserWhereUniqueInput
  }

  export type ClientProfileCreateNestedOneWithoutSecretaryProfileInput = {
    create?: XOR<ClientProfileCreateWithoutSecretaryProfileInput, ClientProfileUncheckedCreateWithoutSecretaryProfileInput>
    connectOrCreate?: ClientProfileCreateOrConnectWithoutSecretaryProfileInput
    connect?: ClientProfileWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSecretaryProfileNestedInput = {
    create?: XOR<UserCreateWithoutSecretaryProfileInput, UserUncheckedCreateWithoutSecretaryProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutSecretaryProfileInput
    upsert?: UserUpsertWithoutSecretaryProfileInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSecretaryProfileInput, UserUpdateWithoutSecretaryProfileInput>, UserUncheckedUpdateWithoutSecretaryProfileInput>
  }

  export type ClientProfileUpdateOneRequiredWithoutSecretaryProfileNestedInput = {
    create?: XOR<ClientProfileCreateWithoutSecretaryProfileInput, ClientProfileUncheckedCreateWithoutSecretaryProfileInput>
    connectOrCreate?: ClientProfileCreateOrConnectWithoutSecretaryProfileInput
    upsert?: ClientProfileUpsertWithoutSecretaryProfileInput
    connect?: ClientProfileWhereUniqueInput
    update?: XOR<XOR<ClientProfileUpdateToOneWithWhereWithoutSecretaryProfileInput, ClientProfileUpdateWithoutSecretaryProfileInput>, ClientProfileUncheckedUpdateWithoutSecretaryProfileInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedEnumFoodTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.FoodType | EnumFoodTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FoodType[] | ListEnumFoodTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FoodType[] | ListEnumFoodTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFoodTypeFilter<$PrismaModel> | $Enums.FoodType
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedEnumFoodTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FoodType | EnumFoodTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FoodType[] | ListEnumFoodTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FoodType[] | ListEnumFoodTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFoodTypeWithAggregatesFilter<$PrismaModel> | $Enums.FoodType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFoodTypeFilter<$PrismaModel>
    _max?: NestedEnumFoodTypeFilter<$PrismaModel>
  }

  export type NestedEnumFoodPetDayFilter<$PrismaModel = never> = {
    equals?: $Enums.FoodPetDay | EnumFoodPetDayFieldRefInput<$PrismaModel>
    in?: $Enums.FoodPetDay[] | ListEnumFoodPetDayFieldRefInput<$PrismaModel>
    notIn?: $Enums.FoodPetDay[] | ListEnumFoodPetDayFieldRefInput<$PrismaModel>
    not?: NestedEnumFoodPetDayFilter<$PrismaModel> | $Enums.FoodPetDay
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumFoodPetDayWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FoodPetDay | EnumFoodPetDayFieldRefInput<$PrismaModel>
    in?: $Enums.FoodPetDay[] | ListEnumFoodPetDayFieldRefInput<$PrismaModel>
    notIn?: $Enums.FoodPetDay[] | ListEnumFoodPetDayFieldRefInput<$PrismaModel>
    not?: NestedEnumFoodPetDayWithAggregatesFilter<$PrismaModel> | $Enums.FoodPetDay
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFoodPetDayFilter<$PrismaModel>
    _max?: NestedEnumFoodPetDayFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type VeterinarianProfileCreateWithoutClientPetInput = {
    id?: string
    licenseNumber: string
    specialty: string
    yearsExperience: number
    bio?: string | null
    clinic: ClientProfileCreateNestedOneWithoutVeterinarianProfileInput
    user: UserCreateNestedOneWithoutVeterinarianProfileInput
    clinicProfiles?: ClinicProfileCreateNestedManyWithoutVeterinarianProfileInput
    metting?: MettingCreateNestedManyWithoutVeterinarianInput
  }

  export type VeterinarianProfileUncheckedCreateWithoutClientPetInput = {
    id?: string
    licenseNumber: string
    specialty: string
    yearsExperience: number
    bio?: string | null
    clinicId: string
    userId: string
    clinicProfiles?: ClinicProfileUncheckedCreateNestedManyWithoutVeterinarianProfileInput
    metting?: MettingUncheckedCreateNestedManyWithoutVeterinarianInput
  }

  export type VeterinarianProfileCreateOrConnectWithoutClientPetInput = {
    where: VeterinarianProfileWhereUniqueInput
    create: XOR<VeterinarianProfileCreateWithoutClientPetInput, VeterinarianProfileUncheckedCreateWithoutClientPetInput>
  }

  export type ClientProfileCreateWithoutClientPetInput = {
    id?: string
    dateOfBirth: Date | string
    address?: string | null
    phone?: string | null
    user: UserCreateNestedOneWithoutClientProfileInput
    secretaryProfile?: SecretaryProfileCreateNestedOneWithoutClinicInput
    veterinarianProfile?: VeterinarianProfileCreateNestedOneWithoutClinicInput
    clinicProducts?: ClinicProductCreateNestedManyWithoutClinicInput
  }

  export type ClientProfileUncheckedCreateWithoutClientPetInput = {
    id?: string
    dateOfBirth: Date | string
    address?: string | null
    phone?: string | null
    userId: string
    secretaryProfile?: SecretaryProfileUncheckedCreateNestedOneWithoutClinicInput
    veterinarianProfile?: VeterinarianProfileUncheckedCreateNestedOneWithoutClinicInput
    clinicProducts?: ClinicProductUncheckedCreateNestedManyWithoutClinicInput
  }

  export type ClientProfileCreateOrConnectWithoutClientPetInput = {
    where: ClientProfileWhereUniqueInput
    create: XOR<ClientProfileCreateWithoutClientPetInput, ClientProfileUncheckedCreateWithoutClientPetInput>
  }

  export type RaceCreateWithoutClientPetInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    picture?: string | null
    pet: PetCreateNestedOneWithoutRacesInput
  }

  export type RaceUncheckedCreateWithoutClientPetInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    picture?: string | null
    petId: string
  }

  export type RaceCreateOrConnectWithoutClientPetInput = {
    where: RaceWhereUniqueInput
    create: XOR<RaceCreateWithoutClientPetInput, RaceUncheckedCreateWithoutClientPetInput>
  }

  export type PersonalPetVaccineCreateWithoutClientPetInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    vaccine: VaccineCreateNestedOneWithoutPersonalPetVaccineInput
    metting?: MettingCreateNestedOneWithoutPersonalPetVaccineInput
  }

  export type PersonalPetVaccineUncheckedCreateWithoutClientPetInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    vaccineId: string
    mettingId?: string | null
  }

  export type PersonalPetVaccineCreateOrConnectWithoutClientPetInput = {
    where: PersonalPetVaccineWhereUniqueInput
    create: XOR<PersonalPetVaccineCreateWithoutClientPetInput, PersonalPetVaccineUncheckedCreateWithoutClientPetInput>
  }

  export type PersonalPetVaccineCreateManyClientPetInputEnvelope = {
    data: PersonalPetVaccineCreateManyClientPetInput | PersonalPetVaccineCreateManyClientPetInput[]
    skipDuplicates?: boolean
  }

  export type MettingCreateWithoutClientPetInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    date: Date | string
    duration: Decimal | DecimalJsLike | number | string
    description?: string | null
    petWeight?: number | null
    petSize?: number | null
    veterinarian: VeterinarianProfileCreateNestedOneWithoutMettingInput
    personalPetVaccine?: PersonalPetVaccineCreateNestedManyWithoutMettingInput
  }

  export type MettingUncheckedCreateWithoutClientPetInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    date: Date | string
    duration: Decimal | DecimalJsLike | number | string
    description?: string | null
    petWeight?: number | null
    petSize?: number | null
    veterinarianId: string
    personalPetVaccine?: PersonalPetVaccineUncheckedCreateNestedManyWithoutMettingInput
  }

  export type MettingCreateOrConnectWithoutClientPetInput = {
    where: MettingWhereUniqueInput
    create: XOR<MettingCreateWithoutClientPetInput, MettingUncheckedCreateWithoutClientPetInput>
  }

  export type MettingCreateManyClientPetInputEnvelope = {
    data: MettingCreateManyClientPetInput | MettingCreateManyClientPetInput[]
    skipDuplicates?: boolean
  }

  export type FoodPetCreateWithoutClientPetInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    type: $Enums.FoodPetDay
    dateStart: Date | string
    dateEnd?: Date | string | null
    quantity: Decimal | DecimalJsLike | number | string
    hours: Date | string
    food: FoodCreateNestedOneWithoutFoodPetsInput
  }

  export type FoodPetUncheckedCreateWithoutClientPetInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    type: $Enums.FoodPetDay
    dateStart: Date | string
    dateEnd?: Date | string | null
    quantity: Decimal | DecimalJsLike | number | string
    hours: Date | string
    foodId: string
  }

  export type FoodPetCreateOrConnectWithoutClientPetInput = {
    where: FoodPetWhereUniqueInput
    create: XOR<FoodPetCreateWithoutClientPetInput, FoodPetUncheckedCreateWithoutClientPetInput>
  }

  export type FoodPetCreateManyClientPetInputEnvelope = {
    data: FoodPetCreateManyClientPetInput | FoodPetCreateManyClientPetInput[]
    skipDuplicates?: boolean
  }

  export type VeterinarianProfileUpsertWithoutClientPetInput = {
    update: XOR<VeterinarianProfileUpdateWithoutClientPetInput, VeterinarianProfileUncheckedUpdateWithoutClientPetInput>
    create: XOR<VeterinarianProfileCreateWithoutClientPetInput, VeterinarianProfileUncheckedCreateWithoutClientPetInput>
    where?: VeterinarianProfileWhereInput
  }

  export type VeterinarianProfileUpdateToOneWithWhereWithoutClientPetInput = {
    where?: VeterinarianProfileWhereInput
    data: XOR<VeterinarianProfileUpdateWithoutClientPetInput, VeterinarianProfileUncheckedUpdateWithoutClientPetInput>
  }

  export type VeterinarianProfileUpdateWithoutClientPetInput = {
    id?: StringFieldUpdateOperationsInput | string
    licenseNumber?: StringFieldUpdateOperationsInput | string
    specialty?: StringFieldUpdateOperationsInput | string
    yearsExperience?: IntFieldUpdateOperationsInput | number
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    clinic?: ClientProfileUpdateOneRequiredWithoutVeterinarianProfileNestedInput
    user?: UserUpdateOneRequiredWithoutVeterinarianProfileNestedInput
    clinicProfiles?: ClinicProfileUpdateManyWithoutVeterinarianProfileNestedInput
    metting?: MettingUpdateManyWithoutVeterinarianNestedInput
  }

  export type VeterinarianProfileUncheckedUpdateWithoutClientPetInput = {
    id?: StringFieldUpdateOperationsInput | string
    licenseNumber?: StringFieldUpdateOperationsInput | string
    specialty?: StringFieldUpdateOperationsInput | string
    yearsExperience?: IntFieldUpdateOperationsInput | number
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    clinicId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    clinicProfiles?: ClinicProfileUncheckedUpdateManyWithoutVeterinarianProfileNestedInput
    metting?: MettingUncheckedUpdateManyWithoutVeterinarianNestedInput
  }

  export type ClientProfileUpsertWithoutClientPetInput = {
    update: XOR<ClientProfileUpdateWithoutClientPetInput, ClientProfileUncheckedUpdateWithoutClientPetInput>
    create: XOR<ClientProfileCreateWithoutClientPetInput, ClientProfileUncheckedCreateWithoutClientPetInput>
    where?: ClientProfileWhereInput
  }

  export type ClientProfileUpdateToOneWithWhereWithoutClientPetInput = {
    where?: ClientProfileWhereInput
    data: XOR<ClientProfileUpdateWithoutClientPetInput, ClientProfileUncheckedUpdateWithoutClientPetInput>
  }

  export type ClientProfileUpdateWithoutClientPetInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutClientProfileNestedInput
    secretaryProfile?: SecretaryProfileUpdateOneWithoutClinicNestedInput
    veterinarianProfile?: VeterinarianProfileUpdateOneWithoutClinicNestedInput
    clinicProducts?: ClinicProductUpdateManyWithoutClinicNestedInput
  }

  export type ClientProfileUncheckedUpdateWithoutClientPetInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    secretaryProfile?: SecretaryProfileUncheckedUpdateOneWithoutClinicNestedInput
    veterinarianProfile?: VeterinarianProfileUncheckedUpdateOneWithoutClinicNestedInput
    clinicProducts?: ClinicProductUncheckedUpdateManyWithoutClinicNestedInput
  }

  export type RaceUpsertWithoutClientPetInput = {
    update: XOR<RaceUpdateWithoutClientPetInput, RaceUncheckedUpdateWithoutClientPetInput>
    create: XOR<RaceCreateWithoutClientPetInput, RaceUncheckedCreateWithoutClientPetInput>
    where?: RaceWhereInput
  }

  export type RaceUpdateToOneWithWhereWithoutClientPetInput = {
    where?: RaceWhereInput
    data: XOR<RaceUpdateWithoutClientPetInput, RaceUncheckedUpdateWithoutClientPetInput>
  }

  export type RaceUpdateWithoutClientPetInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    pet?: PetUpdateOneRequiredWithoutRacesNestedInput
  }

  export type RaceUncheckedUpdateWithoutClientPetInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    petId?: StringFieldUpdateOperationsInput | string
  }

  export type PersonalPetVaccineUpsertWithWhereUniqueWithoutClientPetInput = {
    where: PersonalPetVaccineWhereUniqueInput
    update: XOR<PersonalPetVaccineUpdateWithoutClientPetInput, PersonalPetVaccineUncheckedUpdateWithoutClientPetInput>
    create: XOR<PersonalPetVaccineCreateWithoutClientPetInput, PersonalPetVaccineUncheckedCreateWithoutClientPetInput>
  }

  export type PersonalPetVaccineUpdateWithWhereUniqueWithoutClientPetInput = {
    where: PersonalPetVaccineWhereUniqueInput
    data: XOR<PersonalPetVaccineUpdateWithoutClientPetInput, PersonalPetVaccineUncheckedUpdateWithoutClientPetInput>
  }

  export type PersonalPetVaccineUpdateManyWithWhereWithoutClientPetInput = {
    where: PersonalPetVaccineScalarWhereInput
    data: XOR<PersonalPetVaccineUpdateManyMutationInput, PersonalPetVaccineUncheckedUpdateManyWithoutClientPetInput>
  }

  export type PersonalPetVaccineScalarWhereInput = {
    AND?: PersonalPetVaccineScalarWhereInput | PersonalPetVaccineScalarWhereInput[]
    OR?: PersonalPetVaccineScalarWhereInput[]
    NOT?: PersonalPetVaccineScalarWhereInput | PersonalPetVaccineScalarWhereInput[]
    id?: StringFilter<"PersonalPetVaccine"> | string
    createdAt?: DateTimeFilter<"PersonalPetVaccine"> | Date | string
    updatedAt?: DateTimeFilter<"PersonalPetVaccine"> | Date | string
    clientPetId?: StringFilter<"PersonalPetVaccine"> | string
    vaccineId?: StringFilter<"PersonalPetVaccine"> | string
    mettingId?: StringNullableFilter<"PersonalPetVaccine"> | string | null
  }

  export type MettingUpsertWithWhereUniqueWithoutClientPetInput = {
    where: MettingWhereUniqueInput
    update: XOR<MettingUpdateWithoutClientPetInput, MettingUncheckedUpdateWithoutClientPetInput>
    create: XOR<MettingCreateWithoutClientPetInput, MettingUncheckedCreateWithoutClientPetInput>
  }

  export type MettingUpdateWithWhereUniqueWithoutClientPetInput = {
    where: MettingWhereUniqueInput
    data: XOR<MettingUpdateWithoutClientPetInput, MettingUncheckedUpdateWithoutClientPetInput>
  }

  export type MettingUpdateManyWithWhereWithoutClientPetInput = {
    where: MettingScalarWhereInput
    data: XOR<MettingUpdateManyMutationInput, MettingUncheckedUpdateManyWithoutClientPetInput>
  }

  export type MettingScalarWhereInput = {
    AND?: MettingScalarWhereInput | MettingScalarWhereInput[]
    OR?: MettingScalarWhereInput[]
    NOT?: MettingScalarWhereInput | MettingScalarWhereInput[]
    id?: StringFilter<"Metting"> | string
    createdAt?: DateTimeFilter<"Metting"> | Date | string
    updatedAt?: DateTimeFilter<"Metting"> | Date | string
    date?: DateTimeFilter<"Metting"> | Date | string
    duration?: DecimalFilter<"Metting"> | Decimal | DecimalJsLike | number | string
    description?: StringNullableFilter<"Metting"> | string | null
    petWeight?: IntNullableFilter<"Metting"> | number | null
    petSize?: IntNullableFilter<"Metting"> | number | null
    clientPetId?: StringFilter<"Metting"> | string
    veterinarianId?: StringFilter<"Metting"> | string
  }

  export type FoodPetUpsertWithWhereUniqueWithoutClientPetInput = {
    where: FoodPetWhereUniqueInput
    update: XOR<FoodPetUpdateWithoutClientPetInput, FoodPetUncheckedUpdateWithoutClientPetInput>
    create: XOR<FoodPetCreateWithoutClientPetInput, FoodPetUncheckedCreateWithoutClientPetInput>
  }

  export type FoodPetUpdateWithWhereUniqueWithoutClientPetInput = {
    where: FoodPetWhereUniqueInput
    data: XOR<FoodPetUpdateWithoutClientPetInput, FoodPetUncheckedUpdateWithoutClientPetInput>
  }

  export type FoodPetUpdateManyWithWhereWithoutClientPetInput = {
    where: FoodPetScalarWhereInput
    data: XOR<FoodPetUpdateManyMutationInput, FoodPetUncheckedUpdateManyWithoutClientPetInput>
  }

  export type FoodPetScalarWhereInput = {
    AND?: FoodPetScalarWhereInput | FoodPetScalarWhereInput[]
    OR?: FoodPetScalarWhereInput[]
    NOT?: FoodPetScalarWhereInput | FoodPetScalarWhereInput[]
    id?: StringFilter<"FoodPet"> | string
    createdAt?: DateTimeFilter<"FoodPet"> | Date | string
    updatedAt?: DateTimeFilter<"FoodPet"> | Date | string
    type?: EnumFoodPetDayFilter<"FoodPet"> | $Enums.FoodPetDay
    dateStart?: DateTimeFilter<"FoodPet"> | Date | string
    dateEnd?: DateTimeNullableFilter<"FoodPet"> | Date | string | null
    quantity?: DecimalFilter<"FoodPet"> | Decimal | DecimalJsLike | number | string
    hours?: DateTimeFilter<"FoodPet"> | Date | string
    foodId?: StringFilter<"FoodPet"> | string
    clientPetId?: StringFilter<"FoodPet"> | string
  }

  export type RaceCreateWithoutPetInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    picture?: string | null
    clientPet?: ClientPetCreateNestedManyWithoutRaceInput
  }

  export type RaceUncheckedCreateWithoutPetInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    picture?: string | null
    clientPet?: ClientPetUncheckedCreateNestedManyWithoutRaceInput
  }

  export type RaceCreateOrConnectWithoutPetInput = {
    where: RaceWhereUniqueInput
    create: XOR<RaceCreateWithoutPetInput, RaceUncheckedCreateWithoutPetInput>
  }

  export type RaceCreateManyPetInputEnvelope = {
    data: RaceCreateManyPetInput | RaceCreateManyPetInput[]
    skipDuplicates?: boolean
  }

  export type VaccineCreateWithoutPetInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    description?: string | null
    recommendedAge: number
    boosterInterval: number
    mandatoryCountry?: NullableJsonNullValueInput | InputJsonValue
    recommendedCountry?: NullableJsonNullValueInput | InputJsonValue
    personalPetVaccine?: PersonalPetVaccineCreateNestedManyWithoutVaccineInput
  }

  export type VaccineUncheckedCreateWithoutPetInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    description?: string | null
    recommendedAge: number
    boosterInterval: number
    mandatoryCountry?: NullableJsonNullValueInput | InputJsonValue
    recommendedCountry?: NullableJsonNullValueInput | InputJsonValue
    personalPetVaccine?: PersonalPetVaccineUncheckedCreateNestedManyWithoutVaccineInput
  }

  export type VaccineCreateOrConnectWithoutPetInput = {
    where: VaccineWhereUniqueInput
    create: XOR<VaccineCreateWithoutPetInput, VaccineUncheckedCreateWithoutPetInput>
  }

  export type VaccineCreateManyPetInputEnvelope = {
    data: VaccineCreateManyPetInput | VaccineCreateManyPetInput[]
    skipDuplicates?: boolean
  }

  export type RaceUpsertWithWhereUniqueWithoutPetInput = {
    where: RaceWhereUniqueInput
    update: XOR<RaceUpdateWithoutPetInput, RaceUncheckedUpdateWithoutPetInput>
    create: XOR<RaceCreateWithoutPetInput, RaceUncheckedCreateWithoutPetInput>
  }

  export type RaceUpdateWithWhereUniqueWithoutPetInput = {
    where: RaceWhereUniqueInput
    data: XOR<RaceUpdateWithoutPetInput, RaceUncheckedUpdateWithoutPetInput>
  }

  export type RaceUpdateManyWithWhereWithoutPetInput = {
    where: RaceScalarWhereInput
    data: XOR<RaceUpdateManyMutationInput, RaceUncheckedUpdateManyWithoutPetInput>
  }

  export type RaceScalarWhereInput = {
    AND?: RaceScalarWhereInput | RaceScalarWhereInput[]
    OR?: RaceScalarWhereInput[]
    NOT?: RaceScalarWhereInput | RaceScalarWhereInput[]
    id?: StringFilter<"Race"> | string
    createdAt?: DateTimeFilter<"Race"> | Date | string
    updatedAt?: DateTimeFilter<"Race"> | Date | string
    name?: StringFilter<"Race"> | string
    picture?: StringNullableFilter<"Race"> | string | null
    petId?: StringFilter<"Race"> | string
  }

  export type VaccineUpsertWithWhereUniqueWithoutPetInput = {
    where: VaccineWhereUniqueInput
    update: XOR<VaccineUpdateWithoutPetInput, VaccineUncheckedUpdateWithoutPetInput>
    create: XOR<VaccineCreateWithoutPetInput, VaccineUncheckedCreateWithoutPetInput>
  }

  export type VaccineUpdateWithWhereUniqueWithoutPetInput = {
    where: VaccineWhereUniqueInput
    data: XOR<VaccineUpdateWithoutPetInput, VaccineUncheckedUpdateWithoutPetInput>
  }

  export type VaccineUpdateManyWithWhereWithoutPetInput = {
    where: VaccineScalarWhereInput
    data: XOR<VaccineUpdateManyMutationInput, VaccineUncheckedUpdateManyWithoutPetInput>
  }

  export type VaccineScalarWhereInput = {
    AND?: VaccineScalarWhereInput | VaccineScalarWhereInput[]
    OR?: VaccineScalarWhereInput[]
    NOT?: VaccineScalarWhereInput | VaccineScalarWhereInput[]
    id?: StringFilter<"Vaccine"> | string
    createdAt?: DateTimeFilter<"Vaccine"> | Date | string
    updatedAt?: DateTimeFilter<"Vaccine"> | Date | string
    name?: StringFilter<"Vaccine"> | string
    description?: StringNullableFilter<"Vaccine"> | string | null
    recommendedAge?: IntFilter<"Vaccine"> | number
    boosterInterval?: IntFilter<"Vaccine"> | number
    mandatoryCountry?: JsonNullableFilter<"Vaccine">
    recommendedCountry?: JsonNullableFilter<"Vaccine">
    petId?: StringFilter<"Vaccine"> | string
  }

  export type PetCreateWithoutRacesInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    picture?: string | null
    vaccine?: VaccineCreateNestedManyWithoutPetInput
  }

  export type PetUncheckedCreateWithoutRacesInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    picture?: string | null
    vaccine?: VaccineUncheckedCreateNestedManyWithoutPetInput
  }

  export type PetCreateOrConnectWithoutRacesInput = {
    where: PetWhereUniqueInput
    create: XOR<PetCreateWithoutRacesInput, PetUncheckedCreateWithoutRacesInput>
  }

  export type ClientPetCreateWithoutRaceInput = {
    id?: string
    name: string
    dateOfBirth: Date | string
    description?: string | null
    activity?: number | null
    attendingVeterinarian?: VeterinarianProfileCreateNestedOneWithoutClientPetInput
    client: ClientProfileCreateNestedOneWithoutClientPetInput
    personalPetVaccine?: PersonalPetVaccineCreateNestedManyWithoutClientPetInput
    metting?: MettingCreateNestedManyWithoutClientPetInput
    foodPets?: FoodPetCreateNestedManyWithoutClientPetInput
  }

  export type ClientPetUncheckedCreateWithoutRaceInput = {
    id?: string
    name: string
    dateOfBirth: Date | string
    description?: string | null
    activity?: number | null
    attendingVeterinarianId?: string | null
    clientId: string
    personalPetVaccine?: PersonalPetVaccineUncheckedCreateNestedManyWithoutClientPetInput
    metting?: MettingUncheckedCreateNestedManyWithoutClientPetInput
    foodPets?: FoodPetUncheckedCreateNestedManyWithoutClientPetInput
  }

  export type ClientPetCreateOrConnectWithoutRaceInput = {
    where: ClientPetWhereUniqueInput
    create: XOR<ClientPetCreateWithoutRaceInput, ClientPetUncheckedCreateWithoutRaceInput>
  }

  export type ClientPetCreateManyRaceInputEnvelope = {
    data: ClientPetCreateManyRaceInput | ClientPetCreateManyRaceInput[]
    skipDuplicates?: boolean
  }

  export type PetUpsertWithoutRacesInput = {
    update: XOR<PetUpdateWithoutRacesInput, PetUncheckedUpdateWithoutRacesInput>
    create: XOR<PetCreateWithoutRacesInput, PetUncheckedCreateWithoutRacesInput>
    where?: PetWhereInput
  }

  export type PetUpdateToOneWithWhereWithoutRacesInput = {
    where?: PetWhereInput
    data: XOR<PetUpdateWithoutRacesInput, PetUncheckedUpdateWithoutRacesInput>
  }

  export type PetUpdateWithoutRacesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    vaccine?: VaccineUpdateManyWithoutPetNestedInput
  }

  export type PetUncheckedUpdateWithoutRacesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    vaccine?: VaccineUncheckedUpdateManyWithoutPetNestedInput
  }

  export type ClientPetUpsertWithWhereUniqueWithoutRaceInput = {
    where: ClientPetWhereUniqueInput
    update: XOR<ClientPetUpdateWithoutRaceInput, ClientPetUncheckedUpdateWithoutRaceInput>
    create: XOR<ClientPetCreateWithoutRaceInput, ClientPetUncheckedCreateWithoutRaceInput>
  }

  export type ClientPetUpdateWithWhereUniqueWithoutRaceInput = {
    where: ClientPetWhereUniqueInput
    data: XOR<ClientPetUpdateWithoutRaceInput, ClientPetUncheckedUpdateWithoutRaceInput>
  }

  export type ClientPetUpdateManyWithWhereWithoutRaceInput = {
    where: ClientPetScalarWhereInput
    data: XOR<ClientPetUpdateManyMutationInput, ClientPetUncheckedUpdateManyWithoutRaceInput>
  }

  export type ClientPetScalarWhereInput = {
    AND?: ClientPetScalarWhereInput | ClientPetScalarWhereInput[]
    OR?: ClientPetScalarWhereInput[]
    NOT?: ClientPetScalarWhereInput | ClientPetScalarWhereInput[]
    id?: StringFilter<"ClientPet"> | string
    name?: StringFilter<"ClientPet"> | string
    dateOfBirth?: DateTimeFilter<"ClientPet"> | Date | string
    description?: StringNullableFilter<"ClientPet"> | string | null
    activity?: IntNullableFilter<"ClientPet"> | number | null
    attendingVeterinarianId?: StringNullableFilter<"ClientPet"> | string | null
    clientId?: StringFilter<"ClientPet"> | string
    raceId?: StringFilter<"ClientPet"> | string
  }

  export type PetCreateWithoutVaccineInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    picture?: string | null
    races?: RaceCreateNestedManyWithoutPetInput
  }

  export type PetUncheckedCreateWithoutVaccineInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    picture?: string | null
    races?: RaceUncheckedCreateNestedManyWithoutPetInput
  }

  export type PetCreateOrConnectWithoutVaccineInput = {
    where: PetWhereUniqueInput
    create: XOR<PetCreateWithoutVaccineInput, PetUncheckedCreateWithoutVaccineInput>
  }

  export type PersonalPetVaccineCreateWithoutVaccineInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    clientPet: ClientPetCreateNestedOneWithoutPersonalPetVaccineInput
    metting?: MettingCreateNestedOneWithoutPersonalPetVaccineInput
  }

  export type PersonalPetVaccineUncheckedCreateWithoutVaccineInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    clientPetId: string
    mettingId?: string | null
  }

  export type PersonalPetVaccineCreateOrConnectWithoutVaccineInput = {
    where: PersonalPetVaccineWhereUniqueInput
    create: XOR<PersonalPetVaccineCreateWithoutVaccineInput, PersonalPetVaccineUncheckedCreateWithoutVaccineInput>
  }

  export type PersonalPetVaccineCreateManyVaccineInputEnvelope = {
    data: PersonalPetVaccineCreateManyVaccineInput | PersonalPetVaccineCreateManyVaccineInput[]
    skipDuplicates?: boolean
  }

  export type PetUpsertWithoutVaccineInput = {
    update: XOR<PetUpdateWithoutVaccineInput, PetUncheckedUpdateWithoutVaccineInput>
    create: XOR<PetCreateWithoutVaccineInput, PetUncheckedCreateWithoutVaccineInput>
    where?: PetWhereInput
  }

  export type PetUpdateToOneWithWhereWithoutVaccineInput = {
    where?: PetWhereInput
    data: XOR<PetUpdateWithoutVaccineInput, PetUncheckedUpdateWithoutVaccineInput>
  }

  export type PetUpdateWithoutVaccineInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    races?: RaceUpdateManyWithoutPetNestedInput
  }

  export type PetUncheckedUpdateWithoutVaccineInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    races?: RaceUncheckedUpdateManyWithoutPetNestedInput
  }

  export type PersonalPetVaccineUpsertWithWhereUniqueWithoutVaccineInput = {
    where: PersonalPetVaccineWhereUniqueInput
    update: XOR<PersonalPetVaccineUpdateWithoutVaccineInput, PersonalPetVaccineUncheckedUpdateWithoutVaccineInput>
    create: XOR<PersonalPetVaccineCreateWithoutVaccineInput, PersonalPetVaccineUncheckedCreateWithoutVaccineInput>
  }

  export type PersonalPetVaccineUpdateWithWhereUniqueWithoutVaccineInput = {
    where: PersonalPetVaccineWhereUniqueInput
    data: XOR<PersonalPetVaccineUpdateWithoutVaccineInput, PersonalPetVaccineUncheckedUpdateWithoutVaccineInput>
  }

  export type PersonalPetVaccineUpdateManyWithWhereWithoutVaccineInput = {
    where: PersonalPetVaccineScalarWhereInput
    data: XOR<PersonalPetVaccineUpdateManyMutationInput, PersonalPetVaccineUncheckedUpdateManyWithoutVaccineInput>
  }

  export type ClientPetCreateWithoutPersonalPetVaccineInput = {
    id?: string
    name: string
    dateOfBirth: Date | string
    description?: string | null
    activity?: number | null
    attendingVeterinarian?: VeterinarianProfileCreateNestedOneWithoutClientPetInput
    client: ClientProfileCreateNestedOneWithoutClientPetInput
    race: RaceCreateNestedOneWithoutClientPetInput
    metting?: MettingCreateNestedManyWithoutClientPetInput
    foodPets?: FoodPetCreateNestedManyWithoutClientPetInput
  }

  export type ClientPetUncheckedCreateWithoutPersonalPetVaccineInput = {
    id?: string
    name: string
    dateOfBirth: Date | string
    description?: string | null
    activity?: number | null
    attendingVeterinarianId?: string | null
    clientId: string
    raceId: string
    metting?: MettingUncheckedCreateNestedManyWithoutClientPetInput
    foodPets?: FoodPetUncheckedCreateNestedManyWithoutClientPetInput
  }

  export type ClientPetCreateOrConnectWithoutPersonalPetVaccineInput = {
    where: ClientPetWhereUniqueInput
    create: XOR<ClientPetCreateWithoutPersonalPetVaccineInput, ClientPetUncheckedCreateWithoutPersonalPetVaccineInput>
  }

  export type VaccineCreateWithoutPersonalPetVaccineInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    description?: string | null
    recommendedAge: number
    boosterInterval: number
    mandatoryCountry?: NullableJsonNullValueInput | InputJsonValue
    recommendedCountry?: NullableJsonNullValueInput | InputJsonValue
    pet: PetCreateNestedOneWithoutVaccineInput
  }

  export type VaccineUncheckedCreateWithoutPersonalPetVaccineInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    description?: string | null
    recommendedAge: number
    boosterInterval: number
    mandatoryCountry?: NullableJsonNullValueInput | InputJsonValue
    recommendedCountry?: NullableJsonNullValueInput | InputJsonValue
    petId: string
  }

  export type VaccineCreateOrConnectWithoutPersonalPetVaccineInput = {
    where: VaccineWhereUniqueInput
    create: XOR<VaccineCreateWithoutPersonalPetVaccineInput, VaccineUncheckedCreateWithoutPersonalPetVaccineInput>
  }

  export type MettingCreateWithoutPersonalPetVaccineInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    date: Date | string
    duration: Decimal | DecimalJsLike | number | string
    description?: string | null
    petWeight?: number | null
    petSize?: number | null
    clientPet: ClientPetCreateNestedOneWithoutMettingInput
    veterinarian: VeterinarianProfileCreateNestedOneWithoutMettingInput
  }

  export type MettingUncheckedCreateWithoutPersonalPetVaccineInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    date: Date | string
    duration: Decimal | DecimalJsLike | number | string
    description?: string | null
    petWeight?: number | null
    petSize?: number | null
    clientPetId: string
    veterinarianId: string
  }

  export type MettingCreateOrConnectWithoutPersonalPetVaccineInput = {
    where: MettingWhereUniqueInput
    create: XOR<MettingCreateWithoutPersonalPetVaccineInput, MettingUncheckedCreateWithoutPersonalPetVaccineInput>
  }

  export type ClientPetUpsertWithoutPersonalPetVaccineInput = {
    update: XOR<ClientPetUpdateWithoutPersonalPetVaccineInput, ClientPetUncheckedUpdateWithoutPersonalPetVaccineInput>
    create: XOR<ClientPetCreateWithoutPersonalPetVaccineInput, ClientPetUncheckedCreateWithoutPersonalPetVaccineInput>
    where?: ClientPetWhereInput
  }

  export type ClientPetUpdateToOneWithWhereWithoutPersonalPetVaccineInput = {
    where?: ClientPetWhereInput
    data: XOR<ClientPetUpdateWithoutPersonalPetVaccineInput, ClientPetUncheckedUpdateWithoutPersonalPetVaccineInput>
  }

  export type ClientPetUpdateWithoutPersonalPetVaccineInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    activity?: NullableIntFieldUpdateOperationsInput | number | null
    attendingVeterinarian?: VeterinarianProfileUpdateOneWithoutClientPetNestedInput
    client?: ClientProfileUpdateOneRequiredWithoutClientPetNestedInput
    race?: RaceUpdateOneRequiredWithoutClientPetNestedInput
    metting?: MettingUpdateManyWithoutClientPetNestedInput
    foodPets?: FoodPetUpdateManyWithoutClientPetNestedInput
  }

  export type ClientPetUncheckedUpdateWithoutPersonalPetVaccineInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    activity?: NullableIntFieldUpdateOperationsInput | number | null
    attendingVeterinarianId?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    raceId?: StringFieldUpdateOperationsInput | string
    metting?: MettingUncheckedUpdateManyWithoutClientPetNestedInput
    foodPets?: FoodPetUncheckedUpdateManyWithoutClientPetNestedInput
  }

  export type VaccineUpsertWithoutPersonalPetVaccineInput = {
    update: XOR<VaccineUpdateWithoutPersonalPetVaccineInput, VaccineUncheckedUpdateWithoutPersonalPetVaccineInput>
    create: XOR<VaccineCreateWithoutPersonalPetVaccineInput, VaccineUncheckedCreateWithoutPersonalPetVaccineInput>
    where?: VaccineWhereInput
  }

  export type VaccineUpdateToOneWithWhereWithoutPersonalPetVaccineInput = {
    where?: VaccineWhereInput
    data: XOR<VaccineUpdateWithoutPersonalPetVaccineInput, VaccineUncheckedUpdateWithoutPersonalPetVaccineInput>
  }

  export type VaccineUpdateWithoutPersonalPetVaccineInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    recommendedAge?: IntFieldUpdateOperationsInput | number
    boosterInterval?: IntFieldUpdateOperationsInput | number
    mandatoryCountry?: NullableJsonNullValueInput | InputJsonValue
    recommendedCountry?: NullableJsonNullValueInput | InputJsonValue
    pet?: PetUpdateOneRequiredWithoutVaccineNestedInput
  }

  export type VaccineUncheckedUpdateWithoutPersonalPetVaccineInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    recommendedAge?: IntFieldUpdateOperationsInput | number
    boosterInterval?: IntFieldUpdateOperationsInput | number
    mandatoryCountry?: NullableJsonNullValueInput | InputJsonValue
    recommendedCountry?: NullableJsonNullValueInput | InputJsonValue
    petId?: StringFieldUpdateOperationsInput | string
  }

  export type MettingUpsertWithoutPersonalPetVaccineInput = {
    update: XOR<MettingUpdateWithoutPersonalPetVaccineInput, MettingUncheckedUpdateWithoutPersonalPetVaccineInput>
    create: XOR<MettingCreateWithoutPersonalPetVaccineInput, MettingUncheckedCreateWithoutPersonalPetVaccineInput>
    where?: MettingWhereInput
  }

  export type MettingUpdateToOneWithWhereWithoutPersonalPetVaccineInput = {
    where?: MettingWhereInput
    data: XOR<MettingUpdateWithoutPersonalPetVaccineInput, MettingUncheckedUpdateWithoutPersonalPetVaccineInput>
  }

  export type MettingUpdateWithoutPersonalPetVaccineInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    petWeight?: NullableIntFieldUpdateOperationsInput | number | null
    petSize?: NullableIntFieldUpdateOperationsInput | number | null
    clientPet?: ClientPetUpdateOneRequiredWithoutMettingNestedInput
    veterinarian?: VeterinarianProfileUpdateOneRequiredWithoutMettingNestedInput
  }

  export type MettingUncheckedUpdateWithoutPersonalPetVaccineInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    petWeight?: NullableIntFieldUpdateOperationsInput | number | null
    petSize?: NullableIntFieldUpdateOperationsInput | number | null
    clientPetId?: StringFieldUpdateOperationsInput | string
    veterinarianId?: StringFieldUpdateOperationsInput | string
  }

  export type ClientPetCreateWithoutMettingInput = {
    id?: string
    name: string
    dateOfBirth: Date | string
    description?: string | null
    activity?: number | null
    attendingVeterinarian?: VeterinarianProfileCreateNestedOneWithoutClientPetInput
    client: ClientProfileCreateNestedOneWithoutClientPetInput
    race: RaceCreateNestedOneWithoutClientPetInput
    personalPetVaccine?: PersonalPetVaccineCreateNestedManyWithoutClientPetInput
    foodPets?: FoodPetCreateNestedManyWithoutClientPetInput
  }

  export type ClientPetUncheckedCreateWithoutMettingInput = {
    id?: string
    name: string
    dateOfBirth: Date | string
    description?: string | null
    activity?: number | null
    attendingVeterinarianId?: string | null
    clientId: string
    raceId: string
    personalPetVaccine?: PersonalPetVaccineUncheckedCreateNestedManyWithoutClientPetInput
    foodPets?: FoodPetUncheckedCreateNestedManyWithoutClientPetInput
  }

  export type ClientPetCreateOrConnectWithoutMettingInput = {
    where: ClientPetWhereUniqueInput
    create: XOR<ClientPetCreateWithoutMettingInput, ClientPetUncheckedCreateWithoutMettingInput>
  }

  export type VeterinarianProfileCreateWithoutMettingInput = {
    id?: string
    licenseNumber: string
    specialty: string
    yearsExperience: number
    bio?: string | null
    clinic: ClientProfileCreateNestedOneWithoutVeterinarianProfileInput
    user: UserCreateNestedOneWithoutVeterinarianProfileInput
    clinicProfiles?: ClinicProfileCreateNestedManyWithoutVeterinarianProfileInput
    clientPet?: ClientPetCreateNestedManyWithoutAttendingVeterinarianInput
  }

  export type VeterinarianProfileUncheckedCreateWithoutMettingInput = {
    id?: string
    licenseNumber: string
    specialty: string
    yearsExperience: number
    bio?: string | null
    clinicId: string
    userId: string
    clinicProfiles?: ClinicProfileUncheckedCreateNestedManyWithoutVeterinarianProfileInput
    clientPet?: ClientPetUncheckedCreateNestedManyWithoutAttendingVeterinarianInput
  }

  export type VeterinarianProfileCreateOrConnectWithoutMettingInput = {
    where: VeterinarianProfileWhereUniqueInput
    create: XOR<VeterinarianProfileCreateWithoutMettingInput, VeterinarianProfileUncheckedCreateWithoutMettingInput>
  }

  export type PersonalPetVaccineCreateWithoutMettingInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    clientPet: ClientPetCreateNestedOneWithoutPersonalPetVaccineInput
    vaccine: VaccineCreateNestedOneWithoutPersonalPetVaccineInput
  }

  export type PersonalPetVaccineUncheckedCreateWithoutMettingInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    clientPetId: string
    vaccineId: string
  }

  export type PersonalPetVaccineCreateOrConnectWithoutMettingInput = {
    where: PersonalPetVaccineWhereUniqueInput
    create: XOR<PersonalPetVaccineCreateWithoutMettingInput, PersonalPetVaccineUncheckedCreateWithoutMettingInput>
  }

  export type PersonalPetVaccineCreateManyMettingInputEnvelope = {
    data: PersonalPetVaccineCreateManyMettingInput | PersonalPetVaccineCreateManyMettingInput[]
    skipDuplicates?: boolean
  }

  export type ClientPetUpsertWithoutMettingInput = {
    update: XOR<ClientPetUpdateWithoutMettingInput, ClientPetUncheckedUpdateWithoutMettingInput>
    create: XOR<ClientPetCreateWithoutMettingInput, ClientPetUncheckedCreateWithoutMettingInput>
    where?: ClientPetWhereInput
  }

  export type ClientPetUpdateToOneWithWhereWithoutMettingInput = {
    where?: ClientPetWhereInput
    data: XOR<ClientPetUpdateWithoutMettingInput, ClientPetUncheckedUpdateWithoutMettingInput>
  }

  export type ClientPetUpdateWithoutMettingInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    activity?: NullableIntFieldUpdateOperationsInput | number | null
    attendingVeterinarian?: VeterinarianProfileUpdateOneWithoutClientPetNestedInput
    client?: ClientProfileUpdateOneRequiredWithoutClientPetNestedInput
    race?: RaceUpdateOneRequiredWithoutClientPetNestedInput
    personalPetVaccine?: PersonalPetVaccineUpdateManyWithoutClientPetNestedInput
    foodPets?: FoodPetUpdateManyWithoutClientPetNestedInput
  }

  export type ClientPetUncheckedUpdateWithoutMettingInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    activity?: NullableIntFieldUpdateOperationsInput | number | null
    attendingVeterinarianId?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    raceId?: StringFieldUpdateOperationsInput | string
    personalPetVaccine?: PersonalPetVaccineUncheckedUpdateManyWithoutClientPetNestedInput
    foodPets?: FoodPetUncheckedUpdateManyWithoutClientPetNestedInput
  }

  export type VeterinarianProfileUpsertWithoutMettingInput = {
    update: XOR<VeterinarianProfileUpdateWithoutMettingInput, VeterinarianProfileUncheckedUpdateWithoutMettingInput>
    create: XOR<VeterinarianProfileCreateWithoutMettingInput, VeterinarianProfileUncheckedCreateWithoutMettingInput>
    where?: VeterinarianProfileWhereInput
  }

  export type VeterinarianProfileUpdateToOneWithWhereWithoutMettingInput = {
    where?: VeterinarianProfileWhereInput
    data: XOR<VeterinarianProfileUpdateWithoutMettingInput, VeterinarianProfileUncheckedUpdateWithoutMettingInput>
  }

  export type VeterinarianProfileUpdateWithoutMettingInput = {
    id?: StringFieldUpdateOperationsInput | string
    licenseNumber?: StringFieldUpdateOperationsInput | string
    specialty?: StringFieldUpdateOperationsInput | string
    yearsExperience?: IntFieldUpdateOperationsInput | number
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    clinic?: ClientProfileUpdateOneRequiredWithoutVeterinarianProfileNestedInput
    user?: UserUpdateOneRequiredWithoutVeterinarianProfileNestedInput
    clinicProfiles?: ClinicProfileUpdateManyWithoutVeterinarianProfileNestedInput
    clientPet?: ClientPetUpdateManyWithoutAttendingVeterinarianNestedInput
  }

  export type VeterinarianProfileUncheckedUpdateWithoutMettingInput = {
    id?: StringFieldUpdateOperationsInput | string
    licenseNumber?: StringFieldUpdateOperationsInput | string
    specialty?: StringFieldUpdateOperationsInput | string
    yearsExperience?: IntFieldUpdateOperationsInput | number
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    clinicId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    clinicProfiles?: ClinicProfileUncheckedUpdateManyWithoutVeterinarianProfileNestedInput
    clientPet?: ClientPetUncheckedUpdateManyWithoutAttendingVeterinarianNestedInput
  }

  export type PersonalPetVaccineUpsertWithWhereUniqueWithoutMettingInput = {
    where: PersonalPetVaccineWhereUniqueInput
    update: XOR<PersonalPetVaccineUpdateWithoutMettingInput, PersonalPetVaccineUncheckedUpdateWithoutMettingInput>
    create: XOR<PersonalPetVaccineCreateWithoutMettingInput, PersonalPetVaccineUncheckedCreateWithoutMettingInput>
  }

  export type PersonalPetVaccineUpdateWithWhereUniqueWithoutMettingInput = {
    where: PersonalPetVaccineWhereUniqueInput
    data: XOR<PersonalPetVaccineUpdateWithoutMettingInput, PersonalPetVaccineUncheckedUpdateWithoutMettingInput>
  }

  export type PersonalPetVaccineUpdateManyWithWhereWithoutMettingInput = {
    where: PersonalPetVaccineScalarWhereInput
    data: XOR<PersonalPetVaccineUpdateManyMutationInput, PersonalPetVaccineUncheckedUpdateManyWithoutMettingInput>
  }

  export type BrandCreateWithoutProductInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    logo?: string | null
  }

  export type BrandUncheckedCreateWithoutProductInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    logo?: string | null
  }

  export type BrandCreateOrConnectWithoutProductInput = {
    where: BrandWhereUniqueInput
    create: XOR<BrandCreateWithoutProductInput, BrandUncheckedCreateWithoutProductInput>
  }

  export type ClinicProductCreateWithoutProductInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    stock?: number
    minimumRequired: number
    clinic: ClientProfileCreateNestedOneWithoutClinicProductsInput
  }

  export type ClinicProductUncheckedCreateWithoutProductInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    stock?: number
    minimumRequired: number
    clinicId: string
  }

  export type ClinicProductCreateOrConnectWithoutProductInput = {
    where: ClinicProductWhereUniqueInput
    create: XOR<ClinicProductCreateWithoutProductInput, ClinicProductUncheckedCreateWithoutProductInput>
  }

  export type ClinicProductCreateManyProductInputEnvelope = {
    data: ClinicProductCreateManyProductInput | ClinicProductCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type FoodCreateWithoutProductInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    caloriesPer100?: Decimal | DecimalJsLike | number | string | null
    proteinPer100?: Decimal | DecimalJsLike | number | string | null
    fatPercentage?: Decimal | DecimalJsLike | number | string | null
    fiberPercentage?: Decimal | DecimalJsLike | number | string | null
    moisturePercentage?: Decimal | DecimalJsLike | number | string | null
    type: $Enums.FoodType
    foodPets?: FoodPetCreateNestedManyWithoutFoodInput
  }

  export type FoodUncheckedCreateWithoutProductInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    caloriesPer100?: Decimal | DecimalJsLike | number | string | null
    proteinPer100?: Decimal | DecimalJsLike | number | string | null
    fatPercentage?: Decimal | DecimalJsLike | number | string | null
    fiberPercentage?: Decimal | DecimalJsLike | number | string | null
    moisturePercentage?: Decimal | DecimalJsLike | number | string | null
    type: $Enums.FoodType
    foodPets?: FoodPetUncheckedCreateNestedManyWithoutFoodInput
  }

  export type FoodCreateOrConnectWithoutProductInput = {
    where: FoodWhereUniqueInput
    create: XOR<FoodCreateWithoutProductInput, FoodUncheckedCreateWithoutProductInput>
  }

  export type BrandUpsertWithoutProductInput = {
    update: XOR<BrandUpdateWithoutProductInput, BrandUncheckedUpdateWithoutProductInput>
    create: XOR<BrandCreateWithoutProductInput, BrandUncheckedCreateWithoutProductInput>
    where?: BrandWhereInput
  }

  export type BrandUpdateToOneWithWhereWithoutProductInput = {
    where?: BrandWhereInput
    data: XOR<BrandUpdateWithoutProductInput, BrandUncheckedUpdateWithoutProductInput>
  }

  export type BrandUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BrandUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ClinicProductUpsertWithWhereUniqueWithoutProductInput = {
    where: ClinicProductWhereUniqueInput
    update: XOR<ClinicProductUpdateWithoutProductInput, ClinicProductUncheckedUpdateWithoutProductInput>
    create: XOR<ClinicProductCreateWithoutProductInput, ClinicProductUncheckedCreateWithoutProductInput>
  }

  export type ClinicProductUpdateWithWhereUniqueWithoutProductInput = {
    where: ClinicProductWhereUniqueInput
    data: XOR<ClinicProductUpdateWithoutProductInput, ClinicProductUncheckedUpdateWithoutProductInput>
  }

  export type ClinicProductUpdateManyWithWhereWithoutProductInput = {
    where: ClinicProductScalarWhereInput
    data: XOR<ClinicProductUpdateManyMutationInput, ClinicProductUncheckedUpdateManyWithoutProductInput>
  }

  export type ClinicProductScalarWhereInput = {
    AND?: ClinicProductScalarWhereInput | ClinicProductScalarWhereInput[]
    OR?: ClinicProductScalarWhereInput[]
    NOT?: ClinicProductScalarWhereInput | ClinicProductScalarWhereInput[]
    id?: StringFilter<"ClinicProduct"> | string
    createdAt?: DateTimeFilter<"ClinicProduct"> | Date | string
    updatedAt?: DateTimeFilter<"ClinicProduct"> | Date | string
    stock?: IntFilter<"ClinicProduct"> | number
    minimumRequired?: IntFilter<"ClinicProduct"> | number
    clinicId?: StringFilter<"ClinicProduct"> | string
    productId?: StringFilter<"ClinicProduct"> | string
  }

  export type FoodUpsertWithoutProductInput = {
    update: XOR<FoodUpdateWithoutProductInput, FoodUncheckedUpdateWithoutProductInput>
    create: XOR<FoodCreateWithoutProductInput, FoodUncheckedCreateWithoutProductInput>
    where?: FoodWhereInput
  }

  export type FoodUpdateToOneWithWhereWithoutProductInput = {
    where?: FoodWhereInput
    data: XOR<FoodUpdateWithoutProductInput, FoodUncheckedUpdateWithoutProductInput>
  }

  export type FoodUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    caloriesPer100?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    proteinPer100?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fatPercentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fiberPercentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    moisturePercentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    type?: EnumFoodTypeFieldUpdateOperationsInput | $Enums.FoodType
    foodPets?: FoodPetUpdateManyWithoutFoodNestedInput
  }

  export type FoodUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    caloriesPer100?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    proteinPer100?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fatPercentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fiberPercentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    moisturePercentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    type?: EnumFoodTypeFieldUpdateOperationsInput | $Enums.FoodType
    foodPets?: FoodPetUncheckedUpdateManyWithoutFoodNestedInput
  }

  export type ProductCreateWithoutFoodInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    description?: string | null
    qrCode: string
    websiteUrl?: string | null
    picture?: string | null
    brand: BrandCreateNestedOneWithoutProductInput
    clinicProducts?: ClinicProductCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutFoodInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    description?: string | null
    qrCode: string
    websiteUrl?: string | null
    picture?: string | null
    brandId: string
    clinicProducts?: ClinicProductUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutFoodInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutFoodInput, ProductUncheckedCreateWithoutFoodInput>
  }

  export type FoodPetCreateWithoutFoodInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    type: $Enums.FoodPetDay
    dateStart: Date | string
    dateEnd?: Date | string | null
    quantity: Decimal | DecimalJsLike | number | string
    hours: Date | string
    clientPet: ClientPetCreateNestedOneWithoutFoodPetsInput
  }

  export type FoodPetUncheckedCreateWithoutFoodInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    type: $Enums.FoodPetDay
    dateStart: Date | string
    dateEnd?: Date | string | null
    quantity: Decimal | DecimalJsLike | number | string
    hours: Date | string
    clientPetId: string
  }

  export type FoodPetCreateOrConnectWithoutFoodInput = {
    where: FoodPetWhereUniqueInput
    create: XOR<FoodPetCreateWithoutFoodInput, FoodPetUncheckedCreateWithoutFoodInput>
  }

  export type FoodPetCreateManyFoodInputEnvelope = {
    data: FoodPetCreateManyFoodInput | FoodPetCreateManyFoodInput[]
    skipDuplicates?: boolean
  }

  export type ProductUpsertWithoutFoodInput = {
    update: XOR<ProductUpdateWithoutFoodInput, ProductUncheckedUpdateWithoutFoodInput>
    create: XOR<ProductCreateWithoutFoodInput, ProductUncheckedCreateWithoutFoodInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutFoodInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutFoodInput, ProductUncheckedUpdateWithoutFoodInput>
  }

  export type ProductUpdateWithoutFoodInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    qrCode?: StringFieldUpdateOperationsInput | string
    websiteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    brand?: BrandUpdateOneRequiredWithoutProductNestedInput
    clinicProducts?: ClinicProductUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutFoodInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    qrCode?: StringFieldUpdateOperationsInput | string
    websiteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    brandId?: StringFieldUpdateOperationsInput | string
    clinicProducts?: ClinicProductUncheckedUpdateManyWithoutProductNestedInput
  }

  export type FoodPetUpsertWithWhereUniqueWithoutFoodInput = {
    where: FoodPetWhereUniqueInput
    update: XOR<FoodPetUpdateWithoutFoodInput, FoodPetUncheckedUpdateWithoutFoodInput>
    create: XOR<FoodPetCreateWithoutFoodInput, FoodPetUncheckedCreateWithoutFoodInput>
  }

  export type FoodPetUpdateWithWhereUniqueWithoutFoodInput = {
    where: FoodPetWhereUniqueInput
    data: XOR<FoodPetUpdateWithoutFoodInput, FoodPetUncheckedUpdateWithoutFoodInput>
  }

  export type FoodPetUpdateManyWithWhereWithoutFoodInput = {
    where: FoodPetScalarWhereInput
    data: XOR<FoodPetUpdateManyMutationInput, FoodPetUncheckedUpdateManyWithoutFoodInput>
  }

  export type ProductCreateWithoutBrandInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    description?: string | null
    qrCode: string
    websiteUrl?: string | null
    picture?: string | null
    clinicProducts?: ClinicProductCreateNestedManyWithoutProductInput
    Food?: FoodCreateNestedOneWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutBrandInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    description?: string | null
    qrCode: string
    websiteUrl?: string | null
    picture?: string | null
    clinicProducts?: ClinicProductUncheckedCreateNestedManyWithoutProductInput
    Food?: FoodUncheckedCreateNestedOneWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutBrandInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutBrandInput, ProductUncheckedCreateWithoutBrandInput>
  }

  export type ProductCreateManyBrandInputEnvelope = {
    data: ProductCreateManyBrandInput | ProductCreateManyBrandInput[]
    skipDuplicates?: boolean
  }

  export type ProductUpsertWithWhereUniqueWithoutBrandInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutBrandInput, ProductUncheckedUpdateWithoutBrandInput>
    create: XOR<ProductCreateWithoutBrandInput, ProductUncheckedCreateWithoutBrandInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutBrandInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutBrandInput, ProductUncheckedUpdateWithoutBrandInput>
  }

  export type ProductUpdateManyWithWhereWithoutBrandInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutBrandInput>
  }

  export type ProductScalarWhereInput = {
    AND?: ProductScalarWhereInput | ProductScalarWhereInput[]
    OR?: ProductScalarWhereInput[]
    NOT?: ProductScalarWhereInput | ProductScalarWhereInput[]
    id?: StringFilter<"Product"> | string
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    name?: StringFilter<"Product"> | string
    description?: StringNullableFilter<"Product"> | string | null
    qrCode?: StringFilter<"Product"> | string
    websiteUrl?: StringNullableFilter<"Product"> | string | null
    picture?: StringNullableFilter<"Product"> | string | null
    brandId?: StringFilter<"Product"> | string
  }

  export type ClientProfileCreateWithoutClinicProductsInput = {
    id?: string
    dateOfBirth: Date | string
    address?: string | null
    phone?: string | null
    user: UserCreateNestedOneWithoutClientProfileInput
    secretaryProfile?: SecretaryProfileCreateNestedOneWithoutClinicInput
    veterinarianProfile?: VeterinarianProfileCreateNestedOneWithoutClinicInput
    clientPet?: ClientPetCreateNestedManyWithoutClientInput
  }

  export type ClientProfileUncheckedCreateWithoutClinicProductsInput = {
    id?: string
    dateOfBirth: Date | string
    address?: string | null
    phone?: string | null
    userId: string
    secretaryProfile?: SecretaryProfileUncheckedCreateNestedOneWithoutClinicInput
    veterinarianProfile?: VeterinarianProfileUncheckedCreateNestedOneWithoutClinicInput
    clientPet?: ClientPetUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientProfileCreateOrConnectWithoutClinicProductsInput = {
    where: ClientProfileWhereUniqueInput
    create: XOR<ClientProfileCreateWithoutClinicProductsInput, ClientProfileUncheckedCreateWithoutClinicProductsInput>
  }

  export type ProductCreateWithoutClinicProductsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    description?: string | null
    qrCode: string
    websiteUrl?: string | null
    picture?: string | null
    brand: BrandCreateNestedOneWithoutProductInput
    Food?: FoodCreateNestedOneWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutClinicProductsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    description?: string | null
    qrCode: string
    websiteUrl?: string | null
    picture?: string | null
    brandId: string
    Food?: FoodUncheckedCreateNestedOneWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutClinicProductsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutClinicProductsInput, ProductUncheckedCreateWithoutClinicProductsInput>
  }

  export type ClientProfileUpsertWithoutClinicProductsInput = {
    update: XOR<ClientProfileUpdateWithoutClinicProductsInput, ClientProfileUncheckedUpdateWithoutClinicProductsInput>
    create: XOR<ClientProfileCreateWithoutClinicProductsInput, ClientProfileUncheckedCreateWithoutClinicProductsInput>
    where?: ClientProfileWhereInput
  }

  export type ClientProfileUpdateToOneWithWhereWithoutClinicProductsInput = {
    where?: ClientProfileWhereInput
    data: XOR<ClientProfileUpdateWithoutClinicProductsInput, ClientProfileUncheckedUpdateWithoutClinicProductsInput>
  }

  export type ClientProfileUpdateWithoutClinicProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutClientProfileNestedInput
    secretaryProfile?: SecretaryProfileUpdateOneWithoutClinicNestedInput
    veterinarianProfile?: VeterinarianProfileUpdateOneWithoutClinicNestedInput
    clientPet?: ClientPetUpdateManyWithoutClientNestedInput
  }

  export type ClientProfileUncheckedUpdateWithoutClinicProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    secretaryProfile?: SecretaryProfileUncheckedUpdateOneWithoutClinicNestedInput
    veterinarianProfile?: VeterinarianProfileUncheckedUpdateOneWithoutClinicNestedInput
    clientPet?: ClientPetUncheckedUpdateManyWithoutClientNestedInput
  }

  export type ProductUpsertWithoutClinicProductsInput = {
    update: XOR<ProductUpdateWithoutClinicProductsInput, ProductUncheckedUpdateWithoutClinicProductsInput>
    create: XOR<ProductCreateWithoutClinicProductsInput, ProductUncheckedCreateWithoutClinicProductsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutClinicProductsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutClinicProductsInput, ProductUncheckedUpdateWithoutClinicProductsInput>
  }

  export type ProductUpdateWithoutClinicProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    qrCode?: StringFieldUpdateOperationsInput | string
    websiteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    brand?: BrandUpdateOneRequiredWithoutProductNestedInput
    Food?: FoodUpdateOneWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutClinicProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    qrCode?: StringFieldUpdateOperationsInput | string
    websiteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    brandId?: StringFieldUpdateOperationsInput | string
    Food?: FoodUncheckedUpdateOneWithoutProductNestedInput
  }

  export type FoodCreateWithoutFoodPetsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    caloriesPer100?: Decimal | DecimalJsLike | number | string | null
    proteinPer100?: Decimal | DecimalJsLike | number | string | null
    fatPercentage?: Decimal | DecimalJsLike | number | string | null
    fiberPercentage?: Decimal | DecimalJsLike | number | string | null
    moisturePercentage?: Decimal | DecimalJsLike | number | string | null
    type: $Enums.FoodType
    product: ProductCreateNestedOneWithoutFoodInput
  }

  export type FoodUncheckedCreateWithoutFoodPetsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    caloriesPer100?: Decimal | DecimalJsLike | number | string | null
    proteinPer100?: Decimal | DecimalJsLike | number | string | null
    fatPercentage?: Decimal | DecimalJsLike | number | string | null
    fiberPercentage?: Decimal | DecimalJsLike | number | string | null
    moisturePercentage?: Decimal | DecimalJsLike | number | string | null
    type: $Enums.FoodType
    productId: string
  }

  export type FoodCreateOrConnectWithoutFoodPetsInput = {
    where: FoodWhereUniqueInput
    create: XOR<FoodCreateWithoutFoodPetsInput, FoodUncheckedCreateWithoutFoodPetsInput>
  }

  export type ClientPetCreateWithoutFoodPetsInput = {
    id?: string
    name: string
    dateOfBirth: Date | string
    description?: string | null
    activity?: number | null
    attendingVeterinarian?: VeterinarianProfileCreateNestedOneWithoutClientPetInput
    client: ClientProfileCreateNestedOneWithoutClientPetInput
    race: RaceCreateNestedOneWithoutClientPetInput
    personalPetVaccine?: PersonalPetVaccineCreateNestedManyWithoutClientPetInput
    metting?: MettingCreateNestedManyWithoutClientPetInput
  }

  export type ClientPetUncheckedCreateWithoutFoodPetsInput = {
    id?: string
    name: string
    dateOfBirth: Date | string
    description?: string | null
    activity?: number | null
    attendingVeterinarianId?: string | null
    clientId: string
    raceId: string
    personalPetVaccine?: PersonalPetVaccineUncheckedCreateNestedManyWithoutClientPetInput
    metting?: MettingUncheckedCreateNestedManyWithoutClientPetInput
  }

  export type ClientPetCreateOrConnectWithoutFoodPetsInput = {
    where: ClientPetWhereUniqueInput
    create: XOR<ClientPetCreateWithoutFoodPetsInput, ClientPetUncheckedCreateWithoutFoodPetsInput>
  }

  export type FoodUpsertWithoutFoodPetsInput = {
    update: XOR<FoodUpdateWithoutFoodPetsInput, FoodUncheckedUpdateWithoutFoodPetsInput>
    create: XOR<FoodCreateWithoutFoodPetsInput, FoodUncheckedCreateWithoutFoodPetsInput>
    where?: FoodWhereInput
  }

  export type FoodUpdateToOneWithWhereWithoutFoodPetsInput = {
    where?: FoodWhereInput
    data: XOR<FoodUpdateWithoutFoodPetsInput, FoodUncheckedUpdateWithoutFoodPetsInput>
  }

  export type FoodUpdateWithoutFoodPetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    caloriesPer100?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    proteinPer100?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fatPercentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fiberPercentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    moisturePercentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    type?: EnumFoodTypeFieldUpdateOperationsInput | $Enums.FoodType
    product?: ProductUpdateOneRequiredWithoutFoodNestedInput
  }

  export type FoodUncheckedUpdateWithoutFoodPetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    caloriesPer100?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    proteinPer100?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fatPercentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fiberPercentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    moisturePercentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    type?: EnumFoodTypeFieldUpdateOperationsInput | $Enums.FoodType
    productId?: StringFieldUpdateOperationsInput | string
  }

  export type ClientPetUpsertWithoutFoodPetsInput = {
    update: XOR<ClientPetUpdateWithoutFoodPetsInput, ClientPetUncheckedUpdateWithoutFoodPetsInput>
    create: XOR<ClientPetCreateWithoutFoodPetsInput, ClientPetUncheckedCreateWithoutFoodPetsInput>
    where?: ClientPetWhereInput
  }

  export type ClientPetUpdateToOneWithWhereWithoutFoodPetsInput = {
    where?: ClientPetWhereInput
    data: XOR<ClientPetUpdateWithoutFoodPetsInput, ClientPetUncheckedUpdateWithoutFoodPetsInput>
  }

  export type ClientPetUpdateWithoutFoodPetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    activity?: NullableIntFieldUpdateOperationsInput | number | null
    attendingVeterinarian?: VeterinarianProfileUpdateOneWithoutClientPetNestedInput
    client?: ClientProfileUpdateOneRequiredWithoutClientPetNestedInput
    race?: RaceUpdateOneRequiredWithoutClientPetNestedInput
    personalPetVaccine?: PersonalPetVaccineUpdateManyWithoutClientPetNestedInput
    metting?: MettingUpdateManyWithoutClientPetNestedInput
  }

  export type ClientPetUncheckedUpdateWithoutFoodPetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    activity?: NullableIntFieldUpdateOperationsInput | number | null
    attendingVeterinarianId?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    raceId?: StringFieldUpdateOperationsInput | string
    personalPetVaccine?: PersonalPetVaccineUncheckedUpdateManyWithoutClientPetNestedInput
    metting?: MettingUncheckedUpdateManyWithoutClientPetNestedInput
  }

  export type ClientProfileCreateWithoutUserInput = {
    id?: string
    dateOfBirth: Date | string
    address?: string | null
    phone?: string | null
    secretaryProfile?: SecretaryProfileCreateNestedOneWithoutClinicInput
    veterinarianProfile?: VeterinarianProfileCreateNestedOneWithoutClinicInput
    clientPet?: ClientPetCreateNestedManyWithoutClientInput
    clinicProducts?: ClinicProductCreateNestedManyWithoutClinicInput
  }

  export type ClientProfileUncheckedCreateWithoutUserInput = {
    id?: string
    dateOfBirth: Date | string
    address?: string | null
    phone?: string | null
    secretaryProfile?: SecretaryProfileUncheckedCreateNestedOneWithoutClinicInput
    veterinarianProfile?: VeterinarianProfileUncheckedCreateNestedOneWithoutClinicInput
    clientPet?: ClientPetUncheckedCreateNestedManyWithoutClientInput
    clinicProducts?: ClinicProductUncheckedCreateNestedManyWithoutClinicInput
  }

  export type ClientProfileCreateOrConnectWithoutUserInput = {
    where: ClientProfileWhereUniqueInput
    create: XOR<ClientProfileCreateWithoutUserInput, ClientProfileUncheckedCreateWithoutUserInput>
  }

  export type VeterinarianProfileCreateWithoutUserInput = {
    id?: string
    licenseNumber: string
    specialty: string
    yearsExperience: number
    bio?: string | null
    clinic: ClientProfileCreateNestedOneWithoutVeterinarianProfileInput
    clinicProfiles?: ClinicProfileCreateNestedManyWithoutVeterinarianProfileInput
    clientPet?: ClientPetCreateNestedManyWithoutAttendingVeterinarianInput
    metting?: MettingCreateNestedManyWithoutVeterinarianInput
  }

  export type VeterinarianProfileUncheckedCreateWithoutUserInput = {
    id?: string
    licenseNumber: string
    specialty: string
    yearsExperience: number
    bio?: string | null
    clinicId: string
    clinicProfiles?: ClinicProfileUncheckedCreateNestedManyWithoutVeterinarianProfileInput
    clientPet?: ClientPetUncheckedCreateNestedManyWithoutAttendingVeterinarianInput
    metting?: MettingUncheckedCreateNestedManyWithoutVeterinarianInput
  }

  export type VeterinarianProfileCreateOrConnectWithoutUserInput = {
    where: VeterinarianProfileWhereUniqueInput
    create: XOR<VeterinarianProfileCreateWithoutUserInput, VeterinarianProfileUncheckedCreateWithoutUserInput>
  }

  export type ClinicProfileCreateWithoutUserInput = {
    id?: string
    name: string
    address: string
    siret: string
    phone: string
    description?: string | null
    website: string
    veterinarianProfile?: VeterinarianProfileCreateNestedOneWithoutClinicProfilesInput
  }

  export type ClinicProfileUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    address: string
    siret: string
    phone: string
    description?: string | null
    website: string
    veterinarianProfileId?: string | null
  }

  export type ClinicProfileCreateOrConnectWithoutUserInput = {
    where: ClinicProfileWhereUniqueInput
    create: XOR<ClinicProfileCreateWithoutUserInput, ClinicProfileUncheckedCreateWithoutUserInput>
  }

  export type SecretaryProfileCreateWithoutUserInput = {
    id?: string
    clinic: ClientProfileCreateNestedOneWithoutSecretaryProfileInput
  }

  export type SecretaryProfileUncheckedCreateWithoutUserInput = {
    id?: string
    clinicId: string
  }

  export type SecretaryProfileCreateOrConnectWithoutUserInput = {
    where: SecretaryProfileWhereUniqueInput
    create: XOR<SecretaryProfileCreateWithoutUserInput, SecretaryProfileUncheckedCreateWithoutUserInput>
  }

  export type ClientProfileUpsertWithoutUserInput = {
    update: XOR<ClientProfileUpdateWithoutUserInput, ClientProfileUncheckedUpdateWithoutUserInput>
    create: XOR<ClientProfileCreateWithoutUserInput, ClientProfileUncheckedCreateWithoutUserInput>
    where?: ClientProfileWhereInput
  }

  export type ClientProfileUpdateToOneWithWhereWithoutUserInput = {
    where?: ClientProfileWhereInput
    data: XOR<ClientProfileUpdateWithoutUserInput, ClientProfileUncheckedUpdateWithoutUserInput>
  }

  export type ClientProfileUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    secretaryProfile?: SecretaryProfileUpdateOneWithoutClinicNestedInput
    veterinarianProfile?: VeterinarianProfileUpdateOneWithoutClinicNestedInput
    clientPet?: ClientPetUpdateManyWithoutClientNestedInput
    clinicProducts?: ClinicProductUpdateManyWithoutClinicNestedInput
  }

  export type ClientProfileUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    secretaryProfile?: SecretaryProfileUncheckedUpdateOneWithoutClinicNestedInput
    veterinarianProfile?: VeterinarianProfileUncheckedUpdateOneWithoutClinicNestedInput
    clientPet?: ClientPetUncheckedUpdateManyWithoutClientNestedInput
    clinicProducts?: ClinicProductUncheckedUpdateManyWithoutClinicNestedInput
  }

  export type VeterinarianProfileUpsertWithoutUserInput = {
    update: XOR<VeterinarianProfileUpdateWithoutUserInput, VeterinarianProfileUncheckedUpdateWithoutUserInput>
    create: XOR<VeterinarianProfileCreateWithoutUserInput, VeterinarianProfileUncheckedCreateWithoutUserInput>
    where?: VeterinarianProfileWhereInput
  }

  export type VeterinarianProfileUpdateToOneWithWhereWithoutUserInput = {
    where?: VeterinarianProfileWhereInput
    data: XOR<VeterinarianProfileUpdateWithoutUserInput, VeterinarianProfileUncheckedUpdateWithoutUserInput>
  }

  export type VeterinarianProfileUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    licenseNumber?: StringFieldUpdateOperationsInput | string
    specialty?: StringFieldUpdateOperationsInput | string
    yearsExperience?: IntFieldUpdateOperationsInput | number
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    clinic?: ClientProfileUpdateOneRequiredWithoutVeterinarianProfileNestedInput
    clinicProfiles?: ClinicProfileUpdateManyWithoutVeterinarianProfileNestedInput
    clientPet?: ClientPetUpdateManyWithoutAttendingVeterinarianNestedInput
    metting?: MettingUpdateManyWithoutVeterinarianNestedInput
  }

  export type VeterinarianProfileUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    licenseNumber?: StringFieldUpdateOperationsInput | string
    specialty?: StringFieldUpdateOperationsInput | string
    yearsExperience?: IntFieldUpdateOperationsInput | number
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    clinicId?: StringFieldUpdateOperationsInput | string
    clinicProfiles?: ClinicProfileUncheckedUpdateManyWithoutVeterinarianProfileNestedInput
    clientPet?: ClientPetUncheckedUpdateManyWithoutAttendingVeterinarianNestedInput
    metting?: MettingUncheckedUpdateManyWithoutVeterinarianNestedInput
  }

  export type ClinicProfileUpsertWithoutUserInput = {
    update: XOR<ClinicProfileUpdateWithoutUserInput, ClinicProfileUncheckedUpdateWithoutUserInput>
    create: XOR<ClinicProfileCreateWithoutUserInput, ClinicProfileUncheckedCreateWithoutUserInput>
    where?: ClinicProfileWhereInput
  }

  export type ClinicProfileUpdateToOneWithWhereWithoutUserInput = {
    where?: ClinicProfileWhereInput
    data: XOR<ClinicProfileUpdateWithoutUserInput, ClinicProfileUncheckedUpdateWithoutUserInput>
  }

  export type ClinicProfileUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    siret?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: StringFieldUpdateOperationsInput | string
    veterinarianProfile?: VeterinarianProfileUpdateOneWithoutClinicProfilesNestedInput
  }

  export type ClinicProfileUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    siret?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: StringFieldUpdateOperationsInput | string
    veterinarianProfileId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SecretaryProfileUpsertWithoutUserInput = {
    update: XOR<SecretaryProfileUpdateWithoutUserInput, SecretaryProfileUncheckedUpdateWithoutUserInput>
    create: XOR<SecretaryProfileCreateWithoutUserInput, SecretaryProfileUncheckedCreateWithoutUserInput>
    where?: SecretaryProfileWhereInput
  }

  export type SecretaryProfileUpdateToOneWithWhereWithoutUserInput = {
    where?: SecretaryProfileWhereInput
    data: XOR<SecretaryProfileUpdateWithoutUserInput, SecretaryProfileUncheckedUpdateWithoutUserInput>
  }

  export type SecretaryProfileUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinic?: ClientProfileUpdateOneRequiredWithoutSecretaryProfileNestedInput
  }

  export type SecretaryProfileUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: StringFieldUpdateOperationsInput | string
  }

  export type UserCreateWithoutClientProfileInput = {
    id?: string
    email: string
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    firstname: string
    lastname: string
    password: string
    picture?: string | null
    veterinarianProfile?: VeterinarianProfileCreateNestedOneWithoutUserInput
    clinicProfile?: ClinicProfileCreateNestedOneWithoutUserInput
    secretaryProfile?: SecretaryProfileCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutClientProfileInput = {
    id?: string
    email: string
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    firstname: string
    lastname: string
    password: string
    picture?: string | null
    veterinarianProfile?: VeterinarianProfileUncheckedCreateNestedOneWithoutUserInput
    clinicProfile?: ClinicProfileUncheckedCreateNestedOneWithoutUserInput
    secretaryProfile?: SecretaryProfileUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutClientProfileInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutClientProfileInput, UserUncheckedCreateWithoutClientProfileInput>
  }

  export type SecretaryProfileCreateWithoutClinicInput = {
    id?: string
    user: UserCreateNestedOneWithoutSecretaryProfileInput
  }

  export type SecretaryProfileUncheckedCreateWithoutClinicInput = {
    id?: string
    userId: string
  }

  export type SecretaryProfileCreateOrConnectWithoutClinicInput = {
    where: SecretaryProfileWhereUniqueInput
    create: XOR<SecretaryProfileCreateWithoutClinicInput, SecretaryProfileUncheckedCreateWithoutClinicInput>
  }

  export type VeterinarianProfileCreateWithoutClinicInput = {
    id?: string
    licenseNumber: string
    specialty: string
    yearsExperience: number
    bio?: string | null
    user: UserCreateNestedOneWithoutVeterinarianProfileInput
    clinicProfiles?: ClinicProfileCreateNestedManyWithoutVeterinarianProfileInput
    clientPet?: ClientPetCreateNestedManyWithoutAttendingVeterinarianInput
    metting?: MettingCreateNestedManyWithoutVeterinarianInput
  }

  export type VeterinarianProfileUncheckedCreateWithoutClinicInput = {
    id?: string
    licenseNumber: string
    specialty: string
    yearsExperience: number
    bio?: string | null
    userId: string
    clinicProfiles?: ClinicProfileUncheckedCreateNestedManyWithoutVeterinarianProfileInput
    clientPet?: ClientPetUncheckedCreateNestedManyWithoutAttendingVeterinarianInput
    metting?: MettingUncheckedCreateNestedManyWithoutVeterinarianInput
  }

  export type VeterinarianProfileCreateOrConnectWithoutClinicInput = {
    where: VeterinarianProfileWhereUniqueInput
    create: XOR<VeterinarianProfileCreateWithoutClinicInput, VeterinarianProfileUncheckedCreateWithoutClinicInput>
  }

  export type ClientPetCreateWithoutClientInput = {
    id?: string
    name: string
    dateOfBirth: Date | string
    description?: string | null
    activity?: number | null
    attendingVeterinarian?: VeterinarianProfileCreateNestedOneWithoutClientPetInput
    race: RaceCreateNestedOneWithoutClientPetInput
    personalPetVaccine?: PersonalPetVaccineCreateNestedManyWithoutClientPetInput
    metting?: MettingCreateNestedManyWithoutClientPetInput
    foodPets?: FoodPetCreateNestedManyWithoutClientPetInput
  }

  export type ClientPetUncheckedCreateWithoutClientInput = {
    id?: string
    name: string
    dateOfBirth: Date | string
    description?: string | null
    activity?: number | null
    attendingVeterinarianId?: string | null
    raceId: string
    personalPetVaccine?: PersonalPetVaccineUncheckedCreateNestedManyWithoutClientPetInput
    metting?: MettingUncheckedCreateNestedManyWithoutClientPetInput
    foodPets?: FoodPetUncheckedCreateNestedManyWithoutClientPetInput
  }

  export type ClientPetCreateOrConnectWithoutClientInput = {
    where: ClientPetWhereUniqueInput
    create: XOR<ClientPetCreateWithoutClientInput, ClientPetUncheckedCreateWithoutClientInput>
  }

  export type ClientPetCreateManyClientInputEnvelope = {
    data: ClientPetCreateManyClientInput | ClientPetCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type ClinicProductCreateWithoutClinicInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    stock?: number
    minimumRequired: number
    product: ProductCreateNestedOneWithoutClinicProductsInput
  }

  export type ClinicProductUncheckedCreateWithoutClinicInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    stock?: number
    minimumRequired: number
    productId: string
  }

  export type ClinicProductCreateOrConnectWithoutClinicInput = {
    where: ClinicProductWhereUniqueInput
    create: XOR<ClinicProductCreateWithoutClinicInput, ClinicProductUncheckedCreateWithoutClinicInput>
  }

  export type ClinicProductCreateManyClinicInputEnvelope = {
    data: ClinicProductCreateManyClinicInput | ClinicProductCreateManyClinicInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutClientProfileInput = {
    update: XOR<UserUpdateWithoutClientProfileInput, UserUncheckedUpdateWithoutClientProfileInput>
    create: XOR<UserCreateWithoutClientProfileInput, UserUncheckedCreateWithoutClientProfileInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutClientProfileInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutClientProfileInput, UserUncheckedUpdateWithoutClientProfileInput>
  }

  export type UserUpdateWithoutClientProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    veterinarianProfile?: VeterinarianProfileUpdateOneWithoutUserNestedInput
    clinicProfile?: ClinicProfileUpdateOneWithoutUserNestedInput
    secretaryProfile?: SecretaryProfileUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutClientProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    veterinarianProfile?: VeterinarianProfileUncheckedUpdateOneWithoutUserNestedInput
    clinicProfile?: ClinicProfileUncheckedUpdateOneWithoutUserNestedInput
    secretaryProfile?: SecretaryProfileUncheckedUpdateOneWithoutUserNestedInput
  }

  export type SecretaryProfileUpsertWithoutClinicInput = {
    update: XOR<SecretaryProfileUpdateWithoutClinicInput, SecretaryProfileUncheckedUpdateWithoutClinicInput>
    create: XOR<SecretaryProfileCreateWithoutClinicInput, SecretaryProfileUncheckedCreateWithoutClinicInput>
    where?: SecretaryProfileWhereInput
  }

  export type SecretaryProfileUpdateToOneWithWhereWithoutClinicInput = {
    where?: SecretaryProfileWhereInput
    data: XOR<SecretaryProfileUpdateWithoutClinicInput, SecretaryProfileUncheckedUpdateWithoutClinicInput>
  }

  export type SecretaryProfileUpdateWithoutClinicInput = {
    id?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutSecretaryProfileNestedInput
  }

  export type SecretaryProfileUncheckedUpdateWithoutClinicInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type VeterinarianProfileUpsertWithoutClinicInput = {
    update: XOR<VeterinarianProfileUpdateWithoutClinicInput, VeterinarianProfileUncheckedUpdateWithoutClinicInput>
    create: XOR<VeterinarianProfileCreateWithoutClinicInput, VeterinarianProfileUncheckedCreateWithoutClinicInput>
    where?: VeterinarianProfileWhereInput
  }

  export type VeterinarianProfileUpdateToOneWithWhereWithoutClinicInput = {
    where?: VeterinarianProfileWhereInput
    data: XOR<VeterinarianProfileUpdateWithoutClinicInput, VeterinarianProfileUncheckedUpdateWithoutClinicInput>
  }

  export type VeterinarianProfileUpdateWithoutClinicInput = {
    id?: StringFieldUpdateOperationsInput | string
    licenseNumber?: StringFieldUpdateOperationsInput | string
    specialty?: StringFieldUpdateOperationsInput | string
    yearsExperience?: IntFieldUpdateOperationsInput | number
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutVeterinarianProfileNestedInput
    clinicProfiles?: ClinicProfileUpdateManyWithoutVeterinarianProfileNestedInput
    clientPet?: ClientPetUpdateManyWithoutAttendingVeterinarianNestedInput
    metting?: MettingUpdateManyWithoutVeterinarianNestedInput
  }

  export type VeterinarianProfileUncheckedUpdateWithoutClinicInput = {
    id?: StringFieldUpdateOperationsInput | string
    licenseNumber?: StringFieldUpdateOperationsInput | string
    specialty?: StringFieldUpdateOperationsInput | string
    yearsExperience?: IntFieldUpdateOperationsInput | number
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    clinicProfiles?: ClinicProfileUncheckedUpdateManyWithoutVeterinarianProfileNestedInput
    clientPet?: ClientPetUncheckedUpdateManyWithoutAttendingVeterinarianNestedInput
    metting?: MettingUncheckedUpdateManyWithoutVeterinarianNestedInput
  }

  export type ClientPetUpsertWithWhereUniqueWithoutClientInput = {
    where: ClientPetWhereUniqueInput
    update: XOR<ClientPetUpdateWithoutClientInput, ClientPetUncheckedUpdateWithoutClientInput>
    create: XOR<ClientPetCreateWithoutClientInput, ClientPetUncheckedCreateWithoutClientInput>
  }

  export type ClientPetUpdateWithWhereUniqueWithoutClientInput = {
    where: ClientPetWhereUniqueInput
    data: XOR<ClientPetUpdateWithoutClientInput, ClientPetUncheckedUpdateWithoutClientInput>
  }

  export type ClientPetUpdateManyWithWhereWithoutClientInput = {
    where: ClientPetScalarWhereInput
    data: XOR<ClientPetUpdateManyMutationInput, ClientPetUncheckedUpdateManyWithoutClientInput>
  }

  export type ClinicProductUpsertWithWhereUniqueWithoutClinicInput = {
    where: ClinicProductWhereUniqueInput
    update: XOR<ClinicProductUpdateWithoutClinicInput, ClinicProductUncheckedUpdateWithoutClinicInput>
    create: XOR<ClinicProductCreateWithoutClinicInput, ClinicProductUncheckedCreateWithoutClinicInput>
  }

  export type ClinicProductUpdateWithWhereUniqueWithoutClinicInput = {
    where: ClinicProductWhereUniqueInput
    data: XOR<ClinicProductUpdateWithoutClinicInput, ClinicProductUncheckedUpdateWithoutClinicInput>
  }

  export type ClinicProductUpdateManyWithWhereWithoutClinicInput = {
    where: ClinicProductScalarWhereInput
    data: XOR<ClinicProductUpdateManyMutationInput, ClinicProductUncheckedUpdateManyWithoutClinicInput>
  }

  export type ClientProfileCreateWithoutVeterinarianProfileInput = {
    id?: string
    dateOfBirth: Date | string
    address?: string | null
    phone?: string | null
    user: UserCreateNestedOneWithoutClientProfileInput
    secretaryProfile?: SecretaryProfileCreateNestedOneWithoutClinicInput
    clientPet?: ClientPetCreateNestedManyWithoutClientInput
    clinicProducts?: ClinicProductCreateNestedManyWithoutClinicInput
  }

  export type ClientProfileUncheckedCreateWithoutVeterinarianProfileInput = {
    id?: string
    dateOfBirth: Date | string
    address?: string | null
    phone?: string | null
    userId: string
    secretaryProfile?: SecretaryProfileUncheckedCreateNestedOneWithoutClinicInput
    clientPet?: ClientPetUncheckedCreateNestedManyWithoutClientInput
    clinicProducts?: ClinicProductUncheckedCreateNestedManyWithoutClinicInput
  }

  export type ClientProfileCreateOrConnectWithoutVeterinarianProfileInput = {
    where: ClientProfileWhereUniqueInput
    create: XOR<ClientProfileCreateWithoutVeterinarianProfileInput, ClientProfileUncheckedCreateWithoutVeterinarianProfileInput>
  }

  export type UserCreateWithoutVeterinarianProfileInput = {
    id?: string
    email: string
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    firstname: string
    lastname: string
    password: string
    picture?: string | null
    clientProfile?: ClientProfileCreateNestedOneWithoutUserInput
    clinicProfile?: ClinicProfileCreateNestedOneWithoutUserInput
    secretaryProfile?: SecretaryProfileCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutVeterinarianProfileInput = {
    id?: string
    email: string
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    firstname: string
    lastname: string
    password: string
    picture?: string | null
    clientProfile?: ClientProfileUncheckedCreateNestedOneWithoutUserInput
    clinicProfile?: ClinicProfileUncheckedCreateNestedOneWithoutUserInput
    secretaryProfile?: SecretaryProfileUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutVeterinarianProfileInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutVeterinarianProfileInput, UserUncheckedCreateWithoutVeterinarianProfileInput>
  }

  export type ClinicProfileCreateWithoutVeterinarianProfileInput = {
    id?: string
    name: string
    address: string
    siret: string
    phone: string
    description?: string | null
    website: string
    user: UserCreateNestedOneWithoutClinicProfileInput
  }

  export type ClinicProfileUncheckedCreateWithoutVeterinarianProfileInput = {
    id?: string
    name: string
    address: string
    siret: string
    phone: string
    description?: string | null
    website: string
    userId: string
  }

  export type ClinicProfileCreateOrConnectWithoutVeterinarianProfileInput = {
    where: ClinicProfileWhereUniqueInput
    create: XOR<ClinicProfileCreateWithoutVeterinarianProfileInput, ClinicProfileUncheckedCreateWithoutVeterinarianProfileInput>
  }

  export type ClinicProfileCreateManyVeterinarianProfileInputEnvelope = {
    data: ClinicProfileCreateManyVeterinarianProfileInput | ClinicProfileCreateManyVeterinarianProfileInput[]
    skipDuplicates?: boolean
  }

  export type ClientPetCreateWithoutAttendingVeterinarianInput = {
    id?: string
    name: string
    dateOfBirth: Date | string
    description?: string | null
    activity?: number | null
    client: ClientProfileCreateNestedOneWithoutClientPetInput
    race: RaceCreateNestedOneWithoutClientPetInput
    personalPetVaccine?: PersonalPetVaccineCreateNestedManyWithoutClientPetInput
    metting?: MettingCreateNestedManyWithoutClientPetInput
    foodPets?: FoodPetCreateNestedManyWithoutClientPetInput
  }

  export type ClientPetUncheckedCreateWithoutAttendingVeterinarianInput = {
    id?: string
    name: string
    dateOfBirth: Date | string
    description?: string | null
    activity?: number | null
    clientId: string
    raceId: string
    personalPetVaccine?: PersonalPetVaccineUncheckedCreateNestedManyWithoutClientPetInput
    metting?: MettingUncheckedCreateNestedManyWithoutClientPetInput
    foodPets?: FoodPetUncheckedCreateNestedManyWithoutClientPetInput
  }

  export type ClientPetCreateOrConnectWithoutAttendingVeterinarianInput = {
    where: ClientPetWhereUniqueInput
    create: XOR<ClientPetCreateWithoutAttendingVeterinarianInput, ClientPetUncheckedCreateWithoutAttendingVeterinarianInput>
  }

  export type ClientPetCreateManyAttendingVeterinarianInputEnvelope = {
    data: ClientPetCreateManyAttendingVeterinarianInput | ClientPetCreateManyAttendingVeterinarianInput[]
    skipDuplicates?: boolean
  }

  export type MettingCreateWithoutVeterinarianInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    date: Date | string
    duration: Decimal | DecimalJsLike | number | string
    description?: string | null
    petWeight?: number | null
    petSize?: number | null
    clientPet: ClientPetCreateNestedOneWithoutMettingInput
    personalPetVaccine?: PersonalPetVaccineCreateNestedManyWithoutMettingInput
  }

  export type MettingUncheckedCreateWithoutVeterinarianInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    date: Date | string
    duration: Decimal | DecimalJsLike | number | string
    description?: string | null
    petWeight?: number | null
    petSize?: number | null
    clientPetId: string
    personalPetVaccine?: PersonalPetVaccineUncheckedCreateNestedManyWithoutMettingInput
  }

  export type MettingCreateOrConnectWithoutVeterinarianInput = {
    where: MettingWhereUniqueInput
    create: XOR<MettingCreateWithoutVeterinarianInput, MettingUncheckedCreateWithoutVeterinarianInput>
  }

  export type MettingCreateManyVeterinarianInputEnvelope = {
    data: MettingCreateManyVeterinarianInput | MettingCreateManyVeterinarianInput[]
    skipDuplicates?: boolean
  }

  export type ClientProfileUpsertWithoutVeterinarianProfileInput = {
    update: XOR<ClientProfileUpdateWithoutVeterinarianProfileInput, ClientProfileUncheckedUpdateWithoutVeterinarianProfileInput>
    create: XOR<ClientProfileCreateWithoutVeterinarianProfileInput, ClientProfileUncheckedCreateWithoutVeterinarianProfileInput>
    where?: ClientProfileWhereInput
  }

  export type ClientProfileUpdateToOneWithWhereWithoutVeterinarianProfileInput = {
    where?: ClientProfileWhereInput
    data: XOR<ClientProfileUpdateWithoutVeterinarianProfileInput, ClientProfileUncheckedUpdateWithoutVeterinarianProfileInput>
  }

  export type ClientProfileUpdateWithoutVeterinarianProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutClientProfileNestedInput
    secretaryProfile?: SecretaryProfileUpdateOneWithoutClinicNestedInput
    clientPet?: ClientPetUpdateManyWithoutClientNestedInput
    clinicProducts?: ClinicProductUpdateManyWithoutClinicNestedInput
  }

  export type ClientProfileUncheckedUpdateWithoutVeterinarianProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    secretaryProfile?: SecretaryProfileUncheckedUpdateOneWithoutClinicNestedInput
    clientPet?: ClientPetUncheckedUpdateManyWithoutClientNestedInput
    clinicProducts?: ClinicProductUncheckedUpdateManyWithoutClinicNestedInput
  }

  export type UserUpsertWithoutVeterinarianProfileInput = {
    update: XOR<UserUpdateWithoutVeterinarianProfileInput, UserUncheckedUpdateWithoutVeterinarianProfileInput>
    create: XOR<UserCreateWithoutVeterinarianProfileInput, UserUncheckedCreateWithoutVeterinarianProfileInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutVeterinarianProfileInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutVeterinarianProfileInput, UserUncheckedUpdateWithoutVeterinarianProfileInput>
  }

  export type UserUpdateWithoutVeterinarianProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    clientProfile?: ClientProfileUpdateOneWithoutUserNestedInput
    clinicProfile?: ClinicProfileUpdateOneWithoutUserNestedInput
    secretaryProfile?: SecretaryProfileUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutVeterinarianProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    clientProfile?: ClientProfileUncheckedUpdateOneWithoutUserNestedInput
    clinicProfile?: ClinicProfileUncheckedUpdateOneWithoutUserNestedInput
    secretaryProfile?: SecretaryProfileUncheckedUpdateOneWithoutUserNestedInput
  }

  export type ClinicProfileUpsertWithWhereUniqueWithoutVeterinarianProfileInput = {
    where: ClinicProfileWhereUniqueInput
    update: XOR<ClinicProfileUpdateWithoutVeterinarianProfileInput, ClinicProfileUncheckedUpdateWithoutVeterinarianProfileInput>
    create: XOR<ClinicProfileCreateWithoutVeterinarianProfileInput, ClinicProfileUncheckedCreateWithoutVeterinarianProfileInput>
  }

  export type ClinicProfileUpdateWithWhereUniqueWithoutVeterinarianProfileInput = {
    where: ClinicProfileWhereUniqueInput
    data: XOR<ClinicProfileUpdateWithoutVeterinarianProfileInput, ClinicProfileUncheckedUpdateWithoutVeterinarianProfileInput>
  }

  export type ClinicProfileUpdateManyWithWhereWithoutVeterinarianProfileInput = {
    where: ClinicProfileScalarWhereInput
    data: XOR<ClinicProfileUpdateManyMutationInput, ClinicProfileUncheckedUpdateManyWithoutVeterinarianProfileInput>
  }

  export type ClinicProfileScalarWhereInput = {
    AND?: ClinicProfileScalarWhereInput | ClinicProfileScalarWhereInput[]
    OR?: ClinicProfileScalarWhereInput[]
    NOT?: ClinicProfileScalarWhereInput | ClinicProfileScalarWhereInput[]
    id?: StringFilter<"ClinicProfile"> | string
    name?: StringFilter<"ClinicProfile"> | string
    address?: StringFilter<"ClinicProfile"> | string
    siret?: StringFilter<"ClinicProfile"> | string
    phone?: StringFilter<"ClinicProfile"> | string
    description?: StringNullableFilter<"ClinicProfile"> | string | null
    website?: StringFilter<"ClinicProfile"> | string
    userId?: StringFilter<"ClinicProfile"> | string
    veterinarianProfileId?: StringNullableFilter<"ClinicProfile"> | string | null
  }

  export type ClientPetUpsertWithWhereUniqueWithoutAttendingVeterinarianInput = {
    where: ClientPetWhereUniqueInput
    update: XOR<ClientPetUpdateWithoutAttendingVeterinarianInput, ClientPetUncheckedUpdateWithoutAttendingVeterinarianInput>
    create: XOR<ClientPetCreateWithoutAttendingVeterinarianInput, ClientPetUncheckedCreateWithoutAttendingVeterinarianInput>
  }

  export type ClientPetUpdateWithWhereUniqueWithoutAttendingVeterinarianInput = {
    where: ClientPetWhereUniqueInput
    data: XOR<ClientPetUpdateWithoutAttendingVeterinarianInput, ClientPetUncheckedUpdateWithoutAttendingVeterinarianInput>
  }

  export type ClientPetUpdateManyWithWhereWithoutAttendingVeterinarianInput = {
    where: ClientPetScalarWhereInput
    data: XOR<ClientPetUpdateManyMutationInput, ClientPetUncheckedUpdateManyWithoutAttendingVeterinarianInput>
  }

  export type MettingUpsertWithWhereUniqueWithoutVeterinarianInput = {
    where: MettingWhereUniqueInput
    update: XOR<MettingUpdateWithoutVeterinarianInput, MettingUncheckedUpdateWithoutVeterinarianInput>
    create: XOR<MettingCreateWithoutVeterinarianInput, MettingUncheckedCreateWithoutVeterinarianInput>
  }

  export type MettingUpdateWithWhereUniqueWithoutVeterinarianInput = {
    where: MettingWhereUniqueInput
    data: XOR<MettingUpdateWithoutVeterinarianInput, MettingUncheckedUpdateWithoutVeterinarianInput>
  }

  export type MettingUpdateManyWithWhereWithoutVeterinarianInput = {
    where: MettingScalarWhereInput
    data: XOR<MettingUpdateManyMutationInput, MettingUncheckedUpdateManyWithoutVeterinarianInput>
  }

  export type UserCreateWithoutClinicProfileInput = {
    id?: string
    email: string
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    firstname: string
    lastname: string
    password: string
    picture?: string | null
    clientProfile?: ClientProfileCreateNestedOneWithoutUserInput
    veterinarianProfile?: VeterinarianProfileCreateNestedOneWithoutUserInput
    secretaryProfile?: SecretaryProfileCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutClinicProfileInput = {
    id?: string
    email: string
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    firstname: string
    lastname: string
    password: string
    picture?: string | null
    clientProfile?: ClientProfileUncheckedCreateNestedOneWithoutUserInput
    veterinarianProfile?: VeterinarianProfileUncheckedCreateNestedOneWithoutUserInput
    secretaryProfile?: SecretaryProfileUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutClinicProfileInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutClinicProfileInput, UserUncheckedCreateWithoutClinicProfileInput>
  }

  export type VeterinarianProfileCreateWithoutClinicProfilesInput = {
    id?: string
    licenseNumber: string
    specialty: string
    yearsExperience: number
    bio?: string | null
    clinic: ClientProfileCreateNestedOneWithoutVeterinarianProfileInput
    user: UserCreateNestedOneWithoutVeterinarianProfileInput
    clientPet?: ClientPetCreateNestedManyWithoutAttendingVeterinarianInput
    metting?: MettingCreateNestedManyWithoutVeterinarianInput
  }

  export type VeterinarianProfileUncheckedCreateWithoutClinicProfilesInput = {
    id?: string
    licenseNumber: string
    specialty: string
    yearsExperience: number
    bio?: string | null
    clinicId: string
    userId: string
    clientPet?: ClientPetUncheckedCreateNestedManyWithoutAttendingVeterinarianInput
    metting?: MettingUncheckedCreateNestedManyWithoutVeterinarianInput
  }

  export type VeterinarianProfileCreateOrConnectWithoutClinicProfilesInput = {
    where: VeterinarianProfileWhereUniqueInput
    create: XOR<VeterinarianProfileCreateWithoutClinicProfilesInput, VeterinarianProfileUncheckedCreateWithoutClinicProfilesInput>
  }

  export type UserUpsertWithoutClinicProfileInput = {
    update: XOR<UserUpdateWithoutClinicProfileInput, UserUncheckedUpdateWithoutClinicProfileInput>
    create: XOR<UserCreateWithoutClinicProfileInput, UserUncheckedCreateWithoutClinicProfileInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutClinicProfileInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutClinicProfileInput, UserUncheckedUpdateWithoutClinicProfileInput>
  }

  export type UserUpdateWithoutClinicProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    clientProfile?: ClientProfileUpdateOneWithoutUserNestedInput
    veterinarianProfile?: VeterinarianProfileUpdateOneWithoutUserNestedInput
    secretaryProfile?: SecretaryProfileUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutClinicProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    clientProfile?: ClientProfileUncheckedUpdateOneWithoutUserNestedInput
    veterinarianProfile?: VeterinarianProfileUncheckedUpdateOneWithoutUserNestedInput
    secretaryProfile?: SecretaryProfileUncheckedUpdateOneWithoutUserNestedInput
  }

  export type VeterinarianProfileUpsertWithoutClinicProfilesInput = {
    update: XOR<VeterinarianProfileUpdateWithoutClinicProfilesInput, VeterinarianProfileUncheckedUpdateWithoutClinicProfilesInput>
    create: XOR<VeterinarianProfileCreateWithoutClinicProfilesInput, VeterinarianProfileUncheckedCreateWithoutClinicProfilesInput>
    where?: VeterinarianProfileWhereInput
  }

  export type VeterinarianProfileUpdateToOneWithWhereWithoutClinicProfilesInput = {
    where?: VeterinarianProfileWhereInput
    data: XOR<VeterinarianProfileUpdateWithoutClinicProfilesInput, VeterinarianProfileUncheckedUpdateWithoutClinicProfilesInput>
  }

  export type VeterinarianProfileUpdateWithoutClinicProfilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    licenseNumber?: StringFieldUpdateOperationsInput | string
    specialty?: StringFieldUpdateOperationsInput | string
    yearsExperience?: IntFieldUpdateOperationsInput | number
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    clinic?: ClientProfileUpdateOneRequiredWithoutVeterinarianProfileNestedInput
    user?: UserUpdateOneRequiredWithoutVeterinarianProfileNestedInput
    clientPet?: ClientPetUpdateManyWithoutAttendingVeterinarianNestedInput
    metting?: MettingUpdateManyWithoutVeterinarianNestedInput
  }

  export type VeterinarianProfileUncheckedUpdateWithoutClinicProfilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    licenseNumber?: StringFieldUpdateOperationsInput | string
    specialty?: StringFieldUpdateOperationsInput | string
    yearsExperience?: IntFieldUpdateOperationsInput | number
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    clinicId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    clientPet?: ClientPetUncheckedUpdateManyWithoutAttendingVeterinarianNestedInput
    metting?: MettingUncheckedUpdateManyWithoutVeterinarianNestedInput
  }

  export type UserCreateWithoutSecretaryProfileInput = {
    id?: string
    email: string
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    firstname: string
    lastname: string
    password: string
    picture?: string | null
    clientProfile?: ClientProfileCreateNestedOneWithoutUserInput
    veterinarianProfile?: VeterinarianProfileCreateNestedOneWithoutUserInput
    clinicProfile?: ClinicProfileCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSecretaryProfileInput = {
    id?: string
    email: string
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    firstname: string
    lastname: string
    password: string
    picture?: string | null
    clientProfile?: ClientProfileUncheckedCreateNestedOneWithoutUserInput
    veterinarianProfile?: VeterinarianProfileUncheckedCreateNestedOneWithoutUserInput
    clinicProfile?: ClinicProfileUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSecretaryProfileInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSecretaryProfileInput, UserUncheckedCreateWithoutSecretaryProfileInput>
  }

  export type ClientProfileCreateWithoutSecretaryProfileInput = {
    id?: string
    dateOfBirth: Date | string
    address?: string | null
    phone?: string | null
    user: UserCreateNestedOneWithoutClientProfileInput
    veterinarianProfile?: VeterinarianProfileCreateNestedOneWithoutClinicInput
    clientPet?: ClientPetCreateNestedManyWithoutClientInput
    clinicProducts?: ClinicProductCreateNestedManyWithoutClinicInput
  }

  export type ClientProfileUncheckedCreateWithoutSecretaryProfileInput = {
    id?: string
    dateOfBirth: Date | string
    address?: string | null
    phone?: string | null
    userId: string
    veterinarianProfile?: VeterinarianProfileUncheckedCreateNestedOneWithoutClinicInput
    clientPet?: ClientPetUncheckedCreateNestedManyWithoutClientInput
    clinicProducts?: ClinicProductUncheckedCreateNestedManyWithoutClinicInput
  }

  export type ClientProfileCreateOrConnectWithoutSecretaryProfileInput = {
    where: ClientProfileWhereUniqueInput
    create: XOR<ClientProfileCreateWithoutSecretaryProfileInput, ClientProfileUncheckedCreateWithoutSecretaryProfileInput>
  }

  export type UserUpsertWithoutSecretaryProfileInput = {
    update: XOR<UserUpdateWithoutSecretaryProfileInput, UserUncheckedUpdateWithoutSecretaryProfileInput>
    create: XOR<UserCreateWithoutSecretaryProfileInput, UserUncheckedCreateWithoutSecretaryProfileInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSecretaryProfileInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSecretaryProfileInput, UserUncheckedUpdateWithoutSecretaryProfileInput>
  }

  export type UserUpdateWithoutSecretaryProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    clientProfile?: ClientProfileUpdateOneWithoutUserNestedInput
    veterinarianProfile?: VeterinarianProfileUpdateOneWithoutUserNestedInput
    clinicProfile?: ClinicProfileUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSecretaryProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    clientProfile?: ClientProfileUncheckedUpdateOneWithoutUserNestedInput
    veterinarianProfile?: VeterinarianProfileUncheckedUpdateOneWithoutUserNestedInput
    clinicProfile?: ClinicProfileUncheckedUpdateOneWithoutUserNestedInput
  }

  export type ClientProfileUpsertWithoutSecretaryProfileInput = {
    update: XOR<ClientProfileUpdateWithoutSecretaryProfileInput, ClientProfileUncheckedUpdateWithoutSecretaryProfileInput>
    create: XOR<ClientProfileCreateWithoutSecretaryProfileInput, ClientProfileUncheckedCreateWithoutSecretaryProfileInput>
    where?: ClientProfileWhereInput
  }

  export type ClientProfileUpdateToOneWithWhereWithoutSecretaryProfileInput = {
    where?: ClientProfileWhereInput
    data: XOR<ClientProfileUpdateWithoutSecretaryProfileInput, ClientProfileUncheckedUpdateWithoutSecretaryProfileInput>
  }

  export type ClientProfileUpdateWithoutSecretaryProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutClientProfileNestedInput
    veterinarianProfile?: VeterinarianProfileUpdateOneWithoutClinicNestedInput
    clientPet?: ClientPetUpdateManyWithoutClientNestedInput
    clinicProducts?: ClinicProductUpdateManyWithoutClinicNestedInput
  }

  export type ClientProfileUncheckedUpdateWithoutSecretaryProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    veterinarianProfile?: VeterinarianProfileUncheckedUpdateOneWithoutClinicNestedInput
    clientPet?: ClientPetUncheckedUpdateManyWithoutClientNestedInput
    clinicProducts?: ClinicProductUncheckedUpdateManyWithoutClinicNestedInput
  }

  export type PersonalPetVaccineCreateManyClientPetInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    vaccineId: string
    mettingId?: string | null
  }

  export type MettingCreateManyClientPetInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    date: Date | string
    duration: Decimal | DecimalJsLike | number | string
    description?: string | null
    petWeight?: number | null
    petSize?: number | null
    veterinarianId: string
  }

  export type FoodPetCreateManyClientPetInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    type: $Enums.FoodPetDay
    dateStart: Date | string
    dateEnd?: Date | string | null
    quantity: Decimal | DecimalJsLike | number | string
    hours: Date | string
    foodId: string
  }

  export type PersonalPetVaccineUpdateWithoutClientPetInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vaccine?: VaccineUpdateOneRequiredWithoutPersonalPetVaccineNestedInput
    metting?: MettingUpdateOneWithoutPersonalPetVaccineNestedInput
  }

  export type PersonalPetVaccineUncheckedUpdateWithoutClientPetInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vaccineId?: StringFieldUpdateOperationsInput | string
    mettingId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PersonalPetVaccineUncheckedUpdateManyWithoutClientPetInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vaccineId?: StringFieldUpdateOperationsInput | string
    mettingId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MettingUpdateWithoutClientPetInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    petWeight?: NullableIntFieldUpdateOperationsInput | number | null
    petSize?: NullableIntFieldUpdateOperationsInput | number | null
    veterinarian?: VeterinarianProfileUpdateOneRequiredWithoutMettingNestedInput
    personalPetVaccine?: PersonalPetVaccineUpdateManyWithoutMettingNestedInput
  }

  export type MettingUncheckedUpdateWithoutClientPetInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    petWeight?: NullableIntFieldUpdateOperationsInput | number | null
    petSize?: NullableIntFieldUpdateOperationsInput | number | null
    veterinarianId?: StringFieldUpdateOperationsInput | string
    personalPetVaccine?: PersonalPetVaccineUncheckedUpdateManyWithoutMettingNestedInput
  }

  export type MettingUncheckedUpdateManyWithoutClientPetInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    petWeight?: NullableIntFieldUpdateOperationsInput | number | null
    petSize?: NullableIntFieldUpdateOperationsInput | number | null
    veterinarianId?: StringFieldUpdateOperationsInput | string
  }

  export type FoodPetUpdateWithoutClientPetInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumFoodPetDayFieldUpdateOperationsInput | $Enums.FoodPetDay
    dateStart?: DateTimeFieldUpdateOperationsInput | Date | string
    dateEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    hours?: DateTimeFieldUpdateOperationsInput | Date | string
    food?: FoodUpdateOneRequiredWithoutFoodPetsNestedInput
  }

  export type FoodPetUncheckedUpdateWithoutClientPetInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumFoodPetDayFieldUpdateOperationsInput | $Enums.FoodPetDay
    dateStart?: DateTimeFieldUpdateOperationsInput | Date | string
    dateEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    hours?: DateTimeFieldUpdateOperationsInput | Date | string
    foodId?: StringFieldUpdateOperationsInput | string
  }

  export type FoodPetUncheckedUpdateManyWithoutClientPetInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumFoodPetDayFieldUpdateOperationsInput | $Enums.FoodPetDay
    dateStart?: DateTimeFieldUpdateOperationsInput | Date | string
    dateEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    hours?: DateTimeFieldUpdateOperationsInput | Date | string
    foodId?: StringFieldUpdateOperationsInput | string
  }

  export type RaceCreateManyPetInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    picture?: string | null
  }

  export type VaccineCreateManyPetInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    description?: string | null
    recommendedAge: number
    boosterInterval: number
    mandatoryCountry?: NullableJsonNullValueInput | InputJsonValue
    recommendedCountry?: NullableJsonNullValueInput | InputJsonValue
  }

  export type RaceUpdateWithoutPetInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    clientPet?: ClientPetUpdateManyWithoutRaceNestedInput
  }

  export type RaceUncheckedUpdateWithoutPetInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    clientPet?: ClientPetUncheckedUpdateManyWithoutRaceNestedInput
  }

  export type RaceUncheckedUpdateManyWithoutPetInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    picture?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VaccineUpdateWithoutPetInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    recommendedAge?: IntFieldUpdateOperationsInput | number
    boosterInterval?: IntFieldUpdateOperationsInput | number
    mandatoryCountry?: NullableJsonNullValueInput | InputJsonValue
    recommendedCountry?: NullableJsonNullValueInput | InputJsonValue
    personalPetVaccine?: PersonalPetVaccineUpdateManyWithoutVaccineNestedInput
  }

  export type VaccineUncheckedUpdateWithoutPetInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    recommendedAge?: IntFieldUpdateOperationsInput | number
    boosterInterval?: IntFieldUpdateOperationsInput | number
    mandatoryCountry?: NullableJsonNullValueInput | InputJsonValue
    recommendedCountry?: NullableJsonNullValueInput | InputJsonValue
    personalPetVaccine?: PersonalPetVaccineUncheckedUpdateManyWithoutVaccineNestedInput
  }

  export type VaccineUncheckedUpdateManyWithoutPetInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    recommendedAge?: IntFieldUpdateOperationsInput | number
    boosterInterval?: IntFieldUpdateOperationsInput | number
    mandatoryCountry?: NullableJsonNullValueInput | InputJsonValue
    recommendedCountry?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ClientPetCreateManyRaceInput = {
    id?: string
    name: string
    dateOfBirth: Date | string
    description?: string | null
    activity?: number | null
    attendingVeterinarianId?: string | null
    clientId: string
  }

  export type ClientPetUpdateWithoutRaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    activity?: NullableIntFieldUpdateOperationsInput | number | null
    attendingVeterinarian?: VeterinarianProfileUpdateOneWithoutClientPetNestedInput
    client?: ClientProfileUpdateOneRequiredWithoutClientPetNestedInput
    personalPetVaccine?: PersonalPetVaccineUpdateManyWithoutClientPetNestedInput
    metting?: MettingUpdateManyWithoutClientPetNestedInput
    foodPets?: FoodPetUpdateManyWithoutClientPetNestedInput
  }

  export type ClientPetUncheckedUpdateWithoutRaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    activity?: NullableIntFieldUpdateOperationsInput | number | null
    attendingVeterinarianId?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    personalPetVaccine?: PersonalPetVaccineUncheckedUpdateManyWithoutClientPetNestedInput
    metting?: MettingUncheckedUpdateManyWithoutClientPetNestedInput
    foodPets?: FoodPetUncheckedUpdateManyWithoutClientPetNestedInput
  }

  export type ClientPetUncheckedUpdateManyWithoutRaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    activity?: NullableIntFieldUpdateOperationsInput | number | null
    attendingVeterinarianId?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
  }

  export type PersonalPetVaccineCreateManyVaccineInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    clientPetId: string
    mettingId?: string | null
  }

  export type PersonalPetVaccineUpdateWithoutVaccineInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientPet?: ClientPetUpdateOneRequiredWithoutPersonalPetVaccineNestedInput
    metting?: MettingUpdateOneWithoutPersonalPetVaccineNestedInput
  }

  export type PersonalPetVaccineUncheckedUpdateWithoutVaccineInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientPetId?: StringFieldUpdateOperationsInput | string
    mettingId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PersonalPetVaccineUncheckedUpdateManyWithoutVaccineInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientPetId?: StringFieldUpdateOperationsInput | string
    mettingId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PersonalPetVaccineCreateManyMettingInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    clientPetId: string
    vaccineId: string
  }

  export type PersonalPetVaccineUpdateWithoutMettingInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientPet?: ClientPetUpdateOneRequiredWithoutPersonalPetVaccineNestedInput
    vaccine?: VaccineUpdateOneRequiredWithoutPersonalPetVaccineNestedInput
  }

  export type PersonalPetVaccineUncheckedUpdateWithoutMettingInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientPetId?: StringFieldUpdateOperationsInput | string
    vaccineId?: StringFieldUpdateOperationsInput | string
  }

  export type PersonalPetVaccineUncheckedUpdateManyWithoutMettingInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientPetId?: StringFieldUpdateOperationsInput | string
    vaccineId?: StringFieldUpdateOperationsInput | string
  }

  export type ClinicProductCreateManyProductInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    stock?: number
    minimumRequired: number
    clinicId: string
  }

  export type ClinicProductUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stock?: IntFieldUpdateOperationsInput | number
    minimumRequired?: IntFieldUpdateOperationsInput | number
    clinic?: ClientProfileUpdateOneRequiredWithoutClinicProductsNestedInput
  }

  export type ClinicProductUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stock?: IntFieldUpdateOperationsInput | number
    minimumRequired?: IntFieldUpdateOperationsInput | number
    clinicId?: StringFieldUpdateOperationsInput | string
  }

  export type ClinicProductUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stock?: IntFieldUpdateOperationsInput | number
    minimumRequired?: IntFieldUpdateOperationsInput | number
    clinicId?: StringFieldUpdateOperationsInput | string
  }

  export type FoodPetCreateManyFoodInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    type: $Enums.FoodPetDay
    dateStart: Date | string
    dateEnd?: Date | string | null
    quantity: Decimal | DecimalJsLike | number | string
    hours: Date | string
    clientPetId: string
  }

  export type FoodPetUpdateWithoutFoodInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumFoodPetDayFieldUpdateOperationsInput | $Enums.FoodPetDay
    dateStart?: DateTimeFieldUpdateOperationsInput | Date | string
    dateEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    hours?: DateTimeFieldUpdateOperationsInput | Date | string
    clientPet?: ClientPetUpdateOneRequiredWithoutFoodPetsNestedInput
  }

  export type FoodPetUncheckedUpdateWithoutFoodInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumFoodPetDayFieldUpdateOperationsInput | $Enums.FoodPetDay
    dateStart?: DateTimeFieldUpdateOperationsInput | Date | string
    dateEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    hours?: DateTimeFieldUpdateOperationsInput | Date | string
    clientPetId?: StringFieldUpdateOperationsInput | string
  }

  export type FoodPetUncheckedUpdateManyWithoutFoodInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumFoodPetDayFieldUpdateOperationsInput | $Enums.FoodPetDay
    dateStart?: DateTimeFieldUpdateOperationsInput | Date | string
    dateEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    hours?: DateTimeFieldUpdateOperationsInput | Date | string
    clientPetId?: StringFieldUpdateOperationsInput | string
  }

  export type ProductCreateManyBrandInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    description?: string | null
    qrCode: string
    websiteUrl?: string | null
    picture?: string | null
  }

  export type ProductUpdateWithoutBrandInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    qrCode?: StringFieldUpdateOperationsInput | string
    websiteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    clinicProducts?: ClinicProductUpdateManyWithoutProductNestedInput
    Food?: FoodUpdateOneWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutBrandInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    qrCode?: StringFieldUpdateOperationsInput | string
    websiteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    clinicProducts?: ClinicProductUncheckedUpdateManyWithoutProductNestedInput
    Food?: FoodUncheckedUpdateOneWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutBrandInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    qrCode?: StringFieldUpdateOperationsInput | string
    websiteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ClientPetCreateManyClientInput = {
    id?: string
    name: string
    dateOfBirth: Date | string
    description?: string | null
    activity?: number | null
    attendingVeterinarianId?: string | null
    raceId: string
  }

  export type ClinicProductCreateManyClinicInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    stock?: number
    minimumRequired: number
    productId: string
  }

  export type ClientPetUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    activity?: NullableIntFieldUpdateOperationsInput | number | null
    attendingVeterinarian?: VeterinarianProfileUpdateOneWithoutClientPetNestedInput
    race?: RaceUpdateOneRequiredWithoutClientPetNestedInput
    personalPetVaccine?: PersonalPetVaccineUpdateManyWithoutClientPetNestedInput
    metting?: MettingUpdateManyWithoutClientPetNestedInput
    foodPets?: FoodPetUpdateManyWithoutClientPetNestedInput
  }

  export type ClientPetUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    activity?: NullableIntFieldUpdateOperationsInput | number | null
    attendingVeterinarianId?: NullableStringFieldUpdateOperationsInput | string | null
    raceId?: StringFieldUpdateOperationsInput | string
    personalPetVaccine?: PersonalPetVaccineUncheckedUpdateManyWithoutClientPetNestedInput
    metting?: MettingUncheckedUpdateManyWithoutClientPetNestedInput
    foodPets?: FoodPetUncheckedUpdateManyWithoutClientPetNestedInput
  }

  export type ClientPetUncheckedUpdateManyWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    activity?: NullableIntFieldUpdateOperationsInput | number | null
    attendingVeterinarianId?: NullableStringFieldUpdateOperationsInput | string | null
    raceId?: StringFieldUpdateOperationsInput | string
  }

  export type ClinicProductUpdateWithoutClinicInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stock?: IntFieldUpdateOperationsInput | number
    minimumRequired?: IntFieldUpdateOperationsInput | number
    product?: ProductUpdateOneRequiredWithoutClinicProductsNestedInput
  }

  export type ClinicProductUncheckedUpdateWithoutClinicInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stock?: IntFieldUpdateOperationsInput | number
    minimumRequired?: IntFieldUpdateOperationsInput | number
    productId?: StringFieldUpdateOperationsInput | string
  }

  export type ClinicProductUncheckedUpdateManyWithoutClinicInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stock?: IntFieldUpdateOperationsInput | number
    minimumRequired?: IntFieldUpdateOperationsInput | number
    productId?: StringFieldUpdateOperationsInput | string
  }

  export type ClinicProfileCreateManyVeterinarianProfileInput = {
    id?: string
    name: string
    address: string
    siret: string
    phone: string
    description?: string | null
    website: string
    userId: string
  }

  export type ClientPetCreateManyAttendingVeterinarianInput = {
    id?: string
    name: string
    dateOfBirth: Date | string
    description?: string | null
    activity?: number | null
    clientId: string
    raceId: string
  }

  export type MettingCreateManyVeterinarianInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    date: Date | string
    duration: Decimal | DecimalJsLike | number | string
    description?: string | null
    petWeight?: number | null
    petSize?: number | null
    clientPetId: string
  }

  export type ClinicProfileUpdateWithoutVeterinarianProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    siret?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutClinicProfileNestedInput
  }

  export type ClinicProfileUncheckedUpdateWithoutVeterinarianProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    siret?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type ClinicProfileUncheckedUpdateManyWithoutVeterinarianProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    siret?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type ClientPetUpdateWithoutAttendingVeterinarianInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    activity?: NullableIntFieldUpdateOperationsInput | number | null
    client?: ClientProfileUpdateOneRequiredWithoutClientPetNestedInput
    race?: RaceUpdateOneRequiredWithoutClientPetNestedInput
    personalPetVaccine?: PersonalPetVaccineUpdateManyWithoutClientPetNestedInput
    metting?: MettingUpdateManyWithoutClientPetNestedInput
    foodPets?: FoodPetUpdateManyWithoutClientPetNestedInput
  }

  export type ClientPetUncheckedUpdateWithoutAttendingVeterinarianInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    activity?: NullableIntFieldUpdateOperationsInput | number | null
    clientId?: StringFieldUpdateOperationsInput | string
    raceId?: StringFieldUpdateOperationsInput | string
    personalPetVaccine?: PersonalPetVaccineUncheckedUpdateManyWithoutClientPetNestedInput
    metting?: MettingUncheckedUpdateManyWithoutClientPetNestedInput
    foodPets?: FoodPetUncheckedUpdateManyWithoutClientPetNestedInput
  }

  export type ClientPetUncheckedUpdateManyWithoutAttendingVeterinarianInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    activity?: NullableIntFieldUpdateOperationsInput | number | null
    clientId?: StringFieldUpdateOperationsInput | string
    raceId?: StringFieldUpdateOperationsInput | string
  }

  export type MettingUpdateWithoutVeterinarianInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    petWeight?: NullableIntFieldUpdateOperationsInput | number | null
    petSize?: NullableIntFieldUpdateOperationsInput | number | null
    clientPet?: ClientPetUpdateOneRequiredWithoutMettingNestedInput
    personalPetVaccine?: PersonalPetVaccineUpdateManyWithoutMettingNestedInput
  }

  export type MettingUncheckedUpdateWithoutVeterinarianInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    petWeight?: NullableIntFieldUpdateOperationsInput | number | null
    petSize?: NullableIntFieldUpdateOperationsInput | number | null
    clientPetId?: StringFieldUpdateOperationsInput | string
    personalPetVaccine?: PersonalPetVaccineUncheckedUpdateManyWithoutMettingNestedInput
  }

  export type MettingUncheckedUpdateManyWithoutVeterinarianInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    petWeight?: NullableIntFieldUpdateOperationsInput | number | null
    petSize?: NullableIntFieldUpdateOperationsInput | number | null
    clientPetId?: StringFieldUpdateOperationsInput | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}